<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Spring学习日记01：基础概念与IoC</title>
      <link href="/2022/06/30/spring01/"/>
      <url>/2022/06/30/spring01/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-学习日记01：基础概念与IoC"><a href="#Spring-学习日记01：基础概念与IoC" class="headerlink" title="Spring 学习日记01：基础概念与IoC"></a>Spring 学习日记01：基础概念与IoC</h1><h2 id="Spring是什么？"><a href="#Spring是什么？" class="headerlink" title="Spring是什么？"></a>Spring是什么？</h2><p><strong>历史背景：</strong>简单的说就是以前Java用的EJB框架存在许多问题，不好用，一个大佬就写了本书叫&lt;不用EJB进行JAVA开发&gt;，后面blblbl产生了Spring。</p><p>SpringFramework是一个轻量级J2EE开发解决方案（框架）–Spring。目前最新版本为5.X。</p><p>Spring框架包含几个模块，例如 IOC，AOP，DAO，Context，ORM，WEB MVC 等。</p><h2 id="Spring全家桶有哪些？"><a href="#Spring全家桶有哪些？" class="headerlink" title="Spring全家桶有哪些？"></a>Spring全家桶有哪些？</h2><p>SpringFramework（依赖注入、事务处理、webapps、数据访问）</p><p>Spring MVC</p><p>SpringBoot</p><p>Spring Cloud（分布式、微服务）</p><h2 id="Spring的优点"><a href="#Spring的优点" class="headerlink" title="Spring的优点"></a>Spring的优点</h2><ul><li>轻量级</li></ul><pre class=" language-markdown"><code class="language-markdown">1.对于运行环境没有额外要求<span class="token code keyword">    开源 tomcat resion jetty</span>2.代码移植性高<span class="token code keyword">    不需要实现额外接口</span></code></pre><ul><li>JavaEE的解决方案</li></ul><p>​<strong>Java开发体系<img src="/2022/06/30/spring01/image-20220630181036070.png" alt="Java开发体系"></strong></p><ul><li>整合了<strong>设计模式(Design Pattern)</strong></li></ul><pre class=" language-markdown"><code class="language-markdown">1、工厂2、代理3、模板4、策略</code></pre><h2 id="Spring-Framework做了什么？"><a href="#Spring-Framework做了什么？" class="headerlink" title="Spring Framework做了什么？"></a>Spring Framework做了什么？</h2><p>支持控制反转(<strong>IoC</strong>) ,通过依赖注入(<strong>DI</strong>)来实现</p><p>支持面向切面编程(<strong>AOP</strong>)</p><h2 id="控制反转（Inversion-of-Control）与工厂模式"><a href="#控制反转（Inversion-of-Control）与工厂模式" class="headerlink" title="控制反转（Inversion of Control）与工厂模式"></a>控制反转（Inversion of Control）与工厂模式</h2><p><strong>所谓IoC，对于spring框架来说，就是由spring来负责控制对象的生命周期和对象间的关系。</strong></p><p>举个例子。没有IoC之前，我们假设要设计一个 耳机、一个 手机(Phone)，通常都是通过面向对象来new的方式。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AirPod</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">play</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Phone</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> AirPod airPod<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Phone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 1.Phone是依赖于airPod的类</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>airPod <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AirPod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>airPod<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"I am an airPod."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">play</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>airPod<span class="token punctuation">.</span><span class="token function">play</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span> args <span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 1.Phone类依赖于AirPod这个具体类</span>        <span class="token comment" spellcheck="true">// 编译时如果没有AirPod这个类一定会出错</span>        Phone phone <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Phone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        phone<span class="token punctuation">.</span><span class="token function">play</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>这样做的弊端有：</p><p>1.如果AirPod还没有实现的情况，编译是通不过的。</p><p>2.假设我们以后新创建了一个类(AirPod2)以后。原来的代码都是固定死的，不易进行代码更新维护。</p><p><strong>一种简单的处理方案：</strong></p><p>通过接口来降低手机类与耳机类的耦合，这就算一种IoC的思想：使用 <strong>抽象</strong> 的 ， 而不使用 <strong>具体</strong> 的。设计一个接口类。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IEarPhone</span><span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">play</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AirPod</span> <span class="token keyword">implements</span> <span class="token class-name">IEarPhone</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">play</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Phone</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> IEarPhone airPod<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Phone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 2.此时Phone类不再依赖于接口IEarPhone，但是new AirPod依然依赖AirPod</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>airPod <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AirPod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>airPod<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"I am an airPod."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">play</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>airPod<span class="token punctuation">.</span><span class="token function">play</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>但是目前，如果AirPod还没有实现的情况，编译还是通不过的。</p><p>现在我们就要谈到一个重要的东西——工厂模式。</p><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>概念：工厂方法模式基于”输入”，应用在超类和多个子类之间的情况，这种模式将创建对象的责任转移到工厂类，通过工厂类的工厂方法来创建对象。</p><p><strong>好处：</strong>1.面向接口编程，体现了面向对象的思想；2.将创建对象的工作转移到了工厂类，解耦合；</p><p>现在用工厂模式来对手机与耳机的关系进行操作代价就小很多了。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 静态工厂：用于创造实例并返回实例的方法。使用时不需要实例化工厂</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BeanFactory</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> IEarPhone <span class="token function">getEarPhone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">AirPod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>但是!!!目前，如果AirPod还没有实现的情况，编译还是通不过的。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Phone</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> IEarPhone airPod<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Phone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 3.使用静态工厂,Phone类不再依赖于AirPod，而BeanFactory依赖于AirPod</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>airPod <span class="token operator">=</span> BeanFactory<span class="token punctuation">.</span><span class="token function">getEarPhone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>airPod<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"I am an airPod."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">play</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>airPod<span class="token punctuation">.</span><span class="token function">play</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>所以我们要利用反射的技术了</p><h3 id="工厂模式-（配置-反射）-》DI-Dependecy-Injection"><a href="#工厂模式-（配置-反射）-》DI-Dependecy-Injection" class="headerlink" title="工厂模式+（配置+反射）-》DI (Dependecy Injection)"></a>工厂模式+（配置+反射）-》DI (Dependecy Injection)</h3><p>首先创建一个配置文件bean.properties(其实还可以使用xml形式配置)</p><pre class=" language-properties"><code class="language-properties"><span class="token attr-name">airPod</span><span class="token punctuation">=</span><span class="token attr-value">cn.silverCorridors.AirPod</span></code></pre><p>然后在工厂类中</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BeanFactory</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Properties props<span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span><span class="token punctuation">{</span>            props <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//Properties被替换的可能性极小</span>            InputStream in <span class="token operator">=</span> BeanFactory<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getResourceAsStream</span><span class="token punctuation">(</span><span class="token string">"bean.properties"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            props<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ExceptionInInitializerError</span><span class="token punctuation">(</span><span class="token string">"Cannot find bean.properties"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Object <span class="token function">getBean</span><span class="token punctuation">(</span>String beanName<span class="token punctuation">)</span><span class="token punctuation">{</span>        Object bean <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">try</span><span class="token punctuation">{</span>            String beanPath <span class="token operator">=</span> props<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>            bean <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>beanPath<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDeclaredConstructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> bean<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>此时Phone中的工厂就可以不用在依赖于AirPod啦</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Phone</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> IEarPhone airPod<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Phone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 4.静态工厂+配置文件+反射，BeanFactory不依赖于AirPod，但是运行时要求AirPod存在</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>airPod <span class="token operator">=</span> <span class="token punctuation">(</span>IEarPhone<span class="token punctuation">)</span> BeanFactory<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"airPod"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>airPod<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"I am an airPod."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">play</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>airPod<span class="token punctuation">.</span><span class="token function">play</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>通过这种方式，只要使用配置文件的方式就即时没有AirPod这个类也可以编译通过了。</p><h4 id="工厂模式的意义"><a href="#工厂模式的意义" class="headerlink" title="工厂模式的意义"></a>工厂模式的意义</h4><p>使用者只依赖于工厂类，而不依赖于资源</p><p>通过配置+反射，工厂类也可以不依赖于资源，只需要在运行时有资源即可。</p><h2 id="SpringFramework-容器"><a href="#SpringFramework-容器" class="headerlink" title="SpringFramework 容器"></a>SpringFramework 容器</h2><h4 id="Bean工厂"><a href="#Bean工厂" class="headerlink" title="Bean工厂"></a>Bean工厂</h4><p>Spring 容器并不是只有一个实现，而是自带了多个容器实现，可归纳为两种不同类型：bean 工厂、ApplicationContext。</p><p>bean工厂：由 org.springframework.beans.factory.BeanFactory接口定义；</p><p>ApplicationContext：由 org.springframework.context.ApplicationContext接口定义。</p><h4 id="ApplicationContext容器"><a href="#ApplicationContext容器" class="headerlink" title="ApplicationContext容器"></a>ApplicationContext容器</h4><p><em>Application Context</em> 是 spring 中较高级的容器。和 BeanFactory 类似，它可以加载配置文件中定义的 bean，将所有的 bean 集中在一起，当有请求的时候分配 bean。它增加了企业所需要的功能，比如，从属性文件从解析文本信息和将事件传递给所指定的监听器。</p><p>基础继承关系：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ApplicationContext</span> <span class="token keyword">extends</span> <span class="token class-name">EnvironmentCapable</span><span class="token punctuation">,</span> ListableBeanFactory<span class="token punctuation">,</span> HierarchicalBeanFactory<span class="token punctuation">,</span>        MessageSource<span class="token punctuation">,</span> ApplicationEventPublisher<span class="token punctuation">,</span> ResourcePatternResolver<span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><p>可见ApplicationContext是在BeanFactory基础上定义的，实际上ApplicationContext是BeanFactory的一个超全集。</p><h4 id="Bean与ApplicationContext两类别关系："><a href="#Bean与ApplicationContext两类别关系：" class="headerlink" title="Bean与ApplicationContext两类别关系："></a>Bean与ApplicationContext两类别关系：</h4><p>ApplicationContext 基于 BeanFactory 构建，并提供应用框架级别的服务，即BeanFactory是基础，ApplicationContext是一个提升。</p><h4 id="ApplicationContext的特点"><a href="#ApplicationContext的特点" class="headerlink" title="ApplicationContext的特点"></a>ApplicationContext的特点</h4><blockquote><p>特点1：单例</p><p>特点2：即时加载，是在load xml文件时就进行实例化</p></blockquote><h4 id="ApplicationContext-常用的接口实现类："><a href="#ApplicationContext-常用的接口实现类：" class="headerlink" title="ApplicationContext 常用的接口实现类："></a>ApplicationContext 常用的接口实现类：</h4><ul><li><strong>ClassPathXmlApplicationContext</strong>: 该容器读取resources下的XML文件并加载已被定义的 bean。在这里，你不需要提供 XML 文件的完整路径，只需正确配置 CLASSPATH 环境变量即可，因为，容器会从 CLASSPATH 中搜索 bean 配置文件。</li><li><strong>FileSystemXmlApplicationContext</strong>: 该容器从 XML 文件中加载已被定义的 bean。在这里，你需要提供给构造器 XML 文件的完整路径(<font color="red"><strong>绝对路径</strong></font>)</li><li><strong>WebXmlApplicationContext</strong>：该容器会在一个 web 应用程序的范围内加载在 XML 文件中已被定义的 bean。</li><li><strong>AnnotationConfigApplicationContext</strong>: 用于Annotation</li></ul><h2 id="使用SpringFramework来实现工厂模式-配置"><a href="#使用SpringFramework来实现工厂模式-配置" class="headerlink" title="使用SpringFramework来实现工厂模式+配置"></a>使用SpringFramework来实现工厂模式+配置</h2><p>通过上节在Java项目中自己手动设定配置文件的方式很麻烦，现在我们使用SpringFramework的自带容器来实现上节的操作。</p><h4 id="第一种方法：直接创造Bean"><a href="#第一种方法：直接创造Bean" class="headerlink" title="第一种方法：直接创造Bean"></a>第一种方法：直接创造Bean</h4><p>直接创造一个Bean，通过工厂类创造，通过静态工厂方法创造。</p><p>要求XML配置中只有 id 和 class， 要求Bean的类必须有默认构造函数(不带参数的)</p><p>XML中Bean的写法：</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>airPod<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cn.silverCorridors.AirPod<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span></code></pre><p>主程序中调用：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span> args <span class="token punctuation">)</span><span class="token punctuation">{</span>    ApplicationContext ac <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span><span class="token string">"bean.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    IEarPhone earPhone5 <span class="token operator">=</span> <span class="token punctuation">(</span>IEarPhone<span class="token punctuation">)</span> ac<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"airPod"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>earPhone5<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><h4 id="第二种方法：使用工厂方法"><a href="#第二种方法：使用工厂方法" class="headerlink" title="第二种方法：使用工厂方法"></a>第二种方法：使用工厂方法</h4><p>首先需要初始化工厂实例，然后调用工厂的实例方法返回Javabean实例</p><p>工厂实例：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BeanFactory2</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> IEarPhone <span class="token function">getAirPod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">AirPod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//暂时写new的方式，实际上应该用反射方式实现AirPod的初始化</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>XML中Bean的写法：</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- 2.第二种方法，使用工厂方法,首先需要实例化工厂实例，然后调用工厂实例方法返回类实例 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>beanFactory2<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cn.silverCorridors.BeanFactory2<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>airPod<span class="token punctuation">"</span></span> <span class="token attr-name">factory-bean</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>beanFactory2<span class="token punctuation">"</span></span> <span class="token attr-name">factory-method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>getAirPod<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span></code></pre><h4 id="第三种方法：使用静态工厂的静态方法"><a href="#第三种方法：使用静态工厂的静态方法" class="headerlink" title="第三种方法：使用静态工厂的静态方法"></a>第三种方法：使用静态工厂的静态方法</h4><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- 3.第三种方法，使用静态工厂方法，需要知道静态工厂类和静态方法 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>airPod<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cn.silverCorridors.BeanFactory<span class="token punctuation">"</span></span> <span class="token attr-name">factory-method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>getBean<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>airPod<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span></code></pre><h2 id="Bean的作用范围"><a href="#Bean的作用范围" class="headerlink" title="Bean的作用范围"></a>Bean的作用范围</h2><p>当在 Spring 中定义一个 bean 时，你必须声明该 bean 的作用域的选项。例如，为了强制 Spring 在每次需要时都产生一个新的 bean 实例，你应该声明 bean 的作用域的属性为 <strong>prototype</strong>。同理，如果你想让 Spring 在每次需要时都返回同一个bean实例，你应该声明 bean 的作用域的属性为 <strong>singleton</strong>。Spring 框架支持以下五个作用域，分别为 singleton、prototype、request、session 和 global session，5种作用域说明如下所示，注意，如果你使用 web-aware ApplicationContext 时，其中三个是可用的。  </p><table><thead><tr><th align="left">作用域</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">singleton(单例)</td><td align="left">在spring IoC容器仅存在一个Bean实例，Bean以<strong>单例</strong>方式存在，默认值</td></tr><tr><td align="left">prototype(多例)</td><td align="left">每次从容器中调用Bean时，都返回一个新的实例（<strong>懒加载</strong>）。即每次调用getBean()时，相当于执行newXxxBean()</td></tr><tr><td align="left">request</td><td align="left">每次HTTP请求都会创建一个新的Bean，该作用域仅适用于WebApplicationContext环境。即在请求范围内是单例，跨请求是多例。</td></tr><tr><td align="left">session</td><td align="left">同一个HTTP Session共享一个Bean，不同Session使用不同的Bean，仅适用于WebApplicationContext环境。即在Session范围内是单例，跨Session是多例。</td></tr><tr><td align="left">global-session</td><td align="left">一般用于Portlet应用环境，该作用域仅适用于WebApplicationContext环境。在集群环境下，global-session的范围是单例，跨global-session是多例。在非集群环境下，他等同session。</td></tr></tbody></table><h2 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h2><p>当一个 bean 被实例化时，它可能需要执行一些初始化使它转换成可用状态。同样，当 bean 不再需要，并且从容器中移除时，可能需要做一些清除工作。尽管还有一些在 Bean 实例化和销毁之间发生的活动，但是本章将只讨论两个重要的生命周期回调方法，它们在 bean 的初始化和销毁的时候是必需的。</p><h4 id="Singleton模式中"><a href="#Singleton模式中" class="headerlink" title="Singleton模式中"></a>Singleton模式中</h4><ul><li>Bean初始化：即时加载，在load XML的时候进行实例化。</li><li>Bean的存在周期：只要容器存在，Bean就一直存在。</li><li>Bean的销毁：容器销毁的时候，Bean销毁</li></ul><p>还是那个例子，在AirPod里新加两个方法。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"init"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"destroy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>然后在xml文件中对AirPod的bean添加两个属性：</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>airPod<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cn.silverCorridors.AirPod<span class="token punctuation">"</span></span> <span class="token attr-name">scope</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>prototype<span class="token punctuation">"</span></span> <span class="token attr-name">init-method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>init<span class="token punctuation">"</span></span> <span class="token attr-name">destroy-method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>destroy<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span></code></pre><p>运行类中：</p><pre class=" language-java"><code class="language-java">ApplicationContext ac <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span><span class="token string">"bean.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>IEarPhone earPhone5 <span class="token operator">=</span> <span class="token punctuation">(</span>IEarPhone<span class="token punctuation">)</span> ac<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"airPod"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>运行结果：</p><pre class=" language-markdown"><code class="language-markdown">AirPod Constructor.init</code></pre><p>此时我们发现，init和构造器都被执行了，但是destroy没有执行。这是因为ApplicationContext还活着，需要调用ac.close并且需要将运行类中ac的类型改为ClassPathXmlApplicationContext</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 6.5 Bean的生命周期</span>ClassPathXmlApplicationContext ac <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span><span class="token string">"bean.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>IEarPhone earPhone5 <span class="token operator">=</span> <span class="token punctuation">(</span>IEarPhone<span class="token punctuation">)</span> ac<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"airPod"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ac<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>运行结果：</p><pre class=" language-markdown"><code class="language-markdown">AirPod Constructor.initdestroy</code></pre><h4 id="Prototype模式中"><a href="#Prototype模式中" class="headerlink" title="Prototype模式中"></a>Prototype模式中</h4><ul><li>Bean初始化：懒加载，当要getBean的时候进行实例化。</li><li>Bean的存在周期：由用户代码决定。</li><li>Bean的销毁：通过JVM的垃圾回收(GC)算法释放。<strong>即当没有变量指向该Bean以后，JVM在适当的时候Gc 该Bean。</strong></li></ul><p>与Singleton模式中不同，当运行上面代码时，我们不会看到destroy，因为Spring在Prototype模式下根本看不到这个生成的实例了。</p><p>所以这个被销毁时，Spring也是无法知道的。</p><h2 id="Spring总体学习模块"><a href="#Spring总体学习模块" class="headerlink" title="Spring总体学习模块"></a>Spring总体学习模块</h2><p><img src="/2022/06/30/spring01/mokuai.png" alt="mokuai"></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javaSE 面试题02</title>
      <link href="/2022/06/30/javasems02/"/>
      <url>/2022/06/30/javasems02/</url>
      
        <content type="html"><![CDATA[<h2 id="1-一个类的构造方法的作用是什么？构造方法有哪些特性？"><a href="#1-一个类的构造方法的作用是什么？构造方法有哪些特性？" class="headerlink" title="1. 一个类的构造方法的作用是什么？构造方法有哪些特性？"></a>1. 一个类的构造方法的作用是什么？构造方法有哪些特性？</h2><p>构造函数用于完成对象的初始化工作。</p><p>如果一个类没有声明构造函数，编译器会 为类生成默认的、不带参数的构造方法。</p><p>构造函数的特性：</p><p>1，名字与类名相同；</p><p>2，<strong>没有返回值，但不能用void声明构造函数</strong>；</p><p>3，生成类的对象时自动执行，无需调用</p><h2 id="2-静态方法和实例方法有何不同？"><a href="#2-静态方法和实例方法有何不同？" class="headerlink" title="2. 静态方法和实例方法有何不同？"></a>2. 静态方法和实例方法有何不同？</h2><p>两个方面：</p><ol><li>在外部调用静态方法时，可以使用”类名.方法名”的方式，也可以使用”对象名.方法名”的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。</li><li>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制</li></ol><h2 id="3-String对象是不是真的是不可变的？"><a href="#3-String对象是不是真的是不可变的？" class="headerlink" title="3. String对象是不是真的是不可变的？"></a>3. String对象是不是真的是不可变的？</h2><ol><li>String不可变，是说实例对象中的数组不可变。</li><li>但是，事实上是可以通过反射技术改变数组的</li></ol><h2 id="4-什么是反射？"><a href="#4-什么是反射？" class="headerlink" title="4. 什么是反射？"></a>4. 什么是反射？</h2><p><strong>什么是反射？</strong></p><p>在运行状态中，对于任意一个类，能够获取这个类的所有属性和方法，并且可以实例化。</p><p>在运行状态中，对于任意一个对象，能够获取这个实例的类的所有属性和方法，能够调用对象的任意一个方法和属性；</p><p>这种动态获取信息、以及动态调用对象方法的功能，称为java语言的反射机制。</p><p><strong>静态编译和动态编译</strong></p><p>​<strong>静态编译：</strong>代码写死，在编译时类型确定，绑定对象</p><p>​<strong>动态编译：</strong>运行时确定类型，绑定对象</p><p><strong>反射机制优缺点</strong></p><p>​<strong>优点：</strong> 灵活</p><p>​<strong>缺点：</strong> 影响性能</p><h2 id="5-List，Set，Map三者的区别："><a href="#5-List，Set，Map三者的区别：" class="headerlink" title="5. List，Set，Map三者的区别："></a>5. List，Set，Map三者的区别：</h2><p>​<strong>List：</strong> 有序，可重复</p><p>​<strong>Set：</strong> 不可重复，无序</p><p>​<strong>Map：</strong> Key-Value，不可重复</p><h2 id="6-ArrayList、LinkedList、Vector三者的区别："><a href="#6-ArrayList、LinkedList、Vector三者的区别：" class="headerlink" title="6. ArrayList、LinkedList、Vector三者的区别："></a>6. ArrayList、LinkedList、Vector三者的区别：</h2><p>​<strong>ArrayList：</strong> 底层使用数组，随机读取速度快（O(1)），但是插入删除需要移动数据（O(N)）</p><p>​<strong>LinkedList：</strong> 底层使用双向链表，随机读取速度慢（O(N)），但是插入删除不需要移动数据</p><p>​<strong>Vector：</strong> Vector是线程安全的，内部用的同步；ArrayList和LinkedList都不是线程安全的</p><h2 id="7-HashMap、HashSet、HashTable三者的区别："><a href="#7-HashMap、HashSet、HashTable三者的区别：" class="headerlink" title="7. HashMap、HashSet、HashTable三者的区别："></a>7. HashMap、HashSet、HashTable三者的区别：</h2><p>  <strong>HashMap：</strong> Key-Value方式，底层是哈希表，Key的判等是根据HashCode()和equals的返回决定，相同的Key，后面的写操作会覆盖以前的数据。</p><p>  <strong>HashSet：</strong>  使用实例本身计算HashCode当做key，本质也是HashMap，JDK1.8前底层是哈希数组+链表，JDK1.8开始是哈希数组+链表（个数大于8个）+红黑树（个数小于8个）</p><p>  <strong>HashTable：</strong> HashTable和HashMap很接近，区别仅在于HashTable是线程安全的，而前两者不是；另外，HashTable不允许Key是null，但是HashMap允许。</p><h2 id="8-HashMap、ConcurrentHashMap的区别"><a href="#8-HashMap、ConcurrentHashMap的区别" class="headerlink" title="8. HashMap、ConcurrentHashMap的区别"></a>8. HashMap、ConcurrentHashMap的区别</h2><p>​<strong>HashMap：</strong> HashMap不是线程安全的；允许Key是null</p><p>​<strong>ConcurrentHashMap：</strong> ConcurrentHashMap是线程安全的，与HashTable相比，HashTable使用的是synchronized的锁，而ConcurrentHashMap则将自己的Key空间进行了分段（Segment）加锁，并且在JDK1.8开始使用CAS，所以ConcurrentHashMap比HashTable具有更高的并发性能；不允许Key是null。</p><h2 id="9-comparable-和-comparator的区别？"><a href="#9-comparable-和-comparator的区别？" class="headerlink" title="9.comparable 和 comparator的区别？"></a>9.comparable 和 comparator的区别？</h2><p>​<strong>comparable：</strong>  接口，需要类Override compareTo方法，一个类只能有一种compareTo方法</p><p>​<strong>comparator：</strong> 接口，实现该接口的比较类是独立于被比较的类的，比较类需要Override compare方法，一个类可以有多个不同的比较类</p><h2 id="10-如何对Object的list排序？"><a href="#10-如何对Object的list排序？" class="headerlink" title="10. 如何对Object的list排序？"></a>10. 如何对Object的list排序？</h2><p>​对objects数组进行排序，我们可以用Arrays.sort()方法。</p><p>​对objects的集合进行排序，需要使用Collections.sort()方法。</p><h2 id="11-简述HashMap的工作原理以及分析源码"><a href="#11-简述HashMap的工作原理以及分析源码" class="headerlink" title="11. 简述HashMap的工作原理以及分析源码"></a>11. 简述HashMap的工作原理以及分析源码</h2><p>&lt;参考知识讲述中的HashMap，JDK1.8前底层是哈希数组+链表，JDK1.8开始是哈希数组+链表（个数大于8个）+红黑树（个数小于8个）&gt;</p><p><strong>简介</strong></p><p>HashMap主要用来存放键值对，它基于哈希表的Map接口实现，是常用的Java集合之一。与HashTable主要区别为不支持同步和允许null作为key和value，所以如果你想要保证线程安全，可以使用ConcurrentHashMap代替而不是线程安全的HashTable，因为HashTable基本已经被淘汰。</p><p><strong>内部结构分析</strong></p><p><strong>JDK1.8之前：</strong></p><p>JDK1.8之前HashMap底层是数组和链表结合在一起使用也就是链表散列。HashMap通过key的hashCode来计算hash值，当hashCode相同时，通过“拉链法”解决冲突。</p><p>所谓“拉链法”就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p><p><img src="/2022/06/30/javasems02/1.jpg" alt="jdk1.8之前的内部结构"></p><p>简单来说，JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的，如果定位到的数组位置不含链表（当前entry的next指向null）,那么对于查找，添加等操作很快，仅需一次寻址即可；如果定位到的数组包含链表，对于添加操作，其时间复杂度依然为O(1)，因为最新的Entry会插入链表头部，急需要简单改变引用链即可，而对于查找操作来讲，此时就需要遍历链表，然后通过key对象的equals方法逐一比对查找.</p><p><strong>JDK1.8之后：</strong></p><p>相比于之前的版本，jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。</p><p><img src="/2022/06/30/javasems02/2.jpg" alt="JDK1.8之后的内部结构"></p><p><strong>什么是哈希表？</strong></p><p>在讨论哈希表之前，我们先大概了解下其他数据结构在新增，查找等基础操作执行性能</p><p>　　<strong>数组</strong>：采用一段连续的存储单元来存储数据。对于指定下标的查找，时间复杂度为O(1)；通过给定值进行查找，需要遍历数组，逐一比对给定关键字和数组元素，时间复杂度为O(n)，当然，对于有序数组，则可采用二分查找，插值查找，斐波那契查找等方式，可将查找复杂度提高为O(logn)；对于一般的插入删除操作，涉及到数组元素的移动，其平均复杂度也为O(n)</p><p>　　<strong>线性链表</strong>：对于链表的新增，删除等操作（在找到指定操作位置后），仅需处理结点间的引用即可，时间复杂度为O(1)，而查找操作需要遍历链表逐一进行比对，复杂度为O(n)</p><p>　　<strong>二叉树</strong>：对一棵相对平衡的有序二叉树，对其进行插入，查找，删除等操作，平均复杂度均为O(logn)。</p><p>　　<strong>哈希表</strong>：相比上述几种数据结构，在哈希表中进行添加，删除，查找等操作，性能十分之高，不考虑哈希冲突的情况下，仅需一次定位即可完成，时间复杂度为O(1)，接下来我们就来看看哈希表是如何实现达到惊艳的常数阶O(1)的。</p><p>　　我们知道，数据结构的物理存储结构只有两种：<strong>顺序存储结构</strong>和<strong>链式存储结构</strong>（像栈，队列，树，图等是从逻辑结构去抽象的，映射到内存中，也这两种物理组织形式），而在上面我们提到过，在数组中根据下标查找某个元素，一次定位就可以达到，哈希表利用了这种特性，<strong>哈希表的主干就是数组</strong>。</p><p>　　比如我们要新增或查找某个元素，我们通过把当前元素的关键字 通过某个函数映射到数组中的某个位置，通过数组下标一次定位就可完成操作。</p><p>　　　　　　　　<strong>存储位置 = f(关键字)</strong></p><p>　　其中，这个函数f一般称为<strong>哈希函数</strong>，这个函数的设计好坏会直接影响到哈希表的优劣。举个例子，比如我们要在哈希表中执行插入操作：</p><p>　　<img src="/2022/06/30/javasems02/5.png" alt="img"></p><p>　　查找操作同理，先通过哈希函数计算出实际存储地址，然后从数组中对应地址取出即可。</p><p>　　<strong>哈希冲突</strong></p><p>　　然而万事无完美，如果两个不同的元素，通过哈希函数得出的实际存储地址相同怎么办？也就是说，当我们对某个元素进行哈希运算，得到一个存储地址，然后要进行插入的时候，发现已经被其他元素占用了，其实这就是所谓的<strong>哈希冲突</strong>，也叫哈希碰撞。前面我们提到过，哈希函数的设计至关重要，好的哈希函数会尽可能地保证 <strong>计算简单</strong>和<strong>散列地址分布均匀,<strong>但是，我们需要清楚的是，数组是一块连续的固定长度的内存空间，再好的哈希函数也不能保证得到的存储地址绝对不发生冲突。那么哈希冲突如何解决呢？哈希冲突的解决方案有多种:开放定址法（发生冲突，继续寻找下一块未被占用的存储地址），再散列函数法，链地址法，而HashMap即是采用了链地址法，也就是</strong>数组+链表</strong>的方式。</p><p><strong>类的属性：</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractMap</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">Map</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">,</span> Cloneable<span class="token punctuation">,</span> Serializable <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 序列号</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> 362498820763181265L<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 默认的初始容量是16</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEFAULT_INITIAL_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 最大容量</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAXIMUM_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">30</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 默认的填充因子</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">float</span> DEFAULT_LOAD_FACTOR <span class="token operator">=</span> <span class="token number">0.75f</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 当桶(bucket)上的结点数大于这个值时会转成红黑树</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TREEIFY_THRESHOLD <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 当桶(bucket)上的结点数小于这个值时树转链表</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> UNTREEIFY_THRESHOLD <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 桶中结构转化为红黑树对应的table的最小大小</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MIN_TREEIFY_CAPACITY <span class="token operator">=</span> <span class="token number">64</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 存储元素的数组，总是2的幂次倍</span>    <span class="token keyword">transient</span> Node<span class="token operator">&lt;</span>k<span class="token punctuation">,</span>v<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 存放具体元素的集</span>    <span class="token keyword">transient</span> Set<span class="token operator">&lt;</span>map<span class="token punctuation">.</span>entry<span class="token operator">&lt;</span>k<span class="token punctuation">,</span>v<span class="token operator">>></span> entrySet<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 存放元素的个数，注意这个不等于数组的长度。</span>    <span class="token keyword">transient</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 每次扩容和更改map结构的计数器</span>    <span class="token keyword">transient</span> <span class="token keyword">int</span> modCount<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容</span>    <span class="token keyword">int</span> threshold<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 填充因子</span>    <span class="token keyword">final</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>HashMap实现原理</strong></p><p>HashMap的主干是一个Entry数组。Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//HashMap的主干数组，可以看到就是一个Entry数组，初始值为空数组{}，主干数组的长度一定是2的次幂，至于为什么这么做，后面会有详细分析。</span><span class="token keyword">transient</span> Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> table <span class="token operator">=</span> <span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> EMPTY_TABLE<span class="token punctuation">;</span></code></pre><p> Entry是HashMap中的一个静态内部类。代码如下</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> K key<span class="token punctuation">;</span>        V value<span class="token punctuation">;</span>        Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//存储指向下一个Entry的引用，单链表结构</span>        <span class="token keyword">int</span> hash<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//对key的hashcode值进行hash运算后得到的值，存储在Entry，避免重复计算</span>        <span class="token comment" spellcheck="true">/**         * Creates new entry.         */</span>        <span class="token function">Entry</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">,</span> K k<span class="token punctuation">,</span> V v<span class="token punctuation">,</span> Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>            value <span class="token operator">=</span> v<span class="token punctuation">;</span>            next <span class="token operator">=</span> n<span class="token punctuation">;</span>            key <span class="token operator">=</span> k<span class="token punctuation">;</span>            hash <span class="token operator">=</span> h<span class="token punctuation">;</span>        <span class="token punctuation">}</span> </code></pre><p> 所以，HashMap的整体结构如下</p><p><img src="/2022/06/30/javasems02/6.png" alt="img">　　</p><p>　　<strong>简单来说，HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的，如果定位到的数组位置不含链表（当前entry的next指向null）,那么对于查找，添加等操作很快，仅需一次寻址即可；如果定位到的数组包含链表，对于添加操作，其时间复杂度为O(n)，首先遍历链表，存在即覆盖，否则新增；对于查找操作来讲，仍需遍历链表，然后通过key对象的equals方法逐一比对查找。所以，性能考虑，HashMap中的链表出现越少，性能才会越好。</strong></p><p>其他几个重要字段</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//实际存储的key-value键值对的个数</span><span class="token keyword">transient</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//阈值，当table == {}时，该值为初始容量（初始容量默认为16）；当table被填充了，也就是为table分配内存空间后，threshold一般为 capacity*loadFactory。HashMap在进行扩容时需要参考threshold，后面会详细谈到</span><span class="token keyword">int</span> threshold<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//负载因子，代表了table的填充度有多少，默认是0.75</span><span class="token keyword">final</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//用于快速失败，由于HashMap非线程安全，在对HashMap进行迭代时，如果期间其他线程的参与导致HashMap的结构发生变化了（比如put，remove等操作），需要抛出异常ConcurrentModificationException</span><span class="token keyword">transient</span> <span class="token keyword">int</span> modCount<span class="token punctuation">;</span></code></pre><p>HashMap有4个构造器，其他构造器如果用户没有传入initialCapacity 和loadFactor这两个参数，会使用默认值</p><p>initialCapacity默认为16，loadFactory默认为0.75</p><p>我们看下其中一个</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">)</span> <span class="token punctuation">{</span>　　　　　<span class="token comment" spellcheck="true">//此处对传入的初始容量进行校验，最大不能超过MAXIMUM_CAPACITY = 1&lt;&lt;30(230)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal initial capacity: "</span> <span class="token operator">+</span>                                               initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">></span> MAXIMUM_CAPACITY<span class="token punctuation">)</span>            initialCapacity <span class="token operator">=</span> MAXIMUM_CAPACITY<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>loadFactor <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> Float<span class="token punctuation">.</span><span class="token function">isNaN</span><span class="token punctuation">(</span>loadFactor<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal load factor: "</span> <span class="token operator">+</span>                                               loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> loadFactor<span class="token punctuation">;</span>        threshold <span class="token operator">=</span> initialCapacity<span class="token punctuation">;</span>　　　　　        <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//init方法在HashMap中没有实际实现，不过在其子类如 linkedHashMap中就会有对应实现</span>    <span class="token punctuation">}</span></code></pre><p>　　从上面这段代码我们可以看出，<strong>在常规构造器中，没有为数组table分配内存空间（有一个入参为指定Map的构造器例外），而是在执行put操作的时候才真正构建table数组</strong></p><p>　　OK,接下来我们来看看put操作的实现吧</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> V <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//如果table数组为空数组{}，进行数组填充（为table分配实际内存空间），入参为threshold，此时threshold为initialCapacity 默认是1&lt;&lt;4(24=16)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>table <span class="token operator">==</span> EMPTY_TABLE<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">inflateTable</span><span class="token punctuation">(</span>threshold<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>       <span class="token comment" spellcheck="true">//如果key为null，存储位置为table[0]或table[0]的冲突链上</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token function">putForNullKey</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//对key的hashcode进一步计算，确保散列均匀</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//获取在table中的实际位置</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> e <span class="token operator">!=</span> null<span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//如果该对应数据已存在，执行覆盖操作。用新value替换旧value，并返回旧value</span>            Object k<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                V oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>                e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>                e<span class="token punctuation">.</span><span class="token function">recordAccess</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        modCount<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//保证并发访问时，若HashMap内部结构发生变化，快速响应失败</span>        <span class="token function">addEntry</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//新增一个entry</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    </code></pre><p> 先来看看inflateTable这个方法</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">inflateTable</span><span class="token punctuation">(</span><span class="token keyword">int</span> toSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> capacity <span class="token operator">=</span> <span class="token function">roundUpToPowerOf2</span><span class="token punctuation">(</span>toSize<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//capacity一定是2的次幂</span>        threshold <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>capacity <span class="token operator">*</span> loadFactor<span class="token punctuation">,</span> MAXIMUM_CAPACITY <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//此处为threshold赋值，取capacity*loadFactor和MAXIMUM_CAPACITY+1的最小值，capaticy一定不会超过MAXIMUM_CAPACITY，除非loadFactor大于1</span>        table <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">[</span>capacity<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">initHashSeedAsNeeded</span><span class="token punctuation">(</span>capacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>　　inflateTable这个方法用于为主干数组table在内存中分配存储空间，通过roundUpToPowerOf2(toSize)可以确保capacity为大于或等于toSize的最接近toSize的二次幂，比如toSize=13,则capacity=16;to_size=16,capacity=16;to_size=17,capacity=32.</p><pre class=" language-java"><code class="language-java"> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">roundUpToPowerOf2</span><span class="token punctuation">(</span><span class="token keyword">int</span> number<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// assert number >= 0 : "number must be non-negative";</span>        <span class="token keyword">return</span> number <span class="token operator">>=</span> MAXIMUM_CAPACITY                <span class="token operator">?</span> MAXIMUM_CAPACITY                <span class="token operator">:</span> <span class="token punctuation">(</span>number <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">?</span> Integer<span class="token punctuation">.</span><span class="token function">highestOneBit</span><span class="token punctuation">(</span><span class="token punctuation">(</span>number <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>roundUpToPowerOf2中的这段处理使得数组长度一定为2的次幂，Integer.highestOneBit是用来获取最左边的bit（其他bit位为0）所代表的数值.</p><p>hash函数</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//这是一个神奇的函数，用了很多的异或，移位等运算，对key的hashcode进一步进行计算以及二进制位的调整等来保证最终获取的存储位置尽量分布均匀</span><span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span>Object k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> h <span class="token operator">=</span> hashSeed<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">!=</span> h <span class="token operator">&amp;&amp;</span> k <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>Hashing<span class="token punctuation">.</span><span class="token function">stringHash32</span><span class="token punctuation">(</span><span class="token punctuation">(</span>String<span class="token punctuation">)</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        h <span class="token operator">^=</span> k<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        h <span class="token operator">^=</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> h <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>以上hash函数计算出的值，通过indexFor进一步处理来获取实际的存储位置</p><pre class=" language-java"><code class="language-java">　　<span class="token comment" spellcheck="true">/**     * 返回数组下标     */</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">indexFor</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> h <span class="token operator">&amp;</span> <span class="token punctuation">(</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>h&amp;（length-1）保证获取的index一定在数组范围内，举个例子，默认容量16，length-1=15，h=18,转换成二进制计算为</p><pre class=" language-java"><code class="language-java">        <span class="token number">1</span>  <span class="token number">0</span>  <span class="token number">0</span>  <span class="token number">1</span>  <span class="token number">0</span>    <span class="token operator">&amp;</span>   <span class="token number">0</span>  <span class="token number">1</span>  <span class="token number">1</span>  <span class="token number">1</span>  <span class="token number">1</span>    __________________        <span class="token number">0</span>  <span class="token number">0</span>  <span class="token number">0</span>  <span class="token number">1</span>  <span class="token number">0</span>    <span class="token operator">=</span> <span class="token number">2</span></code></pre><p>　　最终计算出的index=2。有些版本的对于此处的计算会使用 取模运算，也能保证index一定在数组范围内，不过位运算对计算机来说，性能更高一些（HashMap中有大量位运算）</p><p>所以最终存储位置的确定流程是这样的：</p><p><img src="/2022/06/30/javasems02/7.png" alt="img"></p><p>再来看看addEntry的实现：</p><pre><code>void addEntry(int hash, K key, V value, int bucketIndex) {        if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) {            resize(2 * table.length);//当size超过临界阈值threshold，并且即将发生哈希冲突时进行扩容            hash = (null != key) ? hash(key) : 0;            bucketIndex = indexFor(hash, table.length);        }        createEntry(hash, key, value, bucketIndex);    }</code></pre><p>　　通过以上代码能够得知，当发生哈希冲突并且size大于阈值的时候，需要进行数组扩容，扩容时，需要新建一个长度为之前数组2倍的新的数组，然后将当前的Entry数组中的元素全部传输过去，扩容后的新数组长度为之前的2倍，所以扩容相对来说是个耗资源的操作。</p><p><strong>(1)loadFactor加载因子</strong></p><p>loadFactor加载因子是控制数组存放数据的疏密程度，loadFactor越趋近于1，那么   数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，load   Factor越小，也就是趋近于0，</p><p><strong>loadFactor太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor的默认值为0.75f是官方给出的一个比较好的临界值</strong>。  </p><p><strong>(2)threshold</strong></p><p><strong>threshold = capacity * loadFactor</strong>，<strong>当Size&gt;=threshold</strong>的时候，那么就要考虑对数组的扩增了，也就是说，这个的意思就是 <strong>衡量数组是否需要扩增的一个标准</strong>。</p><p><strong>为什么HashMap的数组长度一定是2的次幂？</strong></p><p>我们来继续看上面提到的resize方法</p><pre class=" language-java"><code class="language-java"> <span class="token keyword">void</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token keyword">int</span> newCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> oldTable <span class="token operator">=</span> table<span class="token punctuation">;</span>        <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> oldTable<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">==</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token punctuation">{</span>            threshold <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> newTable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">[</span>newCapacity<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">transfer</span><span class="token punctuation">(</span>newTable<span class="token punctuation">,</span> <span class="token function">initHashSeedAsNeeded</span><span class="token punctuation">(</span>newCapacity<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        table <span class="token operator">=</span> newTable<span class="token punctuation">;</span>        threshold <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>newCapacity <span class="token operator">*</span> loadFactor<span class="token punctuation">,</span> MAXIMUM_CAPACITY <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>如果数组进行扩容，数组长度发生变化，而存储位置 index = h&amp;(length-1),index也可能会发生变化，需要重新计算index，我们先来看看transfer这个方法</p><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span>Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> newTable<span class="token punctuation">,</span> <span class="token keyword">boolean</span> rehash<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> newTable<span class="token punctuation">.</span>length<span class="token punctuation">;</span>　　　　　<span class="token comment" spellcheck="true">//for循环中的代码，逐个遍历链表，重新计算索引位置，将老数组数据复制到新数组中去（数组不存储实际数据，所以仅仅是拷贝引用而已）</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">:</span> table<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>null <span class="token operator">!=</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>rehash<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span>hash <span class="token operator">=</span> null <span class="token operator">==</span> e<span class="token punctuation">.</span>key <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token function">hash</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>　　　　　　　　　 <span class="token comment" spellcheck="true">//将当前entry的next链指向新的索引位置,newTable[i]有可能为空，有可能也是个entry链，如果是entry链，直接在链表头部插入。</span>                e<span class="token punctuation">.</span>next <span class="token operator">=</span> newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>                e <span class="token operator">=</span> next<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>　　这个方法将老数组中的数据逐个链表地遍历，扔到新的扩容后的数组中，我们的数组索引位置的计算是通过 对key值的hashcode进行hash扰乱运算后，再通过和 length-1进行位运算得到最终数组索引位置。</p><p>　　hashMap的数组长度一定保持2的次幂，比如16的二进制表示为 10000，那么length-1就是15，二进制为01111，同理扩容后的数组长度为32，二进制表示为100000，length-1为31，二进制表示为011111。从下图可以我们也能看到这样会保证低位全为1，而扩容后只有一位差异，也就是多出了最左位的1，这样在通过 h&amp;(length-1)的时候，只要h对应的最左边的那一个差异位为0，就能保证得到的新的数组索引和老数组索引一致(大大减少了之前已经散列良好的老数组的数据位置重新调换)，个人理解。</p><p>　　<img src="/2022/06/30/javasems02/8.png" alt="img"></p><p> 还有，数组长度保持2的次幂，length-1的低位都为1，会使得获得的数组索引index更加均匀，比如：</p><p><img src="/2022/06/30/javasems02/9.png" alt="img"></p><p>　　我们看到，上面的&amp;运算，高位是不会对结果产生影响的（hash函数采用各种位运算可能也是为了使得低位更加散列），我们只关注低位bit，如果低位全部为1，那么对于h低位部分来说，任何一位的变化都会对结果产生影响，也就是说，要得到index=21这个存储位置，h的低位只有这一种组合。这也是数组长度设计为必须为2的次幂的原因。</p><p><img src="/2022/06/30/javasems02/10.png" alt="img"></p><p>　　如果不是2的次幂，也就是低位不是全为1此时，要使得index=21，h的低位部分不再具有唯一性了，哈希冲突的几率会变的更大，同时，index对应的这个bit位无论如何不会等于1了，而对应的那些数组位置也就被白白浪费了。</p><p>get方法</p><pre class=" language-java"><code class="language-java"> <span class="token keyword">public</span> V <span class="token function">get</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>　　　　 <span class="token comment" spellcheck="true">//如果key为null,则直接去table[0]处去检索即可。</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token function">getForNullKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> entry <span class="token operator">=</span> <span class="token function">getEntry</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> null <span class="token operator">==</span> entry <span class="token operator">?</span> null <span class="token operator">:</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>get方法通过key值返回对应value，如果key为null，直接去table[0]处检索。我们再看一下getEntry这个方法</p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token function">getEntry</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//通过key的hashcode值计算hash值</span>        <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//indexFor (hash&amp;length-1) 获取最终数组索引，然后遍历链表，通过equals方法比对找出对应记录</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span><span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>             e <span class="token operator">!=</span> null<span class="token punctuation">;</span>             e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Object k<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                 <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> e<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    </code></pre><p>　　可以看出，get方法的实现相对简单，key(hashcode)–&gt;hash–&gt;indexFor–&gt;最终索引位置，找到对应位置table[i]，再查看是否有链表，遍历链表，通过key的equals方法比对查找对应的记录。要注意的是，有人觉得上面在定位到数组位置之后然后遍历链表的时候，e.hash == hash这个判断没必要，仅通过equals判断就可以。其实不然，试想一下，如果传入的key对象重写了equals方法却没有重写hashCode，而恰巧此对象定位到这个数组位置，如果仅仅用equals判断可能是相等的，但其hashCode和当前对象不一致，这种情况，根据Object的hashCode的约定，不能返回当前对象，而应该返回null，后面的例子会做出进一步解释。</p><p><strong>Node节点类源码:</strong></p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 继承自 Map.Entry&lt;K,V></span><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token punctuation">{</span>       <span class="token keyword">final</span> <span class="token keyword">int</span> hash<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 哈希值，存放元素到hashmap中时用来与其他元素hash值比较</span>       <span class="token keyword">final</span> K key<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//键</span>       V value<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//值</span>       <span class="token comment" spellcheck="true">// 指向下一个节点</span>       Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">;</span>       <span class="token function">Node</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>hash <span class="token operator">=</span> hash<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> K <span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span> <span class="token keyword">return</span> key<span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> V <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">{</span> <span class="token keyword">return</span> value<span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> key <span class="token operator">+</span> <span class="token string">"="</span> <span class="token operator">+</span> value<span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 重写hashCode()方法</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> Objects<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">^</span> Objects<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> V <span class="token function">setValue</span><span class="token punctuation">(</span>V newValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>            V oldValue <span class="token operator">=</span> value<span class="token punctuation">;</span>            value <span class="token operator">=</span> newValue<span class="token punctuation">;</span>            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 重写 equals() 方法</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> <span class="token keyword">this</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token keyword">instanceof</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token operator">></span> e <span class="token operator">=</span> <span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">)</span>o<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>Objects<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                    Objects<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>树节点类源码:</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">TreeNode</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token punctuation">{</span>        TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> parent<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 父</span>        TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> left<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 左</span>        TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> right<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 右</span>        TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> prev<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// needed to unlink next upon deletion</span>        <span class="token keyword">boolean</span> red<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// 判断颜色</span>        <span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V val<span class="token punctuation">,</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">super</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 返回根节点</span>        <span class="token keyword">final</span> TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token function">root</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> r <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">,</span> p<span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> r<span class="token punctuation">.</span>parent<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>                    <span class="token keyword">return</span> r<span class="token punctuation">;</span>                r <span class="token operator">=</span> p<span class="token punctuation">;</span>       <span class="token punctuation">}</span>复制代码</code></pre><p><strong>LinkedList源码分析</strong></p><p><strong>构造方法</strong></p><p><img src="/2022/06/30/javasems02/3.jpg" alt="四个构造方法"></p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">// 默认构造函数。</span>    <span class="token keyword">public</span> More <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> DEFAULT_LOAD_FACTOR<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// all   other fields defaulted</span>     <span class="token punctuation">}</span>          <span class="token comment" spellcheck="true">// 包含另一个“Map”的构造函数</span>     <span class="token keyword">public</span> More <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">HashMap</span><span class="token punctuation">(</span>Map<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token operator">></span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> DEFAULT_LOAD_FACTOR<span class="token punctuation">;</span>         <span class="token function">putMapEntries</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//下面会分析到这个方法</span>     <span class="token punctuation">}</span>          <span class="token comment" spellcheck="true">// 指定“容量大小”的构造函数</span>     <span class="token keyword">public</span> More <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">this</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">,</span> DEFAULT_LOAD_FACTOR<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>          <span class="token comment" spellcheck="true">// 指定“容量大小”和“加载因子”的构造函数</span>     <span class="token keyword">public</span> More <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>             <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal initial capacity: "</span> <span class="token operator">+</span> initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">></span> MAXIMUM_CAPACITY<span class="token punctuation">)</span>             initialCapacity <span class="token operator">=</span> MAXIMUM_CAPACITY<span class="token punctuation">;</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>loadFactor <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> Float<span class="token punctuation">.</span><span class="token function">isNaN</span><span class="token punctuation">(</span>loadFactor<span class="token punctuation">)</span><span class="token punctuation">)</span>             <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal load factor: "</span> <span class="token operator">+</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> loadFactor<span class="token punctuation">;</span>         <span class="token keyword">this</span><span class="token punctuation">.</span>threshold <span class="token operator">=</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span></code></pre><p><strong>putMapEntries方法：</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">putMapEntries</span><span class="token punctuation">(</span>Map<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token operator">></span> m<span class="token punctuation">,</span> <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> s <span class="token operator">=</span> m<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 判断table是否已经初始化</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>table <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// pre-size</span>            <span class="token comment" spellcheck="true">// 未初始化，s为m的实际元素个数</span>            <span class="token keyword">float</span> ft <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>s <span class="token operator">/</span> loadFactor<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1.0F</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> t <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ft <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token operator">?</span>                    <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>ft <span class="token operator">:</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 计算得到的t大于阈值，则初始化阈值</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">></span> threshold<span class="token punctuation">)</span>                threshold <span class="token operator">=</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 已初始化，并且m元素个数大于阈值，进行扩容处理</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">></span> threshold<span class="token punctuation">)</span>            <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 将m中的所有元素添加至HashMap中</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token operator">></span> e <span class="token operator">:</span> m<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            K key <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            V value <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> evict<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>put方法</strong></p><p>HashMap只提供了put用于添加元素，putVal方法只是给put方法调用的一个方法，并没有提供给用户使用。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">final</span> V <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">,</span>                   <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// table未初始化或者长度为0，进行扩容</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        n <span class="token operator">=</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>        tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 桶中已经存在元素</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span> K k<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 比较桶中第一个元素(数组中的结点)的hash值相等，key相等</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">// 将第一个元素赋值给e，用e来记录</span>                e <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// hash值不相等，即key不相等；为红黑树结点</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// 放入树中</span>            e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 为链表结点</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 在链表最末插入结点</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 到达链表的尾部</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 在尾部插入新结点</span>                    p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 结点数量达到阈值，转化为红黑树</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">>=</span> TREEIFY_THRESHOLD <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// -1 for 1st</span>                        <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 跳出循环</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// 判断链表中结点的key值与插入的元素的key值是否相等</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token comment" spellcheck="true">// 相等，跳出循环</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span>                p <span class="token operator">=</span> e<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 表示在桶中找到key值、hash值与插入元素相等的结点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token comment" spellcheck="true">// 记录e的value</span>            V oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// onlyIfAbsent为false或者旧值为null</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent <span class="token operator">||</span> oldValue <span class="token operator">==</span> null<span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">//用新值替换旧值</span>                e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 访问后回调</span>            <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 返回旧值</span>            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 结构性修改</span>    <span class="token operator">++</span>modCount<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 实际大小大于阈值则扩容</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>size <span class="token operator">></span> threshold<span class="token punctuation">)</span>        <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 插入后回调</span>    <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span>evict<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span> </code></pre><p><strong>get方法</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">get</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">?</span> null <span class="token operator">:</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">final</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> first<span class="token punctuation">,</span> e<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span> K k<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>        <span class="token punctuation">(</span>first <span class="token operator">=</span> tab<span class="token punctuation">[</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 数组元素相等</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>first<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token comment" spellcheck="true">// always check first node</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> first<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> first<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 桶中不止一个节点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> first<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 在树中get</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>first <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>first<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTreeNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 在链表中get</span>            <span class="token keyword">do</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> e<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>resize方法</strong></p><p>进行扩容，会伴随着一次重新hash分配，并且会遍历hash表中所有的元素，是非常耗时的。在编写程序中，要尽量避免resize。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> oldTab <span class="token operator">=</span> table<span class="token punctuation">;</span>    <span class="token keyword">int</span> oldCap <span class="token operator">=</span> <span class="token punctuation">(</span>oldTab <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> oldTab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span> oldThr <span class="token operator">=</span> threshold<span class="token punctuation">;</span>    <span class="token keyword">int</span> newCap<span class="token punctuation">,</span> newThr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">>=</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token punctuation">{</span>            threshold <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>            <span class="token keyword">return</span> oldTab<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 没超过最大值，就扩充为原来的2倍</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>newCap <span class="token operator">=</span> oldCap <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span> oldCap <span class="token operator">>=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span>            newThr <span class="token operator">=</span> oldThr <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// double threshold</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldThr <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// initial capacity was placed in threshold</span>        newCap <span class="token operator">=</span> oldThr<span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>         signifies using defaults        newCap <span class="token operator">=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">;</span>        newThr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>DEFAULT_LOAD_FACTOR <span class="token operator">*</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 计算新的resize上限</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>newThr <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">float</span> ft <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>newCap <span class="token operator">*</span> loadFactor<span class="token punctuation">;</span>        newThr <span class="token operator">=</span> <span class="token punctuation">(</span>newCap <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span> ft <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>MAXIMUM_CAPACITY <span class="token operator">?</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>ft <span class="token operator">:</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    threshold <span class="token operator">=</span> newThr<span class="token punctuation">;</span>    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"rawtypes"</span><span class="token punctuation">,</span><span class="token string">"unchecked"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTab <span class="token operator">=</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">[</span>newCap<span class="token punctuation">]</span><span class="token punctuation">;</span>    table <span class="token operator">=</span> newTab<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldTab <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 把每个bucket都移动到新的buckets中</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> oldCap<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span>                    newTab<span class="token punctuation">[</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> <span class="token punctuation">(</span>newCap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>e<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> newTab<span class="token punctuation">,</span> j<span class="token punctuation">,</span> oldCap<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token punctuation">{</span>                     Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> loHead <span class="token operator">=</span> null<span class="token punctuation">,</span> loTail <span class="token operator">=</span> null<span class="token punctuation">;</span>                    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> hiHead <span class="token operator">=</span> null<span class="token punctuation">,</span> hiTail <span class="token operator">=</span> null<span class="token punctuation">;</span>                    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">;</span>                    <span class="token keyword">do</span> <span class="token punctuation">{</span>                        next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 原索引</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> oldCap<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">==</span> null<span class="token punctuation">)</span>                                loHead <span class="token operator">=</span> e<span class="token punctuation">;</span>                            <span class="token keyword">else</span>                                loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>                            loTail <span class="token operator">=</span> e<span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        <span class="token comment" spellcheck="true">// 原索引+oldCap</span>                        <span class="token keyword">else</span> <span class="token punctuation">{</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">==</span> null<span class="token punctuation">)</span>                                hiHead <span class="token operator">=</span> e<span class="token punctuation">;</span>                            <span class="token keyword">else</span>                                hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>                            hiTail <span class="token operator">=</span> e<span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 原索引放到bucket里</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>                        newTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> loHead<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token comment" spellcheck="true">// 原索引+oldCap放到bucket里</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>                        newTab<span class="token punctuation">[</span>j <span class="token operator">+</span> oldCap<span class="token punctuation">]</span> <span class="token operator">=</span> hiHead<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> newTab<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>HashMap常用方法测试</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> map<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Collection<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>HashMap<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Set<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HashMapDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        HashMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 键不能重复，值可以重复</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"san"</span><span class="token punctuation">,</span> <span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"si"</span><span class="token punctuation">,</span> <span class="token string">"李四"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"wu"</span><span class="token punctuation">,</span> <span class="token string">"王五"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"wang"</span><span class="token punctuation">,</span> <span class="token string">"老王"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"wang"</span><span class="token punctuation">,</span> <span class="token string">"老王2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 老王被覆盖</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"lao"</span><span class="token punctuation">,</span> <span class="token string">"老王"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"-------直接输出hashmap:-------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/**         * 遍历HashMap         */</span>        <span class="token comment" spellcheck="true">// 1.获取Map中的所有键</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"-------foreach获取Map中所有的键:------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Set<span class="token operator">&lt;</span>String<span class="token operator">></span> keys <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>String key <span class="token operator">:</span> keys<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>key<span class="token operator">+</span><span class="token string">"  "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//换行</span>        <span class="token comment" spellcheck="true">// 2.获取Map中所有值</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"-------foreach获取Map中所有的值:------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Collection<span class="token operator">&lt;</span>String<span class="token operator">></span> values <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>String value <span class="token operator">:</span> values<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>value<span class="token operator">+</span><span class="token string">"  "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//换行</span>        <span class="token comment" spellcheck="true">// 3.得到key的值的同时得到key所对应的值</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"-------得到key的值的同时得到key所对应的值:-------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Set<span class="token operator">&lt;</span>String<span class="token operator">></span> keys2 <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>String key <span class="token operator">:</span> keys2<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>key <span class="token operator">+</span> <span class="token string">"："</span> <span class="token operator">+</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"   "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">/**         * 另外一种不常用的遍历方式         */</span>        <span class="token comment" spellcheck="true">// 当我调用put(key,value)方法的时候，首先会把key和value封装到</span>        <span class="token comment" spellcheck="true">// Entry这个静态内部类对象中，把Entry对象再添加到数组中，所以我们想获取</span>        <span class="token comment" spellcheck="true">// map中的所有键值对，我们只要获取数组中的所有Entry对象，接下来</span>        <span class="token comment" spellcheck="true">// 调用Entry对象中的getKey()和getValue()方法就能获取键值对了</span>        Set<span class="token operator">&lt;</span>java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">>></span> entrys <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> entry <span class="token operator">:</span> entrys<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"--"</span> <span class="token operator">+</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">/**         * HashMap其他常用方法         */</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after map.size()："</span><span class="token operator">+</span>map<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after map.isEmpty()："</span><span class="token operator">+</span>map<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">"san"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after map.remove()："</span><span class="token operator">+</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after map.get(si)："</span><span class="token operator">+</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"si"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after map.containsKey(si)："</span><span class="token operator">+</span>map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span><span class="token string">"si"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after containsValue(李四)："</span><span class="token operator">+</span>map<span class="token punctuation">.</span><span class="token function">containsValue</span><span class="token punctuation">(</span><span class="token string">"李四"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">"si"</span><span class="token punctuation">,</span> <span class="token string">"李四2"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after map.replace(si, 李四2):"</span><span class="token operator">+</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="12-简述ConcurrentHashMap-的工作原理及分析源码"><a href="#12-简述ConcurrentHashMap-的工作原理及分析源码" class="headerlink" title="12. 简述ConcurrentHashMap 的工作原理及分析源码"></a>12. 简述ConcurrentHashMap 的工作原理及分析源码</h2><p>ConcurrentHashMap是Java并发包中提供的一个线程安全且高效的HashMap实现，ConcurrentHashMap在并发编程的场景中使用频率非常之高，本文就来分析下ConcurrentHashMap的实现原理，并对其实现原理进行分析（JDK1.7).</p><p><strong>ConcurrentHashMap实现原理</strong></p><p>　　众所周知，哈希表是中非常高效，复杂度为O(1)的数据结构，在Java开发中，我们最常见到最频繁使用的就是HashMap和HashTable，但是在线程竞争激烈的并发场景中使用都不够合理。</p><p>　　<strong>HashMap</strong> ：先说HashMap，HashMap是<strong>线程不安全</strong>的，在并发环境下，可能会形成<strong>环状链表</strong>（扩容时可能造成，具体原因自行百度google或查看源码分析），导致get操作时，cpu空转，所以，在并发环境中使用HashMap是非常危险的。</p><p>　　<strong>HashTable</strong> ： HashTable和HashMap的实现原理几乎一样，差别无非是<strong>1.HashTable不允许key和value为null；2.HashTable是线程安全的。</strong>但是HashTable线程安全的策略实现代价却太大了，简单粗暴，get/put所有相关操作都是synchronized的，这相当于给整个哈希表加了一把<strong>大锁</strong>，多线程访问时候，只要有一个线程访问或操作该对象，那其他线程只能阻塞，相当于将所有的操作<strong>串行化</strong>，在竞争激烈的并发场景中性能就会非常差。</p><p><img src="/2022/06/30/javasems02/3.png" alt="img"></p><p>　　HashTable性能差主要是由于所有操作需要竞争同一把锁，而如果容器中有多把锁，每一把锁锁一段数据，这样在多线程访问时不同段的数据时，就不会存在锁竞争了，这样便可以有效地提高并发效率。这就是ConcurrentHashMap所采用的”<strong>分段锁</strong>“思想。</p><p>　　<img src="/2022/06/30/javasems02/4.png" alt="img"></p><p><strong>ConcurrentHashMap源码分析</strong></p><p>ConcurrentHashMap采用了非常精妙的”分段锁”策略，ConcurrentHashMap的主干是个Segment数组。</p><pre class=" language-java"><code class="language-java"> <span class="token keyword">final</span> Segment<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> segments<span class="token punctuation">;</span></code></pre><p>　　Segment继承了ReentrantLock，所以它就是一种可重入锁（ReentrantLock)。在ConcurrentHashMap，一个Segment就是一个子哈希表，Segment里维护了一个HashEntry数组，并发环境下，对于不同Segment的数据进行操作是不用考虑锁竞争的。（就按默认的ConcurrentLeve为16来讲，理论上就允许16个线程并发执行，有木有很酷）</p><p>　　<strong>所以，对于同一个Segment的操作才需考虑线程同步，不同的Segment则无需考虑。</strong></p><p>Segment类似于HashMap，一个Segment维护着一个HashEntry数组</p><pre class=" language-java"><code class="language-java"> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> HashEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span></code></pre><p>HashEntry是目前我们提到的最小的逻辑处理单元了。一个ConcurrentHashMap维护一个Segment数组，一个Segment维护一个HashEntry数组。</p><pre class=" language-java"><code class="language-java"> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">HashEntry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> <span class="token keyword">int</span> hash<span class="token punctuation">;</span>        <span class="token keyword">final</span> K key<span class="token punctuation">;</span>        <span class="token keyword">volatile</span> V value<span class="token punctuation">;</span>        <span class="token keyword">volatile</span> HashEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//其他省略</span><span class="token punctuation">}</span>    </code></pre><p>我们说Segment类似哈希表，那么一些属性就跟我们之前提到的HashMap差不离，比如负载因子loadFactor，比如阈值threshold等等，看下Segment的构造方法</p><pre class=" language-java"><code class="language-java"><span class="token function">Segment</span><span class="token punctuation">(</span><span class="token keyword">float</span> lf<span class="token punctuation">,</span> <span class="token keyword">int</span> threshold<span class="token punctuation">,</span> HashEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> lf<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//负载因子</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>threshold <span class="token operator">=</span> threshold<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//阈值</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>table <span class="token operator">=</span> tab<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//主干数组即HashEntry数组</span>        <span class="token punctuation">}</span></code></pre><p>我们来看下ConcurrentHashMap的构造方法</p><pre class=" language-java"><code class="language-java"> <span class="token number">1</span>  <span class="token keyword">public</span> <span class="token function">ConcurrentHashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token number">2</span>                                <span class="token keyword">float</span> loadFactor<span class="token punctuation">,</span> <span class="token keyword">int</span> concurrencyLevel<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token number">3</span>           <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>loadFactor <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">||</span> initialCapacity <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> concurrencyLevel <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token number">4</span>               <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">5</span>           <span class="token comment" spellcheck="true">//MAX_SEGMENTS 为1&lt;&lt;16=65536，也就是最大并发数为65536</span> <span class="token number">6</span>           <span class="token keyword">if</span> <span class="token punctuation">(</span>concurrencyLevel <span class="token operator">></span> MAX_SEGMENTS<span class="token punctuation">)</span> <span class="token number">7</span>               concurrencyLevel <span class="token operator">=</span> MAX_SEGMENTS<span class="token punctuation">;</span> <span class="token number">8</span>           <span class="token comment" spellcheck="true">//2的sshif次方等于ssize，例:ssize=16,sshift=4;ssize=32,sshif=5</span> <span class="token number">9</span>          <span class="token keyword">int</span> sshift <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token number">10</span>          <span class="token comment" spellcheck="true">//ssize 为segments数组长度，根据concurrentLevel计算得出</span><span class="token number">11</span>          <span class="token keyword">int</span> ssize <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token number">12</span>          <span class="token keyword">while</span> <span class="token punctuation">(</span>ssize <span class="token operator">&lt;</span> concurrencyLevel<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token number">13</span>              <span class="token operator">++</span>sshift<span class="token punctuation">;</span><span class="token number">14</span>              ssize <span class="token operator">&lt;&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token number">15</span>          <span class="token punctuation">}</span><span class="token number">16</span>          <span class="token comment" spellcheck="true">//segmentShift和segmentMask这两个变量在定位segment时会用到，后面会详细讲</span><span class="token number">17</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>segmentShift <span class="token operator">=</span> <span class="token number">32</span> <span class="token operator">-</span> sshift<span class="token punctuation">;</span><span class="token number">18</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>segmentMask <span class="token operator">=</span> ssize <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token number">19</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">></span> MAXIMUM_CAPACITY<span class="token punctuation">)</span><span class="token number">20</span>              initialCapacity <span class="token operator">=</span> MAXIMUM_CAPACITY<span class="token punctuation">;</span><span class="token number">21</span>          <span class="token comment" spellcheck="true">//计算cap的大小，即Segment中HashEntry的数组长度，cap也一定为2的n次方.</span><span class="token number">22</span>          <span class="token keyword">int</span> c <span class="token operator">=</span> initialCapacity <span class="token operator">/</span> ssize<span class="token punctuation">;</span><span class="token number">23</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">*</span> ssize <span class="token operator">&lt;</span> initialCapacity<span class="token punctuation">)</span><span class="token number">24</span>              <span class="token operator">++</span>c<span class="token punctuation">;</span><span class="token number">25</span>          <span class="token keyword">int</span> cap <span class="token operator">=</span> MIN_SEGMENT_TABLE_CAPACITY<span class="token punctuation">;</span><span class="token number">26</span>          <span class="token keyword">while</span> <span class="token punctuation">(</span>cap <span class="token operator">&lt;</span> c<span class="token punctuation">)</span><span class="token number">27</span>              cap <span class="token operator">&lt;&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token number">28</span>          <span class="token comment" spellcheck="true">//创建segments数组并初始化第一个Segment，其余的Segment延迟初始化</span><span class="token number">29</span>          Segment<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> s0 <span class="token operator">=</span><span class="token number">30</span>              <span class="token keyword">new</span> <span class="token class-name">Segment</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">(</span>loadFactor<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>cap <span class="token operator">*</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">31</span>                               <span class="token punctuation">(</span>HashEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">HashEntry</span><span class="token punctuation">[</span>cap<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">32</span>          Segment<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> ss <span class="token operator">=</span> <span class="token punctuation">(</span>Segment<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Segment</span><span class="token punctuation">[</span>ssize<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token number">33</span>          UNSAFE<span class="token punctuation">.</span><span class="token function">putOrderedObject</span><span class="token punctuation">(</span>ss<span class="token punctuation">,</span> SBASE<span class="token punctuation">,</span> s0<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">34</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>segments <span class="token operator">=</span> ss<span class="token punctuation">;</span><span class="token number">35</span>      <span class="token punctuation">}</span></code></pre><p>　　初始化方法有三个参数，如果用户不指定则会使用默认值，initialCapacity为16，loadFactor为0.75（负载因子，扩容时需要参考），concurrentLevel为16。</p><p>　　<strong>从上面的代码可以看出来,Segment数组的大小ssize是由concurrentLevel来决定的，但是却不一定等于concurrentLevel，ssize一定是大于或等于concurrentLevel的最小的2的次幂。比如：默认情况下concurrentLevel是16，则ssize为16；若concurrentLevel为14，ssize为16；若concurrentLevel为17，则ssize为32。为什么Segment的数组大小一定是2的次幂？其实主要是便于通过按位与的散列算法来定位Segment的index。</strong></p><p>　　接下来，我们来看看put方法</p><pre class=" language-java"><code class="language-java"> <span class="token keyword">public</span> V <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Segment<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> s<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//concurrentHashMap不允许key/value为空</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">==</span> null<span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//hash函数对key的hashCode重新散列，避免差劲的不合理的hashcode，保证散列均匀</span>        <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//返回的hash值无符号右移segmentShift位与段掩码进行位运算，定位segment</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token punctuation">(</span>hash <span class="token operator">>>></span> segmentShift<span class="token punctuation">)</span> <span class="token operator">&amp;</span> segmentMask<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>s <span class="token operator">=</span> <span class="token punctuation">(</span>Segment<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>UNSAFE<span class="token punctuation">.</span>getObject          <span class="token comment" spellcheck="true">// nonvolatile; recheck</span>             <span class="token punctuation">(</span>segments<span class="token punctuation">,</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;&lt;</span> SSHIFT<span class="token punctuation">)</span> <span class="token operator">+</span> SBASE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//  in ensureSegment</span>            s <span class="token operator">=</span> <span class="token function">ensureSegment</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>　从源码看出，put的主要逻辑也就两步：<strong>1.定位segment并确保定位的Segment已初始化 2.调用Segment的put方法。</strong></p><p>　<strong>关于segmentShift和segmentMask</strong></p><p>　　segmentShift和segmentMask这两个全局变量的主要作用是用来定位Segment，int j =(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask。</p><p>　　<strong>segmentMask</strong>：段掩码，假如segments数组长度为16，则段掩码为16-1=15；segments长度为32，段掩码为32-1=31。这样得到的所有bit位都为1，可以更好地保证散列的均匀性</p><p>　　<strong>segmentShift</strong>：2的sshift次方等于ssize，segmentShift=32-sshift。若segments长度为16，segmentShift=32-4=28;若segments长度为32，segmentShift=32-5=27。而计算得出的hash值最大为32位，无符号右移segmentShift，则意味着只保留高几位（其余位是没用的），然后与段掩码segmentMask位运算来定位Segment。</p><p>　　<strong>get/put方法</strong></p><p>　　get方法</p><pre class=" language-java"><code class="language-java"> <span class="token keyword">public</span> V <span class="token function">get</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Segment<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> s<span class="token punctuation">;</span>         HashEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span>        <span class="token keyword">int</span> h <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> u <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>h <span class="token operator">>>></span> segmentShift<span class="token punctuation">)</span> <span class="token operator">&amp;</span> segmentMask<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> SSHIFT<span class="token punctuation">)</span> <span class="token operator">+</span> SBASE<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//先定位Segment，再定位HashEntry</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>s <span class="token operator">=</span> <span class="token punctuation">(</span>Segment<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>UNSAFE<span class="token punctuation">.</span><span class="token function">getObjectVolatile</span><span class="token punctuation">(</span>segments<span class="token punctuation">,</span> u<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span>            <span class="token punctuation">(</span>tab <span class="token operator">=</span> s<span class="token punctuation">.</span>table<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>HashEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> <span class="token punctuation">(</span>HashEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span> UNSAFE<span class="token punctuation">.</span><span class="token function">getObjectVolatile</span>                     <span class="token punctuation">(</span>tab<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>tab<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> h<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> TSHIFT<span class="token punctuation">)</span> <span class="token operator">+</span> TBASE<span class="token punctuation">)</span><span class="token punctuation">;</span>                 e <span class="token operator">!=</span> null<span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>                K k<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> h <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>　　<strong>get方法无需加锁，由于其中涉及到的共享变量都使用volatile修饰，volatile可以保证内存可见性，所以不会读取到过期数据。</strong></p><p>　　来看下concurrentHashMap代理到Segment上的put方法，Segment中的put方法是要加锁的。只不过是锁粒度细了而已。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> V <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> <span class="token keyword">int</span> hash<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">)</span> <span class="token punctuation">{</span>            HashEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> node <span class="token operator">=</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> null <span class="token operator">:</span>                <span class="token function">scanAndLockForPut</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//tryLock不成功时会遍历定位到的HashEnry位置的链表（遍历主要是为了使CPU缓存链表），若找不到，则创建HashEntry。tryLock一定次数后（MAX_SCAN_RETRIES变量决定），则lock。若遍历过程中，由于其他线程的操作导致链表头结点变化，则需要重新遍历。</span>            V oldValue<span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                HashEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> table<span class="token punctuation">;</span>                <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token punctuation">(</span>tab<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//定位HashEntry，可以看到，这个hash值在定位Segment时和在Segment中定位HashEntry都会用到，只不过定位Segment时只用到高几位。</span>                HashEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> first <span class="token operator">=</span> <span class="token function">entryAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span>HashEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> first<span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        K k<span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span>                            <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent<span class="token punctuation">)</span> <span class="token punctuation">{</span>                                e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>                                <span class="token operator">++</span>modCount<span class="token punctuation">;</span>                            <span class="token punctuation">}</span>                            <span class="token keyword">break</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">else</span> <span class="token punctuation">{</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">!=</span> null<span class="token punctuation">)</span>                            node<span class="token punctuation">.</span><span class="token function">setNext</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">else</span>                            node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashEntry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> first<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">int</span> c <span class="token operator">=</span> count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>　　　　　　　　　　　　　　<span class="token comment" spellcheck="true">//若c超出阈值threshold，需要扩容并rehash。扩容后的容量是当前容量的2倍。这样可以最大程度避免之前散列好的entry重新散列，具体在另一篇文章中有详细分析，不赘述。扩容并rehash的这个过程是比较消耗资源的。</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">></span> threshold <span class="token operator">&amp;&amp;</span> tab<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span>                            <span class="token function">rehash</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">else</span>                            <span class="token function">setEntryAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> index<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token operator">++</span>modCount<span class="token punctuation">;</span>                        count <span class="token operator">=</span> c<span class="token punctuation">;</span>                        oldValue <span class="token operator">=</span> null<span class="token punctuation">;</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>        <span class="token punctuation">}</span></code></pre><p> 总结</p><p>　　ConcurrentHashMap作为一种线程安全且高效的哈希表的解决方案，尤其其中的”分段锁”的方案，相比HashTable的全表锁在性能上的提升非常之大。</p>]]></content>
      
      
      <categories>
          
          <category> java面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库学习：触发器</title>
      <link href="/2022/06/29/database01/"/>
      <url>/2022/06/29/database01/</url>
      
        <content type="html"><![CDATA[<h1 id="触发器（Trigger）"><a href="#触发器（Trigger）" class="headerlink" title="触发器（Trigger）"></a>触发器（Trigger）</h1><p>触发器 (Trigger) 是一个存储过程（stored Procedure），在适当条件下被调用的过程，有点类似于回调函数与生命周期函数(在某个时刻会自动执行的函数)。触发器是mysql5新增的功能，通常在进行增删改操作后会做一些触发操作。</p><h2 id="创建触发器的语法"><a href="#创建触发器的语法" class="headerlink" title="创建触发器的语法"></a>创建触发器的语法</h2><pre class=" language-mysql"><code class="language-mysql">CREATE    [DEFINER = { user | CURRENT_USER }]TRIGGER trigger_nametrigger_time trigger_eventON tbl_name FOR EACH ROW　　[trigger_order]trigger_bodytrigger_time: { BEFORE | AFTER }trigger_event: { INSERT | UPDATE | DELETE }trigger_order: { FOLLOWS | PRECEDES } other_trigger_name</code></pre><ul><li>BEFORE 和 AFTER 参数指定了触发执行的时间，在事件之前或是之后。</li><li>FOR EACH ROW 表示任何一条记录上的操作满足触发事件都会触发该触发器，也就是说触发器的触发频率是针对每一行数据触发一次。</li></ul><p><strong>tigger_event</strong>详解：</p><p>　　①INSERT型触发器：插入某一行时激活触发器，可能通过INSERT、LOAD DATA、REPLACE 语句触发(LOAD DAT语句用于将一个文件装入到一个数据表中，相当与一系列的INSERT操作)；</p><p>　　②UPDATE型触发器：更改某一行时激活触发器，可能通过UPDATE语句触发；</p><p>　　③DELETE型触发器：删除某一行时激活触发器，可能通过DELETE、REPLACE语句触发。</p><p>trigger_order是MySQL5.7之后的一个功能，用于定义多个触发器，使用follows(尾随)或precedes(在…之先)来选择触发器执行的先后顺序。 </p><h3 id="1、创建只有一个执行语句的触发器"><a href="#1、创建只有一个执行语句的触发器" class="headerlink" title="1、创建只有一个执行语句的触发器"></a>1、创建只有一个执行语句的触发器</h3><blockquote><p>CREATE TRIGGER 触发器名 BEFORE|AFTER 触发事件 ON 表名 FOR EACH ROW 执行语句;</p></blockquote><p>例1：创建了一个名为trig1的触发器，一旦在work表中有插入动作，就会自动往time表里插入当前时间</p><pre class=" language-mysql"><code class="language-mysql">mysql> CREATE TRIGGER trig1 AFTER INSERT    -> ON `work` FOR EACH ROW    -> INSERT INTO time VALUES(NOW());</code></pre><h3 id="2、创建有多个执行语句的触发器"><a href="#2、创建有多个执行语句的触发器" class="headerlink" title="2、创建有多个执行语句的触发器"></a>2、创建有多个执行语句的触发器</h3><blockquote><p>CREATE TRIGGER 触发器名 BEFORE|AFTER 触发事件</p><p>ON 表名 FOR EACH ROW</p><p>BEGIN</p><p>​    执行语句列表</p><p>END;</p></blockquote><p>例2：定义一个触发器，一旦有满足条件的删除操作，就会执行BEGIN和END中的语句</p><pre class=" language-mysql"><code class="language-mysql">mysql> DELIMITER ||mysql> CREATE TRIGGER trig2 BEFORE DELETE    -> ON `work` FOR EACH ROW    -> BEGIN    -> 　　INSERT INTO time VALUES(NOW());    -> 　　INSERT INTO time VALUES(NOW());    -> END||mysql> DELIMITER ;</code></pre><h3 id="3、NEW与OLD详解"><a href="#3、NEW与OLD详解" class="headerlink" title="3、NEW与OLD详解"></a>3、NEW与OLD详解</h3><p>MySQL 中定义了 NEW 和 OLD，用来表示触发器的所在表中，触发了触发器的那一行数据，来引用触发器中发生变化的记录内容，具体地：</p><ol><li>在INSERT型触发器中，NEW用来表示将要（BEFORE）或已经（AFTER）插入的新数据；</li><li>在UPDATE型触发器中，OLD用来表示将要或已经被修改的原数据，NEW用来表示将要或已经修改为的新数据；</li><li>在DELETE型触发器中，OLD用来表示将要或已经被删除的原数据；</li></ol><p>使用方法：</p><pre class=" language-mysql"><code class="language-mysql">NEW.columnName （columnName为相应数据表某一列名）</code></pre><p>另外，OLD是只读的，而NEW则可以在触发器中使用 SET 赋值，这样不会再次触发触发器，造成循环调用（如每插入一个学生前，都在其学号前加“2013”）。</p><pre class=" language-mysql"><code class="language-mysql">mysql> CREATE TABLE account (acct_num INT, amount DECIMAL(10,2));mysql> INSERT INTO account VALUES(137,14.98),(141,1937.50),(97,-100.00);mysql> delimiter $$mysql> CREATE TRIGGER upd_check BEFORE UPDATE ON account    -> FOR EACH ROW    -> BEGIN    -> 　　IF NEW.amount < 0 THEN    -> 　　　　SET NEW.amount = 0;    -> 　　ELSEIF NEW.amount > 100 THEN    -> 　　　　SET NEW.amount = 100;    -> 　　END IF;    -> END$$mysql> delimiter ;mysql> update account set amount=-10 where acct_num=137;mysql> select * from account;+----------+---------+| acct_num | amount  |+----------+---------+|      137 |    0.00 ||      141 | 1937.50 ||       97 | -100.00 |+----------+---------+mysql> update account set amount=200 where acct_num=137;mysql> select * from account;+----------+---------+| acct_num | amount  |+----------+---------+|      137 |  100.00 ||      141 | 1937.50 ||       97 | -100.00 |+----------+---------+</code></pre><p>二、查看触发器</p><p>1、<strong>SHOW TRIGGERS</strong> 语句查看触发器信息</p><p>mysql&gt; SHOW TRIGGERS\G;</p><p>……</p><p>结果，显示所有触发器的基本信息；无法查询指定的触发器。</p><p>2、在information_schema.triggers表中查看触发器信息</p><p>mysql&gt; SELECT * FROM information_schema.triggers\G</p><p>……</p><p>结果，显示所有触发器的详细信息；同时，该方法可以查询制定触发器的详细信息。</p><pre><code>mysql&gt; select * from information_schema.triggers     -&gt; where trigger_name='upd_check'\G;</code></pre><p>Tips：</p><p>　　<strong>所有触发器信息都存储在information_schema数据库下的triggers表中</strong>，可以使用SELECT语句查询，如果触发器信息过多，最好通过TRIGGER_NAME字段指定查询。</p><p>三、删除触发器</p><blockquote><p>DROP TRIGGER [IF EXISTS] [schema_name.]trigger_name</p></blockquote><p>删除触发器之后最好使用上面的方法查看一遍；同时，也可以使用database.trig来指定某个数据库中的触发器。</p><p>下面由一个实例来完成今天的学习。</p><h2 id="例子：股票涨跌幅"><a href="#例子：股票涨跌幅" class="headerlink" title="例子：股票涨跌幅"></a>例子：股票涨跌幅</h2><p>我们以股票为例，股票由日期、当天尾盘价格、成交量组成，首先创一个table。</p><pre class=" language-mysql"><code class="language-mysql"># 1.例子：股票收盘价,计算每天相对的涨跌# 计算规则：(今天的收盘价-前一天的收盘价)/前一天的收盘价 × 100% = ((今天收盘价/前一天收盘价) - 1 ) × 100%USE WORLD;DROP TABLE IF EXISTS STOCK_DAILY;CREATE TABLE STOCK_DAILY(    DATE DATE,    CLOSE_PRICE DECIMAL(10,2),    AMOUNT DECIMAL(10,2),    PRIMARY KEY(DATE));-- 把生成的INCREASINGRATE写入表中ALTER TABLE STOCK_DAILY ADD INCREASINGRATE DECIMAL(10,2);</code></pre><h3 id="利用Trigger使得数据被insert时自动计算涨跌幅"><a href="#利用Trigger使得数据被insert时自动计算涨跌幅" class="headerlink" title="利用Trigger使得数据被insert时自动计算涨跌幅"></a>利用Trigger使得数据被insert时自动计算涨跌幅</h3><pre class=" language-mysql"><code class="language-mysql"># 1. INSERT 时自动计算并填写INCREASINGRATEDROP TRIGGER IF EXISTS UPDATE_INCREASINGRATE_TGR;# 创建一个触发器CREATE TRIGGER UPDATE_INCREASINGRATE_TGRBEFORE INSERT ON STOCK_DAILY # 在对表进行插入操作时FOR EACH ROWBEGIN    DECLARE PRE_CLOSE_PRICE DECIMAL(10,2) DEFAULT NULL;    # 拿前一天的收盘价作为pre_close_price    SELECT CLOSE_PRICE FROM stock_daily WHERE DATE = NEW.DATE - 1 INTO PRE_CLOSE_PRICE;     # 避免排他锁不用insert    SET NEW.INCREASINGRATE = (NEW.CLOSE_PRICE/PRE_CLOSE_PRICE - 1) * 100.0;    END;INSERT INTO STOCK_DAILYVALUES('2020-01-01',25.03,500000),('2020-01-02',21.02,500000),('2020-01-03',24.17,500000),('2020-01-04',22.84,500000),('2020-01-05',26.77,500000),('2020-01-06',28.52,500000),('2020-01-07',32.51,500000);</code></pre><p>结果如图：</p><p><img src="/2022/06/29/database01/image-20220629234004915.png" alt="image-20220629234004915"></p><p>要注意的是，<strong>在增删改的时候，当前的数据记录，不可以在被Triger增删改</strong>。</p><p><img src="/image-20220629234650170.png" alt="image-20220629234650170"></p><h3 id="Trigger如何取消正在运行的增删改操作"><a href="#Trigger如何取消正在运行的增删改操作" class="headerlink" title="Trigger如何取消正在运行的增删改操作"></a>Trigger如何取消正在运行的增删改操作</h3><pre class=" language-mysql"><code class="language-mysql">DROP TRIGGER IF EXISTS UPDATE_INCREASINGRATE_TGR;# 创建一个触发器CREATE TRIGGER UPDATE_INCREASINGRATE_TGRAFTER INSERT ON STOCK_DAILY # 在对表进行插入操作时FOR EACH ROWBEGIN        IF NEW.INCREASINGRATE IS NULL THEN            SIGNAL SQLSTATE '12345' SET MESSAGE_TEXT='IncreasingRate is Null, Message from mysql.';        END IF;END;INSERT INTO stock_daily (DATE,CLOSE_PRICE,AMOUNT)VALUES('2020-01-08',37.51,500000);</code></pre><h2 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h2><p><a href="https://www.cnblogs.com/geaozhang/p/6819648.html">https://www.cnblogs.com/geaozhang/p/6819648.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程学习日记02：线程池</title>
      <link href="/2022/06/28/multithread02/"/>
      <url>/2022/06/28/multithread02/</url>
      
        <content type="html"><![CDATA[<h1 id="线程池（Thread-Pool）"><a href="#线程池（Thread-Pool）" class="headerlink" title="线程池（Thread Pool）"></a>线程池（Thread Pool）</h1><p>线程池（Thread Pool）是一种基于池化思想管理线程的工具。线程过多会带来额外的开销，其中包括创建<strong>销毁线程的开销、调度线程的开销</strong>等等，同时也降低了计算机的整体性能。线程池维护多个线程，等待监督管理者分配可并发执行的任务。这种做法，一方面避免了处理任务时创建销毁线程开销的代价，另一方面避免了线程数量膨胀导致的过分调度问题，保证了对内核的充分利用。</p><h2 id="一、Java中常用的四种线程池"><a href="#一、Java中常用的四种线程池" class="headerlink" title="一、Java中常用的四种线程池"></a>一、Java中常用的四种线程池</h2><p>在Java中使用线程池，可以用ThreadPoolExecutor的构造函数直接创建出线程池实例。不过，在Executors类中，为我们提供了常用线程池的创建方法。接下来我们就来了解常用的四种：<strong>newFixedThreadPool</strong>、<strong>newCachedThreadPool</strong>、<strong>newScheduledThreadPool</strong>、<strong>newSingleThreadExecutor</strong></p><h3 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h3><p>创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。创建方法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token keyword">int</span> nThreads<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>nThreads<span class="token punctuation">,</span> nThreads<span class="token punctuation">,</span>                                      0L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span>                                      <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>从构造方法可以看出，它创建了一个固定大小的线程池，每次提交一个任务就创建一个线程，直到线程达到线程池的最大值<code>nThreads</code>。线程池的大小一旦达到最大值后，再有新的任务提交时则放入**<a href="https://blog.csdn.net/u022812849/article/details/114698692">无界阻塞队列</a>**中，等到有线程空闲时，再从队列中取出任务继续执行。<br>如何使用<code>newFixedThreadPool</code>？示例代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> test<span class="token punctuation">;</span>  <span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ExecutorService<span class="token punctuation">;</span>  <span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>Executors<span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadPoolExecutorTest</span> <span class="token punctuation">{</span>      <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>          ExecutorService fixedThreadPool <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">12</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                 <span class="token keyword">final</span> <span class="token keyword">int</span> index <span class="token operator">=</span> i<span class="token punctuation">;</span>                 fixedThreadPool<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                       <span class="token keyword">try</span> <span class="token punctuation">{</span>                            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>                            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token punctuation">}</span>                  <span class="token punctuation">}</span>                 <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>       <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  </code></pre><p>线程池大小为3，每个任务输出index后sleep 3秒，所以每三秒打印3个数字。<br>定长线程池的大小最好根据系统资源进行设置。如Runtime.getRuntime().availableProcessors()</p><h3 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h3><p>看一下这种线程池的创建方法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">,</span>                                      60L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>                                      <span class="token keyword">new</span> <span class="token class-name">SynchronousQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>从构造方法可以看出，它创建了一个可缓存的线程池。当有新的任务提交时，有空闲线程则直接处理任务，没有空闲线程则创建新的线程处理任务，队列中不储存任务。线程池不对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。如果线程空闲时间超过了60秒就会被回收。</p><h3 id="使用线程池可以带来一系列好处："><a href="#使用线程池可以带来一系列好处：" class="headerlink" title="使用线程池可以带来一系列好处："></a>使用线程池可以带来一系列好处：</h3><ul><li><strong>降低资源消耗</strong>：通过池化技术重复利用已创建的线程，降低线程创建和销毁造成的损耗。</li><li><strong>提高响应速度</strong>：任务到达时，无需等待线程创建即可立即执行。</li><li><strong>提高线程的可管理性</strong>：线程是稀缺资源，如果无限制创建，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性。使用线程池可以进行统一的分配、调优和监控。</li><li><strong>提供更多更强大的功能</strong>：线程池具备可拓展性，允许开发人员向其中增加更多的功能。比如延时定时线程池ScheduledThreadPoolExecutor，就允许任务延期执行或定期执行。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OneMoreStudy</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ExecutorService cachedThreadPool <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">final</span> <span class="token keyword">int</span> index <span class="token operator">=</span> i<span class="token punctuation">;</span>            cachedThreadPool<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token annotation punctuation">@Override</span>                    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">try</span> <span class="token punctuation">{</span>                        SimpleDateFormat sdf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"HH:mm:ss"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"运行时间: "</span> <span class="token operator">+</span> sdf<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>                        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        cachedThreadPool<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>因为这种线程有新的任务提交，就会创建新的线程（线程池中没有空闲线程时），不需要等待，所以提交的5个任务的运行时间是一样的，运行结果如下：</p><pre class=" language-java"><code class="language-java">运行时间<span class="token operator">:</span> <span class="token number">08</span><span class="token operator">:</span><span class="token number">45</span><span class="token operator">:</span><span class="token number">18</span> <span class="token number">2</span>运行时间<span class="token operator">:</span> <span class="token number">08</span><span class="token operator">:</span><span class="token number">45</span><span class="token operator">:</span><span class="token number">18</span> <span class="token number">1</span>运行时间<span class="token operator">:</span> <span class="token number">08</span><span class="token operator">:</span><span class="token number">45</span><span class="token operator">:</span><span class="token number">18</span> <span class="token number">3</span>运行时间<span class="token operator">:</span> <span class="token number">08</span><span class="token operator">:</span><span class="token number">45</span><span class="token operator">:</span><span class="token number">18</span> <span class="token number">4</span>运行时间<span class="token operator">:</span> <span class="token number">08</span><span class="token operator">:</span><span class="token number">45</span><span class="token operator">:</span><span class="token number">18</span> <span class="token number">0</span></code></pre><h3 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h3><p>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。看一下这种线程池的创建方法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FinalizableDelegatedExecutorService</span>            <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span>                                    0L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span>                                    <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>从构造方法可以看出，它创建了一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序执行。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OneMoreStudy</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ExecutorService singleThreadExecutor <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> <span class="token keyword">int</span> index <span class="token operator">=</span> i<span class="token punctuation">;</span>        singleThreadExecutor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">try</span> <span class="token punctuation">{</span>                        SimpleDateFormat sdf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"HH:mm:ss"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"运行时间: "</span> <span class="token operator">+</span> sdf<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>                        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        singleThreadExecutor<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>因为该线程池类似于单线程执行，所以先执行完前一个任务后，再顺序执行下一个任务，<br>运行结果如下：</p><pre class=" language-java"><code class="language-java">运行时间<span class="token operator">:</span> <span class="token number">08</span><span class="token operator">:</span><span class="token number">54</span><span class="token operator">:</span><span class="token number">17</span> <span class="token number">0</span>运行时间<span class="token operator">:</span> <span class="token number">08</span><span class="token operator">:</span><span class="token number">54</span><span class="token operator">:</span><span class="token number">19</span> <span class="token number">1</span>运行时间<span class="token operator">:</span> <span class="token number">08</span><span class="token operator">:</span><span class="token number">54</span><span class="token operator">:</span><span class="token number">21</span> <span class="token number">2</span>运行时间<span class="token operator">:</span> <span class="token number">08</span><span class="token operator">:</span><span class="token number">54</span><span class="token operator">:</span><span class="token number">23</span> <span class="token number">3</span>运行时间<span class="token operator">:</span> <span class="token number">08</span><span class="token operator">:</span><span class="token number">54</span><span class="token operator">:</span><span class="token number">25</span> <span class="token number">4</span></code></pre><p>既然类似于单线程执行，那么这种线程池还有存在的必要吗？这里的单线程执行指的是线程池内部，从线程池外的角度看，主线程在提交任务到线程池时并没有阻塞，仍然是异步的。</p><h3 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h3><p>这个方法创建了一个固定大小的线程池，支持定时及周期性任务执行。<br>首先看一下定时执行的例子：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OneMoreStudy</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> SimpleDateFormat sdf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"HH:mm:ss"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ScheduledExecutorService scheduledThreadPool <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newScheduledThreadPool</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"提交时间: "</span> <span class="token operator">+</span> sdf<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        scheduledThreadPool<span class="token punctuation">.</span><span class="token function">schedule</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"运行时间: "</span> <span class="token operator">+</span> sdf<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>        scheduledThreadPool<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>使用该线程池的<code>schedule</code>方法，延迟3秒钟后执行任务，运行结果如下：</p><pre class=" language-java"><code class="language-java">提交时间<span class="token operator">:</span> <span class="token number">09</span><span class="token operator">:</span><span class="token number">11</span><span class="token operator">:</span><span class="token number">39</span>运行时间<span class="token operator">:</span> <span class="token number">09</span><span class="token operator">:</span><span class="token number">11</span><span class="token operator">:</span><span class="token number">42</span></code></pre><p>定期执行示例代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadPoolExecutorTest</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>      ScheduledExecutorService scheduledThreadPool <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newScheduledThreadPool</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      scheduledThreadPool<span class="token punctuation">.</span><span class="token function">scheduleAtFixedRate</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"delay 1 seconds, and excute every 3 seconds"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>  <span class="token punctuation">}</span></code></pre><p>表示延迟1秒后每3秒执行一次。</p><h2 id="二、线程池总体设计"><a href="#二、线程池总体设计" class="headerlink" title="二、线程池总体设计"></a>二、线程池总体设计</h2><p>Java中的线程池核心实现类是ThreadPoolExecutor。我们首先来看一下ThreadPoolExecutor的UML类图，了解下ThreadPoolExecutor的继承关系。</p><p><img src="/2022/06/28/multithread02/912883e51327e0c7a9d753d11896326511272.png" alt="图1 ThreadPoolExecutor UML类图"></p><p>ThreadPoolExecutor实现的顶层接口是Executor，顶层接口Executor提供了一种思想：将任务提交和任务执行进行解耦。用户无需关注如何创建线程，如何调度线程来执行任务，用户只需提供Runnable对象，将任务的运行逻辑提交到执行器(Executor)中，<strong>由Executor框架完成线程的调配和任务</strong>的执行部分。</p><p>ExecutorService接口增加了一些能力：（1）扩充执行任务的能力，补充可以为一个或一批异步任务生成Future的方法；（2）提供了管控线程池的方法，比如停止线程池的运行。</p><p>AbstractExecutorService则是上层的抽象类，将执行任务的流程串联了起来，保证下层的实现只需关注一个执行任务的方法即可。</p><p>最下层的实现类ThreadPoolExecutor实现最复杂的运行部分，ThreadPoolExecutor将会一方面维护自身的生命周期，另一方面同时管理线程和任务，使两者良好的结合从而执行并行任务。</p><h4 id="ThreadPoolExecutor运行机制"><a href="#ThreadPoolExecutor运行机制" class="headerlink" title="ThreadPoolExecutor运行机制"></a>ThreadPoolExecutor运行机制</h4><p><img src="/2022/06/28/multithread02/77441586f6b312a54264e3fcf5eebe2663494.png" alt="图2 ThreadPoolExecutor运行流程"></p><p>线程池在内部实际上构建了一个生产者消费者模型，<font color="red">将线程和任务两者解耦，并不直接关联，</font>从而良好的缓冲任务，复用线程。线程池的运行主要分成两部分：<strong>任务管理、线程管理</strong>。任务管理部分充当生产者的角色，当任务提交后，线程池会判断该任务后续的流转：</p><p>（1）直接申请线程执行该任务；</p><p>（2）缓冲到队列中等待线程执行；</p><p>（3）拒绝该任务。</p><p>线程管理部分是消费者，它们被统一维护在线程池内，根据任务请求进行线程的分配，当线程执行完任务后则会继续获取新的任务去执行，最终当线程获取不到任务的时候，线程就会被回收。</p><p>接下来，我们会按照以下三个部分去详细讲解线程池运行机制：</p><ol><li>线程池如何维护自身状态。</li><li>线程池如何管理任务。</li><li>线程池如何管理线程。</li></ol><h4 id="未完待耕"><a href="#未完待耕" class="headerlink" title="未完待耕~~~"></a>未完待耕~~~</h4><h2 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h2><p><a href="https://www.cnblogs.com/heihaozi/p/11741735.html">https://www.cnblogs.com/heihaozi/p/11741735.html</a></p><p><a href="https://blog.csdn.net/u012426959/article/details/78795784">https://blog.csdn.net/u012426959/article/details/78795784</a></p><p><a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html</a></p><end></end>]]></content>
      
      
      <categories>
          
          <category> java多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gecco学习日记02</title>
      <link href="/2022/06/28/gecco02/"/>
      <url>/2022/06/28/gecco02/</url>
      
        <content type="html"><![CDATA[<h1 id="Gecco学习日记02：梳理-与-分析"><a href="#Gecco学习日记02：梳理-与-分析" class="headerlink" title="Gecco学习日记02：梳理 与 分析"></a>Gecco学习日记02：梳理 与 分析</h1><p>Gecco的目标是提供一个完善的主题爬虫框架，简化下载和内容抽取的开发，利用<strong>管道过滤器</strong>模式，提供灵活的<strong>内容清洗</strong>和<strong>持久化处理</strong>模式，让开发人员把更多的精力投入到与业务主题相关的内容处理上。</p><h2 id="Gecco引擎初始化梳理"><a href="#Gecco引擎初始化梳理" class="headerlink" title="Gecco引擎初始化梳理"></a>Gecco引擎初始化梳理</h2><p>GeccoEngine是一个线程类，其中包含一些关键类有：</p><p>状态性的——</p><blockquote><p>请求队列：Scheduler，装着请求对象的队列<br>请求类：Request，代表一个应该进行的请求，存放在请求队列中，多个爬虫对象并发地从队列中取得请求对象，根据之发起HTTP请求<br>响应类：Response，将爬虫对象发起HTTP请求后获得的结果，封装成响应对象，由Render转换成实体对象</p></blockquote><p>行为性的——</p><blockquote><p>引擎类：Engine，总的配置和入口<br>爬虫类：Spider，一个引擎可以有多个爬虫对象并发工作，每个爬虫对象有一个单独的线程，爬虫的线程主循环中，从请求队列中获得请求对象，交给下载器<br>下载器：Downloader，用于根据一个请求对象，发起一次HTTP请求，将HTTP响应封装成响应对象<br>转换器：Render，用于将响应对象转换成用户定义的实体类的对象，实现方式是通过反射读取实体类的字段上的注解并处理</p></blockquote><p>对其运行过程进行流程梳理。</p><ol><li>首先GeccoEngine进行一系列初始化（scheduler、spiderBeanFactory、startRequests、spiders）。</li><li>scheduler将需要下载的请求都放在这里管理，可以认为这里是一个队列，保存了所有待抓取的请求。</li><li>每个爬虫(Spider)可以认为是一个单独线程，在每个爬虫对象线程的主循环中，爬虫会从Scheduler中获取需要待抓取的请求对象，由下载器进行下载。爬虫的任务就是下载网页并渲染相应的JavaBean。</li><li>下载器(Downloader)，使用请求对象(startRequests)，发起HTTP请求，把HTTP响应封装成响应对象</li><li>转换器，使用响应对象，及实体类上的注解信息，将响应对象渲染成有业务意义的实体对象</li><li>在爬取信息过程中，GeccoEngine会监控爬虫的基本信息，并导出jmx信息</li></ol><h2 id="GeccoEngine基本配置项"><a href="#GeccoEngine基本配置项" class="headerlink" title="GeccoEngine基本配置项"></a>GeccoEngine基本配置项</h2><ul><li>loop(true)：表示是否循环抓取，默认为false</li><li>thread(2)：表示开启的爬虫线程数量，默认是1，需要注意的是线程数量要小于或者等于start请求的数量</li><li>interval(2000)：表示某个线程在抓取完成一个请求后的间隔时间，单位是毫秒，系统会在左右1秒时间内随机。如果为2000，系统会在1000～3000之间随机选取。</li><li>mobile(false)：表示使用移动端还是pc端的UserAgent。默认为false使用pc端的UserAgent。</li><li>debug(true)：是否开启debug模式，如果开启debug模式，会在控制台输出jsoup元素抽取的日志。</li><li>pipelineFactory(PipelineFactory)：自定义Pipeline工厂类</li><li>scheduler(Scheduler)：自定义请求队列管理器</li></ul><h2 id="非阻塞启动和阻塞启动"><a href="#非阻塞启动和阻塞启动" class="headerlink" title="非阻塞启动和阻塞启动"></a>非阻塞启动和阻塞启动</h2><ul><li>start()：非阻塞启动，GeccoEngine会单独启动线程运行，推荐以该方式运行。线程模型如下：</li></ul><p>Main Thread–&gt;GeccoEngine Thread–&gt;Spider Thread</p><ul><li>run()：阻塞启动，GeccoEngine在主线程中启动运行，非循环模式GeccoEngine需要等待其他爬虫线程运行完毕后才会退出。线程模型r如下：</li></ul><p>Main Thread–&gt;Spider Thread</p><h2 id="Gecco如何匹配URL"><a href="#Gecco如何匹配URL" class="headerlink" title="Gecco如何匹配URL"></a>Gecco如何匹配URL</h2><ul><li><h4 id="匹配URL的作用"><a href="#匹配URL的作用" class="headerlink" title="匹配URL的作用"></a>匹配URL的作用</h4></li></ul><p>​匹配URL是告知Gecco，这种格式的url对应的网页会被渲染成当前的SpiderBean。</p><ul><li><h4 id="matchUrl如何写"><a href="#matchUrl如何写" class="headerlink" title="matchUrl如何写"></a>matchUrl如何写</h4></li></ul><p>​完全匹配：@Gecco(matchUrl=”<a href="https://github.com/&quot;">https://github.com/"</a>)</p><p>​模糊匹配：@Gecco(matchUrl=”<a href="https://github.com/%7Buser%7D/%7Bproject%7D&quot;">https://github.com/{user}/{project}"</a>)</p><p>​这样会匹配所有类似格式的url，例如<a href="https://github.com/xtuhcy/gecco">https://github.com/xtuhcy/gecco</a></p><p>​任意匹配：@Gecco，如果你不写matchUrl，任何格式的url都会被匹配，这种方式一般用作通用爬虫，例如：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Gecco</span><span class="token punctuation">(</span>pipelines<span class="token operator">=</span><span class="token string">"consolePipeline"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CommonCrawler</span> <span class="token keyword">implements</span> <span class="token class-name">HtmlBean</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token operator">-</span>8870768223740844229L<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Request</span>    <span class="token keyword">private</span> HttpRequest request<span class="token punctuation">;</span>    <span class="token annotation punctuation">@HtmlField</span><span class="token punctuation">(</span>cssPath<span class="token operator">=</span><span class="token string">"body"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> String body<span class="token punctuation">;</span>    <span class="token keyword">public</span> HttpRequest <span class="token function">getRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> request<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setRequest</span><span class="token punctuation">(</span>HttpRequest request<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>request <span class="token operator">=</span> request<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> body<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setBody</span><span class="token punctuation">(</span>String body<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>body <span class="token operator">=</span> body<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        GeccoEngine<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">classpath</span><span class="token punctuation">(</span><span class="token string">"com.geccocrawler.gecco.demo"</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token string">"https://www.baidu.com/"</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">interval</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Gecco </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gecco </tag>
            
            <tag> 网络爬虫 </tag>
            
            <tag> 开源项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gecco学习日记01</title>
      <link href="/2022/06/27/gecco01/"/>
      <url>/2022/06/27/gecco01/</url>
      
        <content type="html"><![CDATA[<h1 id="Gecco学习日记01：网络爬虫的定义与Gecco快速开始"><a href="#Gecco学习日记01：网络爬虫的定义与Gecco快速开始" class="headerlink" title="Gecco学习日记01：网络爬虫的定义与Gecco快速开始"></a>Gecco学习日记01：网络爬虫的定义与Gecco快速开始</h1><h2 id="什么是爬虫？"><a href="#什么是爬虫？" class="headerlink" title="什么是爬虫？"></a>什么是爬虫？</h2><p>WiKi中的定义：网络爬虫（英语：web crawler），也叫网络蜘蛛（spider），是一种用来自动浏览万维网的网络机器人。其目的一般为编纂<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E7%B4%A2%E5%BC%95">网络索引</a>。<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E">网络</a><a href="https://zh.wikipedia.org/wiki/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E">搜索引擎</a>等站点通过爬虫软件更新自身的<a href="https://zh.wikipedia.org/w/index.php?title=%E7%B6%B2%E7%AB%99%E5%85%A7%E5%AE%B9&amp;action=edit&amp;redlink=1">网站内容</a>或其对其他网站的索引。网络爬虫可以将自己所访问的页面保存下来，以便搜索引擎事后生成<a href="https://zh.wikipedia.org/w/index.php?title=%E7%B4%A2%E5%BC%95_(%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E)&amp;action=edit&amp;redlink=1">索引</a>供用户搜索。</p><p>通俗来讲，爬虫就是一个探测机器，它的基本操作就是模拟人的行为去各个网站溜达，点点按钮，查查数据，或者把看到的信息背回来。就像一只虫子在一幢楼里不知疲倦地爬来爬去。</p><p>由此我们可以知道，爬虫的应用领域有：搜索引擎、比价网站、舆情系统、知识信息储备。</p><h2 id="网络爬虫工作原理是什么？"><a href="#网络爬虫工作原理是什么？" class="headerlink" title="网络爬虫工作原理是什么？"></a><strong>网络爬虫工作原理是什么？</strong></h2><p>网络爬虫一般分为如下两个阶段：第一阶段，<strong>URL库初始化</strong>然后开始爬取；第二阶段，爬虫读取没有访问过的URL，来确定它的工作范围。对于所要抓取的URL，具体步骤如下：</p><ol><li>获取URL链接；</li><li>解析内容，获取URL相关数据；</li><li>存储有价值的数据；</li><li>对新抓取的RL进行规范化；</li><li>过滤掉不相关的URL；</li><li>将要抓取的URL更新到URL库中；</li><li>重复步骤2，直到终止条件为止。</li></ol><h2 id="爬虫实现策略包括哪些？"><a href="#爬虫实现策略包括哪些？" class="headerlink" title="爬虫实现策略包括哪些？"></a><strong>爬虫实现策略包括哪些？</strong></h2><ul><li>指定初始URL下载的选择策略</li><li>检测页面是否更新的重新访问策略</li><li>定义如何避免网站过度访问的约定性策略</li><li>如何部署分布式网络爬虫的并行策略</li></ul><p>网络爬虫主要爬取策略有：<strong>深度优先策略</strong>、<strong>宽度优先策略</strong>等等。</p><h2 id="一个典型的网络爬虫系统组成包括哪些？"><a href="#一个典型的网络爬虫系统组成包括哪些？" class="headerlink" title="一个典型的网络爬虫系统组成包括哪些？"></a><strong>一个典型的网络爬虫系统组成包括哪些？</strong></h2><p>网络爬虫本质是对网络资源的抓取、分析、过滤、存储。一个典型的网络爬虫系统组成主要有<strong>控制器，解析器，资源库</strong>三部分组成。</p><blockquote><p>控制器负责给多线程中的各个爬虫线程分配工作任务。</p><p>解析器的主要工作是下载网页，进行页面的处理。</p><p>资源库是用来存放下载到的网页资源，一般都采用大型的数据库存储，如Oracle数据库，并对其建立索引。</p></blockquote><h2 id="知己知彼：常用的反爬虫手段"><a href="#知己知彼：常用的反爬虫手段" class="headerlink" title="知己知彼：常用的反爬虫手段"></a>知己知彼：常用的反爬虫手段</h2><p>常见的反爬虫手段包括：统计IP访问限制、单个session访问量以及单个User-agent的访问，基于网站流量统计和日志分析反爬虫，通过Headers反爬虫，添加验证码限制等。</p><h2 id="介绍：什么是Gecco？"><a href="#介绍：什么是Gecco？" class="headerlink" title="介绍：什么是Gecco？"></a>介绍：什么是Gecco？</h2><p>Gecco 是一款基于 java 语言开发的轻量化的易用的网络爬虫。Gecco 整合了 jsoup、httpclient、fastjson、spring、htmlunit、redission 等优秀框架，让您只需要配置一些 jquery 风格的选择器就能很快的写出一个爬虫。</p><h3 id="Gecco主要特征"><a href="#Gecco主要特征" class="headerlink" title="Gecco主要特征"></a>Gecco主要特征</h3><ol><li>使用 jquery 风格的选择器抽取元素</li><li>支持爬取规则的动态配置和加载</li><li>支持页面中的异步 ajax 请求</li><li>支持页面中的 javascript 变量抽取</li><li>利用 Redis 实现分布式抓取</li><li>支持结合 Spring 开发业务逻辑</li><li>支持 htmlunit 扩展</li><li>支持插件扩展机制</li><li>支持下载时 UserAgent 随机选取</li><li>支持下载代理服务器随机选取</li></ol><h2 id="框架概述"><a href="#框架概述" class="headerlink" title="框架概述"></a>框架概述</h2><p><img src="/2022/06/27/gecco01/jiagou.jpg" alt="img"></p><h3 id="GeccoEngine"><a href="#GeccoEngine" class="headerlink" title="GeccoEngine"></a>GeccoEngine</h3><p>GeccoEngine 是爬虫引擎，每个爬虫引擎最好是一个独立进程，在分布式爬虫场景下，建议每台爬虫服务器（物理机或者虚机）运行一个 GeccoEngine。爬虫引擎包括 Scheduler、Downloader、Spider、SpiderBeanFactory、PipelineFactory 5 个主要模块。</p><h3 id="Scheduler（下载地址管理）"><a href="#Scheduler（下载地址管理）" class="headerlink" title="Scheduler（下载地址管理）"></a>Scheduler（下载地址管理）</h3><p>通常爬虫需要一个有效管理下载地址的角色，Scheduler 负责下载地址的管理。gecco 对初始地址的管理使用 StartScheduler，StartScheduler 内部采用一个<strong>阻塞的 FIFO 的队列</strong>。初始地址通常会派生出很多其他待抓取的地址，派生出来的其他地址采用 SpiderScheduler 进行管理，SpiderScheduler 内部采用<strong>线程安全的非阻塞 FIFO 队列</strong>。这种设计使的 gecco 对初始地址采用了深度遍历的策略，即一个线程抓取完一个初始地址后才会去抓取另外一个初始地址；对初始地址派生出来的地址，采用广度优先策略。</p><h3 id="Downloader（下载器）"><a href="#Downloader（下载器）" class="headerlink" title="Downloader（下载器）"></a>Downloader（下载器）</h3><p>Downloader 负责从 Scheduler 中获取需要下载的请求，gecco 默认采用 httpclient4.x 作为下载引擎。通过实现 Downloader 接口可以自定义自己的下载引擎。你也可以对每个请求定义 BeforeDownload 和 AfterDownload，实现不同的请求下载的个性需求。</p><h3 id="SpiderBeanFactory（爬虫工厂类：生成爬虫SpiderBean）"><a href="#SpiderBeanFactory（爬虫工厂类：生成爬虫SpiderBean）" class="headerlink" title="SpiderBeanFactory（爬虫工厂类：生成爬虫SpiderBean）"></a>SpiderBeanFactory（爬虫工厂类：生成爬虫SpiderBean）</h3><p>Gecco 将下载下来的内容渲染为 SpiderBean，所有爬虫渲染的 JavaBean 都统一继承 SpiderBean，SpiderBean 又分为 HtmlBean 和 JsonBean 分别对应 html 页面的渲染和 json 数据的渲染。<strong>SpiderBeanFactroy 会根据请求的 url 地址，匹配相应的 SpiderBean，同时生成该 SpiderBean 的上下文 SpiderBeanContext</strong>。上下文 SpiderBeanContext 会告知这个 SpiderBean 采用什么渲染器，采用那个下载器，渲染完成后采用哪些 pipeline 处理等相关上下文信息。</p><h3 id="PipelineFactory（管道工厂类）"><a href="#PipelineFactory（管道工厂类）" class="headerlink" title="PipelineFactory（管道工厂类）"></a>PipelineFactory（管道工厂类）</h3><p>pipeline 是 SpiderBean 渲染完成的后续业务处理单元，PipelineFactory 是 pipeline 的工厂类，负责 pipeline 实例化。通过扩展 PipelineFactory 就可以实现和 Spring 等业务处理框架的整合。</p><h3 id="Spider"><a href="#Spider" class="headerlink" title="Spider"></a>Spider</h3><p>Gecco 框架最核心的类应该是 <strong>Spider 线程</strong>，一个爬虫引擎可以同时运行多个 Spider 线程。Spider 描绘了这个框架运行的基本骨架，<font color="red">先从 Scheduler 获取请求，再通过 <strong>SpiderBeanFactory</strong> 匹配 SpiderBeanClass，再通过 SpiderBeanClass 找到 SpiderBean 的上下文，下载网页并对 SpiderBean 做渲染，将渲染后的 SpiderBean 交给 pipeline 处理。</font></p><h2 id="Maven导入jar包"><a href="#Maven导入jar包" class="headerlink" title="Maven导入jar包"></a>Maven导入jar包</h2><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.geccocrawler<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>gecco<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>x.x.x<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><h2 id="项目quick-start"><a href="#项目quick-start" class="headerlink" title="项目quick-start"></a>项目quick-start</h2><p>快速入门源码：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Gecco</span><span class="token punctuation">(</span>matchUrl<span class="token operator">=</span><span class="token string">"https://github.com/{user}/{project}"</span><span class="token punctuation">,</span>pipelines<span class="token operator">=</span><span class="token string">"consolePipeline"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyGithub</span> <span class="token keyword">implements</span> <span class="token class-name">HtmlBean</span> <span class="token punctuation">{</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token operator">-</span>7127412585200687225L<span class="token punctuation">;</span><span class="token annotation punctuation">@RequestParameter</span><span class="token punctuation">(</span><span class="token string">"user"</span><span class="token punctuation">)</span><span class="token keyword">private</span> String user<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//url中的{user}值</span><span class="token annotation punctuation">@RequestParameter</span><span class="token punctuation">(</span><span class="token string">"project"</span><span class="token punctuation">)</span><span class="token keyword">private</span> String project<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//url中的{project}值</span><span class="token annotation punctuation">@Text</span><span class="token annotation punctuation">@HtmlField</span><span class="token punctuation">(</span>cssPath<span class="token operator">=</span><span class="token string">".pagehead-actions li:nth-child(2) .social-count"</span><span class="token punctuation">)</span><span class="token keyword">private</span> String star<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//抽取页面中的star</span><span class="token annotation punctuation">@Text</span><span class="token annotation punctuation">@HtmlField</span><span class="token punctuation">(</span>cssPath<span class="token operator">=</span><span class="token string">".pagehead-actions li:nth-child(3) .social-count"</span><span class="token punctuation">)</span><span class="token keyword">private</span> String fork<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//抽取页面中的fork</span><span class="token annotation punctuation">@Html</span><span class="token annotation punctuation">@HtmlField</span><span class="token punctuation">(</span>cssPath<span class="token operator">=</span><span class="token string">".entry-content"</span><span class="token punctuation">)</span><span class="token keyword">private</span> String readme<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//抽取页面中的readme</span><span class="token keyword">public</span> String <span class="token function">getReadme</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> readme<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setReadme</span><span class="token punctuation">(</span>String readme<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>readme <span class="token operator">=</span> readme<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> String <span class="token function">getUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> user<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setUser</span><span class="token punctuation">(</span>String user<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>user <span class="token operator">=</span> user<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> String <span class="token function">getProject</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> project<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setProject</span><span class="token punctuation">(</span>String project<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>project <span class="token operator">=</span> project<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> String <span class="token function">getStar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> star<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setStar</span><span class="token punctuation">(</span>String star<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>star <span class="token operator">=</span> star<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> String <span class="token function">getFork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> fork<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setFork</span><span class="token punctuation">(</span>String fork<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>fork <span class="token operator">=</span> fork<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    GeccoEngine<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//工程的包路径</span>    <span class="token punctuation">.</span><span class="token function">classpath</span><span class="token punctuation">(</span><span class="token string">"com.geccocrawler.gecco.demo"</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//开始抓取的页面地址</span>    <span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token string">"https://github.com/xtuhcy/gecco"</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//开启几个爬虫线程</span>    <span class="token punctuation">.</span><span class="token function">thread</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//单个爬虫每次抓取完一个请求后的间隔时间</span>    <span class="token punctuation">.</span><span class="token function">interval</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//循环抓取</span>    <span class="token punctuation">.</span><span class="token function">loop</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//使用pc端userAgent</span>    <span class="token punctuation">.</span><span class="token function">mobile</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//非阻塞方式运行</span>    <span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h3><ul><li>接口HtmlBean说明该爬虫是一个解析html页面的爬虫（gecco还支持json格式的解析）</li><li>注解@Gecco告知该爬虫匹配的url格式(matchUrl)和内容抽取后的bean处理类（pipelines处理类采用管道过滤器模式，可以定义多个处理类）。</li><li>注解@RequestParameter可以注入url中的请求参数，如@RequestParameter(“user”)表示匹配url中的{user}</li><li>注解@HtmlField表示抽取html中的元素，cssPath采用类似jquery的css selector选取元素</li><li>注解@Text表示获取@HtmlField抽取出来的元素的text内容</li><li>注解@Html表示获取@HtmlField抽取出来的元素的html内容（如果不指定默认为@Html）</li><li>GeccoEngine表示爬虫引擎，通过create()初始化，通过start()/run()运行。可以配置一些启动参数如：扫描**@Gecco注解**的包名classpath；开始抓取的url地址star；抓取线程数thread；抓取完一个页面后的间隔时间interval(ms)等</li></ul><p><code>@Gecco</code>自定义注解</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Inherited</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">Gecco</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">/**    * 摒弃正则表达式的匹配方式，采用更容易理解的{value}方式    * 如：https://github.com/{user}/{project}    *     * @return url匹配规则    */</span>   String<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">matchUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">"*"</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/**    * url下载器，默认为httpClientDownloader    *     * @return 下载器    */</span>   String <span class="token function">downloader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">""</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/**    * 下载超时时间    *     * @return 下载超时时间    */</span>   <span class="token keyword">int</span> <span class="token function">timeout</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token number">3000</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/**    * bean渲染完成后，后续的管道过滤器    *     * @return 管道过滤器    */</span>   String<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">pipelines</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">""</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>伏笔</strong>：在启动quickstart之后，打印出了以下错误信息：</p><p><img src="/2022/06/27/gecco01/image-20220628175501708.png" alt="image-20220628175501708"></p><p>具体问题解决看下篇~</p><p>本篇结束</p><end></end>]]></content>
      
      
      <categories>
          
          <category> Gecco </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gecco </tag>
            
            <tag> 网络爬虫 </tag>
            
            <tag> 开源项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程学习日记01：进程、线程</title>
      <link href="/2022/06/26/multithread01/"/>
      <url>/2022/06/26/multithread01/</url>
      
        <content type="html"><![CDATA[<h1 id="进程、线程"><a href="#进程、线程" class="headerlink" title="进程、线程"></a>进程、线程</h1><h2 id="前言：程序是如何跑起来的"><a href="#前言：程序是如何跑起来的" class="headerlink" title="前言：程序是如何跑起来的"></a>前言：程序是如何跑起来的</h2><p>​通常来说，像我们苦逼码农写的软件都是文本格式的代码，这些代码不能直接被计算机识别执行，需要使用编译器<font color:red="">编译</font>成操作系统或者虚拟机可以运行的代码（可执行代码），它们都被存储在文件系统中。</p><p>​要想让程序处理数据，完成计算任务，必须把程序从外部设备加载到内存中，并在操作系统的管理调度下交给 CPU 去执行，去运行起来，才能真正发挥软件的作用，程序运行起来以后，被称作<strong>进程</strong>。</p><p>​进程除了包含可执行的程序代码，还包括进程在运行期使用的内存<strong>堆空间、栈空间</strong>、供操作系统管理用的数据结构。</p><h2 id="进程（process）"><a href="#进程（process）" class="headerlink" title="进程（process）"></a>进程（process）</h2><ul><li><p>程序在系统上的一次执行过程</p></li><li><p>每个进程有独立的<strong>地址空间</strong>，进程切换时需要切换进程页表，以及切换运行环境（寄存器等）</p></li></ul><h4 id="早期内存分配机制"><a href="#早期内存分配机制" class="headerlink" title="早期内存分配机制"></a>早期内存分配机制</h4><p>  ​在早期的计算机中，要运行一个程序，会把这些程序全都装入内存，程序都是直接运行在内存上的，也就是说<strong>程序中访问的内存地址都是实际的物理内存地址</strong>。当计算机同时运行多个程序时，必须保证这些程序用到的内存总量要小于计算机实际物理内存的大小。</p><p>  ​那当程序同时运行多个程序时，操作系统是如何为这些程序分配内存的呢？</p><blockquote><p>举个栗子，某台计算机总的内存大小是 128M ，现在同时运行两个程序 A 和 B ， A 需占用内存 10M ， B 需占用内存 110M 。计算机在给程序分配内存时会采取这样的方法：先将内存中的前 10M 分配给程序 A ，接着再从内存中剩余的 118M 中划分出 110M 分配给程序 B 。</p></blockquote><p><img src="/2022/06/26/multithread01/215125w5kywrxk0yhzw1mj.png" alt="image.png"></p><p>这种分配方法可以保证程序 A 和程序 B 都能运行，但是<strong>这种简单的内存分配策略问题很多</strong>。</p><p><strong>安全的问题</strong> ：进程地址空间不隔离。由于程序都是直接访问物理内存，所以恶意程序可以随意修改别的进程的内存数据，以达到破坏的目的。有些非恶意的，但是有 bug 的程序也可能不小心修改了其它程序的内存数据，就会导致其它程序的运行出现异常。</p><p><strong>效率的问题 <strong>：内存使用效率低。在 A 和 B 都运行的情况下，如果用户又运行了程序 C，而程序 C 需要 20M 大小的内存才能运行，而此时系统只剩下 8M 的空间可供使用，所以此时系统必须在已运行的程序中选择一个将该程序的数据暂时拷贝到硬盘上</strong>（知识点：外存硬盘属于I/O设备）</strong>，释放出部分空间来供程序 C 使用，然后再将程序 C 的数据全部装入内存中运行。可以想象得到，在这个过程中，有大量的数据在装入装出，导致效率十分低下。</p><p><strong>地址随机性的问题</strong>：程序运行的地址不确定。当内存中的剩余空间可以满足程序 C 的要求后，操作系统会在剩余空间中随机分配一段连续的 20M 大小的空间给程序 C 使用，因为是随机分配的，所以程序运行的地址是不确定的。</p><h4 id="内存分段机制"><a href="#内存分段机制" class="headerlink" title="内存分段机制"></a>内存分段机制</h4><p><strong>虚内存</strong>：内存地址不是真正的物理地址，而是一个<strong>虚拟地址</strong>（通过映射计算）。<strong>按照这种方法，程序中访问的内存地址不再是实际的物理内存地址，而是一个虚拟地址，然后由操作系统将这个虚拟地址映射到适当的物理内存地址上</strong>。只要操作系统处理好虚拟地址到物理内存地址的<strong>映射</strong>，就可以保证不同的程序最终访问的内存地址位于不同的区域，彼此没有重叠，就可以达到内存地址空间隔离的效果。</p><p>当创建一个进程时，操作系统会为该进程分配一个 4GB 大小的虚拟进程地址空间。之所以是 4GB ，是因为在 32 位的操作系统中，一个指针长度是 4 字节，而 4 字节指针的寻址能力是从<code> 0x00000000</code>~`0xFFFFFFFF<code>，最大值 </code>0xFFFFFFFF` 表示的即为 4GB 大小的容量。</p><p>当进程创建时，每个进程都会有一个自己的 4GB 虚拟地址空间。要注意的是这个 4GB 的地址空间是“虚拟”的，并不是真实存在的，而且每个进程只能访问自己虚拟地址空间中的数据，无法访问别的进程中的数据，通过这种方法实现了进程间的<strong>地址隔离</strong>。</p><p>再举个例子。</p><blockquote><p>假设有两个进程 A 和 B ，进程 A 所需内存大小为 10M ，其虚拟地址空间分布在 0x00000000 到 0x00A00000 ，进程 B 所需内存为 100M ，其虚拟地址空间分布为 0x00000000 到 0x06400000 。那么按照分段的映射方法，进程 A 在物理内存上映射区域为 0x00100000 到 0x00B00000 ，进程 B 在物理内存上映射区域为0x00C00000 到 0x07000000 。于是进程 A 和进程 B 分别被映射到了不同的内存区间，彼此互不重叠，实现了地址隔离。从应用程序的角度看来，进程 A 的地址空间就是分布在 0x00000000 到 0x00A00000 </p></blockquote><p>在 Windows 系统下，这个虚拟地址空间被分成了 4 部分： <strong>NULL 指针区、用户区、 64KB 禁入区、内核区</strong>。<strong>应用程序能使用的只是用户区而已</strong>，大约 2GB 左右 ( 最大可以调整到 3GB) 。内核区为 2GB ，内核区保存的是系统线程调度、内存管理、设备驱动等数据，这部分数据供所有的进程共享，但应用程序是不能直接访问的。</p><p>这种分段的映射方法虽然解决了上述中的安全问题和地址随机性的问题，但并没能解决内存的使用效率问题。在分段的映射方法中，每次换入换出内存的都是整个程序， 这样会造成大量的磁盘访问操作，导致效率低下。所以这种映射方法还是稍显粗糙，粒度比较大。基于此情况，人们想到了粒度更小的内存分割和映射方法，这种方法就是分页 (Paging) 。 </p><h4 id="内存分页机制"><a href="#内存分页机制" class="headerlink" title="内存分页机制"></a>内存分页机制</h4><p>分页的基本方法是，将地址空间分成许多的页。每页的大小由 CPU 决定，然后由操作系统选择页的大小。目前 Inter 系列的 CPU 支持 4KB 或 4MB 的页大小，而 PC上目前都选择使用 4KB 。按这种选择， 4GB 虚拟地址空间共可以分成 1048576（1024*1024） 页， 512M 的物理内存可以分为 131072 个页。显然<strong>虚拟空间的页数要比物理空间的页数多得多</strong>。</p><blockquote><p>例如：银行存钱，张三：存1号箱，李四：存1号箱，但是两个1号箱并不是同一个，有一个特殊的对应表来查询实际的物理位置</p></blockquote><p>在分段的方法中，每次程序运行时总是把程序全部装入内存，而分页的方法则有所不同。分页的思想是程序运行时用到哪页就为哪页分配内存，没用到的页暂时保留在硬盘上。当用到这些页时再在物理地址空间中为这些页分配内存，然后建立虚拟地址空间中的页和刚分配的物理内存页间的映射。</p><h2 id="线程（Thread）"><a href="#线程（Thread）" class="headerlink" title="线程（Thread）"></a>线程（Thread）</h2><ul><li><p>定义：<strong>进程真正的执行过程是线程</strong>，每个进程在创立时会缺省的创立一个主线程，当然，进程还可以创建更多的线程，所有的线程属于这个进程，进程销毁时，进程下所有线程也销毁，<strong>同一个进程</strong>里面 <strong>切换线程</strong>时 **<font color="red">不需要切换页表</font>**（节约时间），需要切换运行时环境（寄存器等）</p></li><li><p>线程一定属于进程</p></li><li><p>每个线程都有独立的运行时空间</p></li><li><p>同一个进程里面 切换线程时 不需要切换页表（节约时间），需要切换运行时环境（寄存器等）</p></li><li><p>一个进程多个线程并发</p></li></ul><h3 id="Java中的线程生命周期"><a href="#Java中的线程生命周期" class="headerlink" title="Java中的线程生命周期"></a>Java中的线程生命周期</h3><p>线程是一个动态执行的过程，它也有一个从产生到死亡的过程。Java中的线程生命周期大体可以分为五种状态：</p><h4 id="1、初始化状态（NEW）"><a href="#1、初始化状态（NEW）" class="headerlink" title="1、初始化状态（NEW）"></a>1、<strong>初始化状态（NEW）</strong></h4><ul><li>此时JVM为其分配内存，并初始化其成员变量的值；</li><li><strong>此时线程对象没有表现出任何线程的动态特征</strong>，程序也不会执行线程的线程执行体；</li></ul><h4 id="2、可运行-x2F-运行状态（RUNNABLE）"><a href="#2、可运行-x2F-运行状态（RUNNABLE）" class="headerlink" title="2、可运行/运行状态（RUNNABLE）"></a>2、<strong>可运行/运行状态（RUNNABLE）</strong></h4><p>线程对象调用了start()方法之后，该线程处于 <strong>就绪状态</strong>，此时JVM会为其<strong>创建方法调用栈和程序计数器</strong></p><p>该状态的线程一直处于 <strong>线程就绪队列</strong>（尽管是采用队列形式，事实上，<strong>把它称为可运行池而不是可运行队列</strong>。因为CPU的调度不一定是按照先进先出的顺序来调度的），线程并没有开始运行；</p><ul><li>此时线程 <strong>等待系统为其分配CPU时间片</strong>，并不是说执行了start()方法就立即执行；</li><li><strong>调用start()方法来启动线程，系统会把该run()方法当成线程执行体来处理</strong>。但如果直接调用线程对象的run()方法，则run()方法立即就会被执行，而且在run()方法返回之前其他线程无法并发执行。也就是说，<strong>系统把线程对象当成一个普通对象，而run()方法也是一个普通方法，而不是线程执行体</strong>；</li><li>需要指出的是，调用了线程的run()方法之后，<strong>该线程已经不再处于新建状态</strong>，不要再次调用线程对象的start()方法。<strong>只能对处于新建状态的线程调用start()方法，否则将引发IllegaIThreadStateExccption异常</strong>；</li></ul><h4 id="3、运行状态（RUNNING）"><a href="#3、运行状态（RUNNING）" class="headerlink" title="3、运行状态（RUNNING）"></a><font color="red"><strong>3、运行状态（RUNNING）</strong></font></h4><p>当CPU开始调度处于 <strong>就绪状态</strong> 的线程时，此时线程获得了CPU时间片才得以真正开始执行run()方法的线程执行体，则该线程处于 <strong>运行状态</strong>。</p><ol><li>如果计算机只有一个CPU，那么在任何时刻只有一个线程处于运行状态；</li><li>如果在一个多处理器的机器上，将会有多个线程并行执行，处于运行状态；</li><li>当线程数大于处理器数时，依然会存在多个线程在同一个CPU上轮换的现象；</li></ol><p>线程<strong>不可能一直处于运行状态</strong>，其在运行过程中需要被中断，<strong>目的是使其他线程获得执行的机会，线程调度的细节取决于底层平台所采用的策略</strong>(抢占式or协作式)。</p><h4 id="4、阻塞状态（BLOCKED）"><a href="#4、阻塞状态（BLOCKED）" class="headerlink" title="4、阻塞状态（BLOCKED）"></a><font color="red"><strong>4、阻塞状态（BLOCKED）</strong></font></h4><p>处于运行状态的线程在某些情况下，让出CPU并暂时停止自己的运行，进入 <strong>阻塞状态</strong>。</p><p><strong>当发生如下情况时，线程将会进入阻塞状态：</strong></p><blockquote><ol><li><strong>线程调用sleep()方法</strong>，主动放弃所占用的处理器资源，暂时进入中断状态（<strong>不会释放持有的对象锁</strong>），时间到后等待系统分配CPU继续执行；</li><li><strong>线程调用一个阻塞式IO方法</strong>，在该方法返回之前，该线程被阻塞；</li><li><strong>线程试图获得一个同步监视器</strong>，但该同步监视器正被其他线程所持有;</li><li><strong>程序调用了线程的suspend方法将线程挂起</strong>；</li><li><strong>线程调用wait</strong>，等待notify/notifyAll唤醒时(会释放持有的对象锁)；</li></ol></blockquote><p><strong>阻塞状态分类：</strong></p><blockquote><ol><li><strong>等待阻塞</strong>：运行状态中的 <strong>线程执行wait()方法</strong>，使本线程进入到等待阻塞状态；</li><li><strong>同步阻塞</strong>：线程在 <strong>获取synchronized同步锁失败</strong>（因为锁被其它线程占用），它会进入到同步阻塞状态；</li><li><strong>其他阻塞</strong>：通过调用线程的 <strong>sleep()或join()或发出I/O请求</strong> 时，线程会进入到阻塞状态。当 <strong>sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕</strong> 时，线程重新转入就绪状态；</li></ol></blockquote><p><strong>在阻塞状态的线程只能进入就绪状态，无法直接进入运行状态</strong>。而就绪和运行状态之间的转换通常不受程序控制，<strong>而是由系统线程调度所决定</strong>。当处于就绪状态的线程获得处理器资源时，该线程进入运行状态；<strong>当处于运行状态的线程失去处理器资源时，该线程进入就绪状态</strong>。</p><blockquote><p>但有一个方法例外，<strong>调用yield()方法可以让运行状态的线程转入就绪状态</strong>。</p></blockquote><h5 id="等待状态分类：无限制等待状态（WAITING）、时限等待状态（TIMED-WAITING）"><a href="#等待状态分类：无限制等待状态（WAITING）、时限等待状态（TIMED-WAITING）" class="headerlink" title="等待状态分类：无限制等待状态（WAITING）、时限等待状态（TIMED_WAITING）"></a>等待状态分类：无限制等待状态（WAITING）、时限等待状态（TIMED_WAITING）</h5><p>当线程进入了一个 <strong>时限等待状态</strong>，如：</p><blockquote><p>**sleep(3000)**，等待3秒后线程重新进行 <strong>就绪（RUNNABLE）状态</strong> 继续运行。</p></blockquote><h4 id="5、终止状态（TERMINATED）"><a href="#5、终止状态（TERMINATED）" class="headerlink" title="5、终止状态（TERMINATED）"></a><strong>5、终止状态（TERMINATED）</strong></h4><p>线程会以如下3种方式结束，结束后就处于 <strong>死亡状态</strong>：</p><blockquote><ol><li><strong>run()或call()方法执行完成</strong>，线程正常结束；</li><li><strong>线程抛出一个未捕获的Exception或Error</strong>；</li><li><strong>直接调用该线程stop()方法来结束该线程</strong>—该方法容易导致死锁，通常不推荐使用；</li></ol></blockquote><p><strong>处于死亡状态的线程对象也许是活的，但是，它已经不是一个单独执行的线程</strong>。线程一旦死亡，就不能复生。 <strong>如果在一个死去的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常</strong>。</p><p><strong>所以，需要注意的是：</strong></p><blockquote><p>一旦线程通过start()方法启动后就再也不能回到新建（NEW）状态，线程终止后也不能再回到就绪（RUNNABLE）状态。</p></blockquote><p><strong>需要重点理解的是：虽然Java语言中线程的状态比较多，但是，其实<font color="red">在操作系统层面，Java线程中的阻塞状态（BLOCKED）、无时限等待状态（WAITING）、有时限等待状态（TIMED_WAITING）都是一种状态，即通用线程生命周期中的休眠状态。</font>也就是说，只要Java中的线程处于这三种状态时，那么，这个线程就没有CPU的使用权。</strong></p><p>下面的图表示Java中线程的生命周期。</p><p><img src="/2022/06/26/multithread01/ThreadLife.png" alt="image.png"></p><h2 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h2><p><strong><a href="https://juejin.cn/post/6844903558433734669">https://juejin.cn/post/6844903558433734669</a></strong></p><p><strong><a href="https://developer.huawei.com/consumer/cn/forum/topic/0202779877806640557?fid=0101592429757310384">https://developer.huawei.com/consumer/cn/forum/topic/0202779877806640557?fid=0101592429757310384</a></strong></p><end></end>]]></content>
      
      
      <categories>
          
          <category> java多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javaSE 面试题01</title>
      <link href="/2022/06/25/javasems01/"/>
      <url>/2022/06/25/javasems01/</url>
      
        <content type="html"><![CDATA[<h2 id="1-面向对象和面向过程的区别"><a href="#1-面向对象和面向过程的区别" class="headerlink" title="1. 面向对象和面向过程的区别"></a>1. 面向对象和面向过程的区别</h2><p><strong>面向过程：</strong> </p><p>优点：性能高，类的实例化是有较大开销的，且占用更多的内存，在注重性能的开发场合，例如单片机、嵌入式开发、Linux/Unix内核等场景中一般采用面向过程开发。</p><p>缺点：代码逻辑贴近机器逻辑，不易维护；不易复用；不易扩展。</p><p><strong>面向对象：</strong> </p><p>优点：易维护；易复用；易扩展；面向对象有<strong>封装、继承、多态</strong>的特性，可以设计出低耦合的系统。</p><p>缺点：性能比面向过程低，一般用于业务层、比如业务中间件。</p><h2 id="2-Java语言有哪些特点？"><a href="#2-Java语言有哪些特点？" class="headerlink" title="2. Java语言有哪些特点？"></a>2. Java语言有哪些特点？</h2><p>面向对象（封装，继承，多态）；</p><p>平台无关性（Java虚拟机实现平台无关性），编译与解释并存；</p><p>使用广泛，有很多可用的库</p><h2 id="3-什么是字节码？采用字节码的最大好处是什么？"><a href="#3-什么是字节码？采用字节码的最大好处是什么？" class="headerlink" title="3. 什么是字节码？采用字节码的最大好处是什么？"></a><font color="red">3. 什么是字节码？采用字节码的最大好处是什么？</font></h2><p><strong>java中的编译器和解释器：</strong> </p><p>Java引入了虚拟机（JVM），即在机器和编译程序之间加入了一层抽象的虚拟的机器。</p><p>在不同的操作系统上，其实有不同的虚拟机，但是他们都提供给编译程序一个的共同的接口。编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。这种<strong>供虚拟机理解的代码叫做字节码</strong>（Java中是扩展名为.class的文件），它不面向任何特定的处理器，只面向虚拟机。</p><p>Java源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行，这就是上面提到的Java的特点的编译与解释并存。 </p><p><strong>Java源代码—-&gt;编译器—-&gt;jvm可执行的Java字节码(即虚拟指令)—-&gt;jvm—-&gt;jvm中解释器—–&gt;机器可执行的二进制机器码—-&gt;程序运行。</strong></p><p>JIT：Just In Time，虚拟机的一种优化手段，<strong>如果某个方法或者代码块频繁的被调用，虚拟机会把这段代码标记为“热点代码”</strong>，并将这段字节码一次性的编译为机器码，以提高运行效率。Java中的JIT是HotSpot。</p><p><strong>采用字节码的好处：</strong></p><p> Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。</p><h2 id="4-什么是JDK-什么是JRE？"><a href="#4-什么是JDK-什么是JRE？" class="headerlink" title="4. 什么是JDK? 什么是JRE？"></a>4. 什么是JDK? 什么是JRE？</h2><p>  JDK: 顾名思义它是给开发者提供的开发工具箱,是给程序开发者用的。它除了包括完整的JRE（Java Runtime Environment），Java运行环境，还包含了其他供开发者使用的工具包。</p><p>​        JDK中包括：</p><pre class=" language-markdown"><code class="language-markdown"><span class="token list punctuation">1.</span> javac：编译器<span class="token list punctuation">2.</span> java：运行工具<span class="token list punctuation">3.</span> jar：打包工具<span class="token list punctuation">4.</span> javadoc：文档生成器<span class="token list punctuation">5.</span> jdb debugger：调试工具</code></pre><p>  JRE:普通用户而只需要安装JRE（Java Runtime Environment）来 来运行Java程序。而程序开发者必须安装JDK来编译、调试程序。</p><h2 id="5-Java环境变量PATH和CLASSPATH"><a href="#5-Java环境变量PATH和CLASSPATH" class="headerlink" title="5. Java环境变量PATH和CLASSPATH"></a>5. Java环境变量PATH和CLASSPATH</h2><p><strong>PATH环境变量</strong>：</p><ol><li>设定%JAVA_HOME%，并将%JAVA_HOME%/bin加入到 PATH中</li><li>好处：可以在任何文件夹下调用javac, java 等工具。</li></ol><p><strong>CLASSPATH环境变量</strong></p><ol><li>java在运行字节码时，需要通过-classpath指定java类的所在位置，否则会报无法加载主类的错误</li><li>设定%CLASSPATH%后，可以使用这个变量用于指定-classpath参数</li></ol><h2 id="6-字符型常量和字符串常量的区别"><a href="#6-字符型常量和字符串常量的区别" class="headerlink" title="6. 字符型常量和字符串常量的区别"></a>6. 字符型常量和字符串常量的区别</h2><ol><li>形式上：字符常量是单引号引起的一个字符 字符串常量是双引号引起的若干个字符</li><li>含义上：字符常量相当于一个整形值(ASCII值),可以参加表达式运算 字符串常量代表一个地址值(该字符串在内存中存放位置)</li><li>占内存大小：字符常量只占一个字节 字符串常量占若干个字节(<strong>java和C\C++不一样，字符串不需要\0结尾</strong>)。</li></ol><h2 id="7-Java语言采用何种编码方案？有何特点？"><a href="#7-Java语言采用何种编码方案？有何特点？" class="headerlink" title="7. Java语言采用何种编码方案？有何特点？"></a>7. Java语言采用何种编码方案？有何特点？</h2><p>  Java语言采用Unicode编码标准，每个字符占两个字节</p><p>​这里说的编码是Java代码运行时在内存中的编码，不是*.java在文件中的编码。</p><h2 id="8-构造器Constructor是否可被override"><a href="#8-构造器Constructor是否可被override" class="headerlink" title="8. 构造器Constructor是否可被override"></a>8. 构造器Constructor是否可被override</h2><p>  在讲继承的时候我们就知道父类的私有属性和构造方法并不能被继承，所以Constructor也就不能被override（子类覆盖父类的同名方法）,但是可以overload（方法相同，但是参数不同）,所以你可以看到一个类中有多个构造函数的情况。</p><p><strong>override和overload的区别：</strong></p><p>override：发生在父子类中，方法名、参数列表必须相同，返回值小于等于父类，抛出的异常小于等于父类，访问修饰符大于等于父类；如果父类方法访问修饰符为private则子类中就不是重写。</p><p>overload：发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。</p><h2 id="9-java-面向对象编程三大特性"><a href="#9-java-面向对象编程三大特性" class="headerlink" title="9. java 面向对象编程三大特性"></a>9. java 面向对象编程三大特性</h2><p><strong>封装</strong>：对象的属性或者方法，可以隐藏起来，禁止被外部访问</p><pre class=" language-markdown"><code class="language-markdown"><span class="token code keyword">    9. 封装：访问权限 protected friendly(什么都不写，default)</span><span class="token code keyword">                 当前类   派生类   同一个package里的类    不同package里的类</span><span class="token code keyword">        public    Yes     Yes            Yes              Yes</span><span class="token code keyword">        protected Yes     Yes            Yes               No</span><span class="token code keyword">        (default) Yes  看是否同一个package Yes               No</span><span class="token code keyword">        private   Yes     No             No                No</span></code></pre><p><strong>继承</strong>：派生类可以使用基类的属性和方法（一般方法，构造方法），也可以定义自己的属性和方法</p><p><strong>多态</strong>：动态绑定，决定调用基类的方法还是派生类的方法，由实例事实上是哪个类的实例来决定，而不是由引用的类型决定。</p><h2 id="10-java中equals方法的用法以及-x3D-x3D-的用法"><a href="#10-java中equals方法的用法以及-x3D-x3D-的用法" class="headerlink" title="10. java中equals方法的用法以及==的用法"></a>10. java中equals方法的用法以及==的用法</h2><p>“==”比较两个变量本身的值，即两个对象在内存中的首地址。</p><p>“equals()”比较字符串中所包含的内容是否相同。</p><p>主要适用于String，原始类型的包装类</p><pre class=" language-java"><code class="language-java">String s1<span class="token punctuation">,</span>s2<span class="token punctuation">,</span>s3 <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">,</span> s4 <span class="token operator">=</span><span class="token string">"abc"</span> <span class="token punctuation">;</span>s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>s2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>s1 == s2: false</p><p>s1.equals(s2): true</p><p>s3 == s4: true</p><p>s3.equals(s4): true</p><pre class=" language-java"><code class="language-java">String s1 <span class="token operator">=</span> <span class="token string">"123"</span><span class="token punctuation">;</span> String s2 <span class="token operator">=</span> <span class="token string">"123"</span><span class="token punctuation">;</span> String s3 <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">;</span> String s4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> String s5 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> String s6 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1 <span class="token operator">==</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//（1）true </span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//（2）true </span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1 <span class="token operator">==</span> s3<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//（3）flase </span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>s3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//（4）flase </span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s4 <span class="token operator">==</span> s5<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//（5）flase </span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s4<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>s5<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//（6）true </span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s4 <span class="token operator">==</span> s6<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//（7）flase </span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s4<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>s6<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//（8）flase </span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1 <span class="token operator">==</span> s4<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//（9）false </span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>s4<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//（10）true </span></code></pre><p>特例：如果某些类没有override equals方法，那么他们使用Object.equals，这个方法也是比较地址的。</p><pre class=" language-java"><code class="language-java">StringBuffer s5 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>StringBuffer s6 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>s5 == s6: false</p><p>s5.equals(s6): false</p><h2 id="11-String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的？"><a href="#11-String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的？" class="headerlink" title="11. String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的？"></a>11. String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的？</h2><p><strong>可变性</strong> </p><p>String类中使用<strong>字符数组保存字符串</strong>，private <strong>final</strong> char value[]，所以string对象是不可变的。StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，char[]value，这两种对象都是可变的。  </p><p><strong>线程安全性</strong></p><p>String中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder是StringBuilder与StringBuffer的公共父类，定义了一些字符串的基本操作，如expandCapacity、append、insert、indexOf等公共方法。StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。  </p><p><strong>性能</strong></p><p>每次对String 类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String 对象。StringBuffer每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用StirngBuilder 相比使用StringBuffer 仅能获得10%~15% 左右的性能提升，但却要冒多线程不安全的风险。 </p><p><strong>对于三者使用的总结：</strong> 如果要操作少量的数据用：String；单线程操作字符串缓冲区 下操作大量数据：StringBuilder；多线程操作字符串缓冲区 下操作大量数据：StringBuffer。</p><h2 id="12-自动装箱与拆箱"><a href="#12-自动装箱与拆箱" class="headerlink" title="12. 自动装箱与拆箱"></a>12. 自动装箱与拆箱</h2><p><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</p><p><strong>拆箱</strong>：将包装类型转换为基本数据类型；  </p><p>Java使用自动装箱和拆箱机制，节省了常用数值的内存开销和创建对象的开销，提高了效率，由编译器来完成，编译器会在编译期根据语法决定是否进行装箱和拆箱动作。</p><h2 id="13-说出这段代码的运行结果："><a href="#13-说出这段代码的运行结果：" class="headerlink" title="13. 说出这段代码的运行结果："></a>13. 说出这段代码的运行结果：</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">aClass</span> <span class="token punctuation">{</span>         <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">static</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                      i<span class="token operator">++</span><span class="token punctuation">;</span>              System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 分别打印输出1</span>        <span class="token punctuation">}</span>                <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              aClass obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">aClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              obj<span class="token punctuation">.</span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              obj<span class="token punctuation">.</span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><p>报错：注意，虽然C\C++这样写是对的，java中static不可以修饰局部变量。</p><h2 id="14-在一个静态方法内调用一个非静态成员为什么是非法的？"><a href="#14-在一个静态方法内调用一个非静态成员为什么是非法的？" class="headerlink" title="14. 在一个静态方法内调用一个非静态成员为什么是非法的？"></a>14. 在一个静态方法内调用一个非静态成员为什么是非法的？</h2><p>  由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。</p><h2 id="15-在Java中定义一个不做事且没有参数的构造方法的作用"><a href="#15-在Java中定义一个不做事且没有参数的构造方法的作用" class="headerlink" title="15. 在Java中定义一个不做事且没有参数的构造方法的作用"></a>15. 在Java中定义一个不做事且没有参数的构造方法的作用</h2><p>  Java程序在执行子类的构造方法之前，如果没有用super()来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用super()来调用父类中特定的构造方法，则编译时将发生错误，因为Java程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。</p><h2 id="16-接口和抽象类的区别是什么？"><a href="#16-接口和抽象类的区别是什么？" class="headerlink" title="16. 接口和抽象类的区别是什么？"></a>16. 接口和抽象类的区别是什么？</h2><ol><li><p><strong>接口的方法默认是public</strong>，在JDK 7及以前，所有方法在接口中不能有实现，JDK 8 及以后接口中可以用default关键字实现方法，<strong>抽象类可以有非抽象的方法</strong></p></li><li><p><strong>接口中不能有变量，构造函数和static静态代码块</strong>，只能有常量 public static final，而抽象类没有限制</p></li><li><p><strong>一个类可以实现多个接口，但最多只能实现一个抽象类</strong></p></li><li><p>一个类实现接口的话要实现接口的所有方法，而抽象类不一定</p></li><li><p>从设计层面来说，抽象类是对类的抽象，是一种模板设计，接口是行为能力的抽象，是一种行为的规范。</p></li></ol><h2 id="17-成员变量与局部变量的区别有那些？"><a href="#17-成员变量与局部变量的区别有那些？" class="headerlink" title="17. 成员变量与局部变量的区别有那些？"></a>17. 成员变量与局部变量的区别有那些？</h2><ol><li><p>从语法形式上，看成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；成员变量可以被public,private,static等修饰符所修饰，而<strong>局部变量不能被访问控制修饰符及static所修饰</strong>；<strong>成员变量和局部变量都能被final所修饰</strong>；</p></li><li><p>从变量在内存中的存储方式来看，成员变量是对象的一部分，而<strong>对象存在于堆内存，局部变量存在于栈内存</strong></p></li><li><p>从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。</p></li><li><p>成员变量如果没有被赋初值，则会自动以类型的默认值而赋值（一种情况例外被final修饰但没有被static修饰的成员变量必须显示地赋值）；而局部变量则不会自动赋值。</p></li></ol><h2 id="18-创建一个对象用什么运算符？对象实体与对象引用有何不同？"><a href="#18-创建一个对象用什么运算符？对象实体与对象引用有何不同？" class="headerlink" title="18. 创建一个对象用什么运算符？对象实体与对象引用有何不同？"></a>18. 创建一个对象用什么运算符？对象实体与对象引用有何不同？</h2><p>  new运算符，new创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。一个对象引用可以指向0个或1个对象;一个对象可以有n个引用指向它。</p>]]></content>
      
      
      <categories>
          
          <category> java面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo模板教程</title>
      <link href="/2022/06/22/hexo01/"/>
      <url>/2022/06/22/hexo01/</url>
      
        <content type="html"><![CDATA[<h2 id="1、新建文章"><a href="#1、新建文章" class="headerlink" title="1、新建文章"></a>1、新建文章</h2><blockquote><p>命令格式：</p><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token punctuation">[</span>layout<span class="token punctuation">]</span> <span class="token string">"title"</span> $ hexo n <span class="token punctuation">[</span>layout<span class="token punctuation">]</span> <span class="token string">"title"</span></code></pre></blockquote><p>创建文章前要先选定模板，在hexo中也叫做布局。hexo支持三种布局（layout）：post(默认)、draft、page。</p><p>我们先介绍如何使用已有布局，后面还将会介绍如何自定义布局。</p><p>在博客目录下输入以下命令时，会默认使用post布局，然后自动在<code>source\_posts</code>目录生成一个text1.md文件：</p><pre class=" language-bash"><code class="language-bash">$ hexo n text1</code></pre><p>也可以指定布局：</p><pre class=" language-bash"><code class="language-bash">$ hexo n <span class="token punctuation">[</span>layout_name<span class="token punctuation">]</span> draft1</code></pre><p>这样就创建了一个使用特定布局的名为draft1的文章。</p><p>打开创建的text1.md文件，我们可以看到文章开头包含以下内容：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token operator">--</span><span class="token operator">-</span>title<span class="token punctuation">:</span> text1author<span class="token punctuation">:</span> silverCorriodsdate<span class="token punctuation">:</span> <span class="token number">2022</span><span class="token operator">-</span><span class="token number">06</span><span class="token operator">-</span><span class="token number">21</span> <span class="token number">14</span><span class="token punctuation">:</span><span class="token number">13</span><span class="token punctuation">:</span><span class="token number">36</span>tags<span class="token punctuation">:</span> hexocategories<span class="token punctuation">:</span> blog<span class="token operator">--</span><span class="token operator">-</span></code></pre><p>上面的内容在hexo被称作<strong>Front-matter，实际上就是该文章的一些变量，用于实现一些特定的功能</strong>。例如<code>tags</code>与<code>categories</code>，渲染后的文章会添加相应的标签和分类。</p><p>如何自定义布局呢？实际上，布局是一个markdown文件，它们保存在<code>scaffolds/</code>目录下，可以看到hexo自带的三种布局其实就是三个<code>.md</code>文件：</p><h2 id="2、给文章添加分类和标签"><a href="#2、给文章添加分类和标签" class="headerlink" title="2、给文章添加分类和标签"></a>2、给文章添加分类和标签</h2><p>在<code>.md</code>文件中设置<code>tags</code>与<code>categories</code>，渲染后的文章会添加相应的标签和分类。</p><p><img src="/2022/06/22/hexo01/image-20220622185517433-16562188823113.png" alt="image-20220622185517433"></p><h2 id="3、启动服务器，本地测试"><a href="#3、启动服务器，本地测试" class="headerlink" title="3、启动服务器，本地测试"></a>3、启动服务器，本地测试</h2><pre class=" language-bash"><code class="language-bash"><span class="token variable">$hexo</span> s</code></pre><p>如图：</p><p><img src="/2022/06/22/hexo01/image-20220622185628911-16562169191001.png" alt="image-20220622185628911-16562169191001"></p><h2 id="4、添加“阅读全文”按钮"><a href="#4、添加“阅读全文”按钮" class="headerlink" title="4、添加“阅读全文”按钮"></a>4、添加“阅读全文”按钮</h2><h5 id="方法一：在文章任意你想添加的位置添加即可"><a href="#方法一：在文章任意你想添加的位置添加即可" class="headerlink" title="方法一：在文章任意你想添加的位置添加即可"></a>方法一：在文章任意你想添加的位置添加即可</h5><pre class=" language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>more<span class="token operator">--</span><span class="token operator">></span>        </code></pre><p>例如：<br>在这里.md里面的内容是：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token operator">--</span><span class="token operator">-</span>title<span class="token punctuation">:</span> 在这里date<span class="token punctuation">:</span> <span class="token number">2018</span><span class="token operator">-</span><span class="token number">08</span><span class="token operator">-</span><span class="token number">02</span> <span class="token number">11</span><span class="token punctuation">:</span><span class="token number">41</span><span class="token punctuation">:</span><span class="token number">10</span>tags<span class="token punctuation">:</span><span class="token operator">-</span> 博客<span class="token operator">-</span> hexocategories<span class="token punctuation">:</span> web前端<span class="token operator">--</span><span class="token operator">-</span>javascript是一门充满活力、简单易用的语言，又是一门具有许多复杂微妙技术的语言。即使是经验丰富的javascript开发者，如果没有认真学习的话，也无法真正理解它们，这就是javascript的矛盾之处。由于javascript不必理解就可以使用，因此通常来说很难真正理解语言本身，这就是我们面临的挑战。不满足于只是让代码正常工作，而是想要弄清楚为什么，勇于挑战这条崎岖颠簸的少有人走的路，拥抱整个javascript<span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>more<span class="token operator">--</span><span class="token operator">></span>后面的内容在首页不显示，只显示到<span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>more<span class="token operator">--</span><span class="token operator">></span>这里</code></pre><p>效果示例：</p><p><img src="/2022/06/22/hexo01/image-20220622185851114.png" alt="image-20220622185851114"></p><h5 id="方法二：设置首页文章以摘要形式显示，打开主题配置文件，找到auto-excerpt进行修改："><a href="#方法二：设置首页文章以摘要形式显示，打开主题配置文件，找到auto-excerpt进行修改：" class="headerlink" title="方法二：设置首页文章以摘要形式显示，打开主题配置文件，找到auto_excerpt进行修改："></a>方法二：设置首页文章以摘要形式显示，打开主题配置文件，找到auto_excerpt进行修改：</h5><pre class=" language-json"><code class="language-json">  auto_excerpt<span class="token operator">:</span>  enable<span class="token operator">:</span> <span class="token boolean">true</span>  length<span class="token operator">:</span> <span class="token number">150</span></code></pre><p>其中length代表显示摘要的截取字符长度。<br>注：这两种方法，在博客首页显示的效果不一样，根据自己的需要，选择自己喜欢的方法</p><h2 id="5、在博文中添加图片"><a href="#5、在博文中添加图片" class="headerlink" title="5、在博文中添加图片"></a>5、在博文中添加图片</h2><h5 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h5><p>(1)在hexo目录下，安装插件：</p><pre class=" language-nginx"><code class="language-nginx">npm install hexo<span class="token operator">-</span>asset<span class="token operator">-</span>image <span class="token operator">--</span>save</code></pre><p>(2)在hexo\source 目录下新建一个img文件夹，把图片放置在里面；<br>(3)在xxx.md文件中引用图片：</p><pre class=" language-markdown"><code class="language-markdown">![header]( img/header.jpg)</code></pre><h5 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h5><p>(1)在全局配置文件（hexo/_config.yml)中将post_asset_folder设置为true；<br>(2)创建文章（在创建的时候，会在hexo/source/_post目录下，生成一个XXX.md文件和一个同名的文件夹）：</p><pre><code>hexo new "XXX"</code></pre><p><img src="/2022/06/22/hexo01/image-20220622190357066.png" alt="image-20220622190357066"></p><p>(3)把XXX这个博文需要展示的图片放在XXX文件夹目录下；<br>(4)在XXX.md文件中引入图片的方式：</p><pre class=" language-markdown"><code class="language-markdown">{% asset_img example.jpg This is an example image %}</code></pre><h4 id="6、发布到Github上"><a href="#6、发布到Github上" class="headerlink" title="6、发布到Github上"></a>6、发布到Github上</h4><p>（1）发表的文章在本地预览无误后，在 Git Bash 命令窗口执行以下命令：</p><pre class=" language-bash"><code class="language-bash"><span class="token variable">$hexo</span> clean <span class="token variable">$hexo</span> g <span class="token variable">$hexo</span> d</code></pre><p>（2）在浏览器，访问自己的博客域名，即可看到刚 发布的文章</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 写作 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
