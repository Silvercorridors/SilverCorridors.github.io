<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>多线程学习日记02：线程池</title>
      <link href="/2022/06/28/multithread02/"/>
      <url>/2022/06/28/multithread02/</url>
      
        <content type="html"><![CDATA[<h1 id="线程池（Thread-Pool）"><a href="#线程池（Thread-Pool）" class="headerlink" title="线程池（Thread Pool）"></a>线程池（Thread Pool）</h1><p>线程池（Thread Pool）是一种基于池化思想管理线程的工具。线程过多会带来额外的开销，其中包括创建<strong>销毁线程的开销、调度线程的开销</strong>等等，同时也降低了计算机的整体性能。线程池维护多个线程，等待监督管理者分配可并发执行的任务。这种做法，一方面避免了处理任务时创建销毁线程开销的代价，另一方面避免了线程数量膨胀导致的过分调度问题，保证了对内核的充分利用。</p><h2 id="一、Java中常用的四种线程池"><a href="#一、Java中常用的四种线程池" class="headerlink" title="一、Java中常用的四种线程池"></a>一、Java中常用的四种线程池</h2><p>在Java中使用线程池，可以用ThreadPoolExecutor的构造函数直接创建出线程池实例。不过，在Executors类中，为我们提供了常用线程池的创建方法。接下来我们就来了解常用的四种：<strong>newFixedThreadPool</strong>、<strong>newCachedThreadPool</strong>、<strong>newScheduledThreadPool</strong>、<strong>newSingleThreadExecutor</strong></p><h3 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h3><p>创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。创建方法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token keyword">int</span> nThreads<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>nThreads<span class="token punctuation">,</span> nThreads<span class="token punctuation">,</span>                                      0L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span>                                      <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>从构造方法可以看出，它创建了一个固定大小的线程池，每次提交一个任务就创建一个线程，直到线程达到线程池的最大值<code>nThreads</code>。线程池的大小一旦达到最大值后，再有新的任务提交时则放入**<a href="https://blog.csdn.net/u022812849/article/details/114698692">无界阻塞队列</a>**中，等到有线程空闲时，再从队列中取出任务继续执行。<br>如何使用<code>newFixedThreadPool</code>？示例代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> test<span class="token punctuation">;</span>  <span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ExecutorService<span class="token punctuation">;</span>  <span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>Executors<span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadPoolExecutorTest</span> <span class="token punctuation">{</span>      <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>          ExecutorService fixedThreadPool <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">12</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                 <span class="token keyword">final</span> <span class="token keyword">int</span> index <span class="token operator">=</span> i<span class="token punctuation">;</span>                 fixedThreadPool<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                       <span class="token keyword">try</span> <span class="token punctuation">{</span>                            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>                            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token punctuation">}</span>                  <span class="token punctuation">}</span>                 <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>       <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  </code></pre><p>线程池大小为3，每个任务输出index后sleep 3秒，所以每三秒打印3个数字。<br>定长线程池的大小最好根据系统资源进行设置。如Runtime.getRuntime().availableProcessors()</p><h3 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h3><p>看一下这种线程池的创建方法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">,</span>                                      60L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>                                      <span class="token keyword">new</span> <span class="token class-name">SynchronousQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>从构造方法可以看出，它创建了一个可缓存的线程池。当有新的任务提交时，有空闲线程则直接处理任务，没有空闲线程则创建新的线程处理任务，队列中不储存任务。线程池不对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。如果线程空闲时间超过了60秒就会被回收。</p><h3 id="使用线程池可以带来一系列好处："><a href="#使用线程池可以带来一系列好处：" class="headerlink" title="使用线程池可以带来一系列好处："></a>使用线程池可以带来一系列好处：</h3><ul><li><strong>降低资源消耗</strong>：通过池化技术重复利用已创建的线程，降低线程创建和销毁造成的损耗。</li><li><strong>提高响应速度</strong>：任务到达时，无需等待线程创建即可立即执行。</li><li><strong>提高线程的可管理性</strong>：线程是稀缺资源，如果无限制创建，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性。使用线程池可以进行统一的分配、调优和监控。</li><li><strong>提供更多更强大的功能</strong>：线程池具备可拓展性，允许开发人员向其中增加更多的功能。比如延时定时线程池ScheduledThreadPoolExecutor，就允许任务延期执行或定期执行。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OneMoreStudy</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ExecutorService cachedThreadPool <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">final</span> <span class="token keyword">int</span> index <span class="token operator">=</span> i<span class="token punctuation">;</span>            cachedThreadPool<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token annotation punctuation">@Override</span>                    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">try</span> <span class="token punctuation">{</span>                        SimpleDateFormat sdf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"HH:mm:ss"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"运行时间: "</span> <span class="token operator">+</span> sdf<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>                        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        cachedThreadPool<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>因为这种线程有新的任务提交，就会创建新的线程（线程池中没有空闲线程时），不需要等待，所以提交的5个任务的运行时间是一样的，运行结果如下：</p><pre class=" language-java"><code class="language-java">运行时间<span class="token operator">:</span> <span class="token number">08</span><span class="token operator">:</span><span class="token number">45</span><span class="token operator">:</span><span class="token number">18</span> <span class="token number">2</span>运行时间<span class="token operator">:</span> <span class="token number">08</span><span class="token operator">:</span><span class="token number">45</span><span class="token operator">:</span><span class="token number">18</span> <span class="token number">1</span>运行时间<span class="token operator">:</span> <span class="token number">08</span><span class="token operator">:</span><span class="token number">45</span><span class="token operator">:</span><span class="token number">18</span> <span class="token number">3</span>运行时间<span class="token operator">:</span> <span class="token number">08</span><span class="token operator">:</span><span class="token number">45</span><span class="token operator">:</span><span class="token number">18</span> <span class="token number">4</span>运行时间<span class="token operator">:</span> <span class="token number">08</span><span class="token operator">:</span><span class="token number">45</span><span class="token operator">:</span><span class="token number">18</span> <span class="token number">0</span></code></pre><h3 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h3><p>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。看一下这种线程池的创建方法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FinalizableDelegatedExecutorService</span>            <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span>                                    0L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span>                                    <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>从构造方法可以看出，它创建了一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序执行。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OneMoreStudy</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ExecutorService singleThreadExecutor <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> <span class="token keyword">int</span> index <span class="token operator">=</span> i<span class="token punctuation">;</span>        singleThreadExecutor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">try</span> <span class="token punctuation">{</span>                        SimpleDateFormat sdf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"HH:mm:ss"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"运行时间: "</span> <span class="token operator">+</span> sdf<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>                        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        singleThreadExecutor<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>因为该线程池类似于单线程执行，所以先执行完前一个任务后，再顺序执行下一个任务，<br>运行结果如下：</p><pre class=" language-java"><code class="language-java">运行时间<span class="token operator">:</span> <span class="token number">08</span><span class="token operator">:</span><span class="token number">54</span><span class="token operator">:</span><span class="token number">17</span> <span class="token number">0</span>运行时间<span class="token operator">:</span> <span class="token number">08</span><span class="token operator">:</span><span class="token number">54</span><span class="token operator">:</span><span class="token number">19</span> <span class="token number">1</span>运行时间<span class="token operator">:</span> <span class="token number">08</span><span class="token operator">:</span><span class="token number">54</span><span class="token operator">:</span><span class="token number">21</span> <span class="token number">2</span>运行时间<span class="token operator">:</span> <span class="token number">08</span><span class="token operator">:</span><span class="token number">54</span><span class="token operator">:</span><span class="token number">23</span> <span class="token number">3</span>运行时间<span class="token operator">:</span> <span class="token number">08</span><span class="token operator">:</span><span class="token number">54</span><span class="token operator">:</span><span class="token number">25</span> <span class="token number">4</span></code></pre><p>既然类似于单线程执行，那么这种线程池还有存在的必要吗？这里的单线程执行指的是线程池内部，从线程池外的角度看，主线程在提交任务到线程池时并没有阻塞，仍然是异步的。</p><h3 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h3><p>这个方法创建了一个固定大小的线程池，支持定时及周期性任务执行。<br>首先看一下定时执行的例子：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OneMoreStudy</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> SimpleDateFormat sdf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"HH:mm:ss"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ScheduledExecutorService scheduledThreadPool <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newScheduledThreadPool</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"提交时间: "</span> <span class="token operator">+</span> sdf<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        scheduledThreadPool<span class="token punctuation">.</span><span class="token function">schedule</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"运行时间: "</span> <span class="token operator">+</span> sdf<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>        scheduledThreadPool<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>使用该线程池的<code>schedule</code>方法，延迟3秒钟后执行任务，运行结果如下：</p><pre class=" language-java"><code class="language-java">提交时间<span class="token operator">:</span> <span class="token number">09</span><span class="token operator">:</span><span class="token number">11</span><span class="token operator">:</span><span class="token number">39</span>运行时间<span class="token operator">:</span> <span class="token number">09</span><span class="token operator">:</span><span class="token number">11</span><span class="token operator">:</span><span class="token number">42</span></code></pre><p>定期执行示例代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadPoolExecutorTest</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>      ScheduledExecutorService scheduledThreadPool <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newScheduledThreadPool</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      scheduledThreadPool<span class="token punctuation">.</span><span class="token function">scheduleAtFixedRate</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"delay 1 seconds, and excute every 3 seconds"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>  <span class="token punctuation">}</span></code></pre><p>表示延迟1秒后每3秒执行一次。</p><h2 id="二、线程池总体设计"><a href="#二、线程池总体设计" class="headerlink" title="二、线程池总体设计"></a>二、线程池总体设计</h2><p>Java中的线程池核心实现类是ThreadPoolExecutor。我们首先来看一下ThreadPoolExecutor的UML类图，了解下ThreadPoolExecutor的继承关系。</p><p><img src="/2022/06/28/multithread02/912883e51327e0c7a9d753d11896326511272.png" alt="图1 ThreadPoolExecutor UML类图"></p><p>ThreadPoolExecutor实现的顶层接口是Executor，顶层接口Executor提供了一种思想：将任务提交和任务执行进行解耦。用户无需关注如何创建线程，如何调度线程来执行任务，用户只需提供Runnable对象，将任务的运行逻辑提交到执行器(Executor)中，<strong>由Executor框架完成线程的调配和任务</strong>的执行部分。</p><p>ExecutorService接口增加了一些能力：（1）扩充执行任务的能力，补充可以为一个或一批异步任务生成Future的方法；（2）提供了管控线程池的方法，比如停止线程池的运行。</p><p>AbstractExecutorService则是上层的抽象类，将执行任务的流程串联了起来，保证下层的实现只需关注一个执行任务的方法即可。</p><p>最下层的实现类ThreadPoolExecutor实现最复杂的运行部分，ThreadPoolExecutor将会一方面维护自身的生命周期，另一方面同时管理线程和任务，使两者良好的结合从而执行并行任务。</p><h4 id="ThreadPoolExecutor运行机制"><a href="#ThreadPoolExecutor运行机制" class="headerlink" title="ThreadPoolExecutor运行机制"></a>ThreadPoolExecutor运行机制</h4><p><img src="/77441586f6b312a54264e3fcf5eebe2663494.png" alt="图2 ThreadPoolExecutor运行流程"></p><p>线程池在内部实际上构建了一个生产者消费者模型，<font color="red">将线程和任务两者解耦，并不直接关联，</font>从而良好的缓冲任务，复用线程。线程池的运行主要分成两部分：<strong>任务管理、线程管理</strong>。任务管理部分充当生产者的角色，当任务提交后，线程池会判断该任务后续的流转：</p><p>（1）直接申请线程执行该任务；</p><p>（2）缓冲到队列中等待线程执行；</p><p>（3）拒绝该任务。</p><p>线程管理部分是消费者，它们被统一维护在线程池内，根据任务请求进行线程的分配，当线程执行完任务后则会继续获取新的任务去执行，最终当线程获取不到任务的时候，线程就会被回收。</p><p>接下来，我们会按照以下三个部分去详细讲解线程池运行机制：</p><ol><li>线程池如何维护自身状态。</li><li>线程池如何管理任务。</li><li>线程池如何管理线程。</li></ol><h4 id="未完待耕"><a href="#未完待耕" class="headerlink" title="未完待耕~~~"></a>未完待耕~~~</h4><h2 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h2><p><a href="https://www.cnblogs.com/heihaozi/p/11741735.html">https://www.cnblogs.com/heihaozi/p/11741735.html</a></p><p><a href="https://blog.csdn.net/u012426959/article/details/78795784">https://blog.csdn.net/u012426959/article/details/78795784</a></p><p><a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html</a></p><end></end>]]></content>
      
      
      <categories>
          
          <category> java多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gecco学习日记02</title>
      <link href="/2022/06/28/gecco02/"/>
      <url>/2022/06/28/gecco02/</url>
      
        <content type="html"><![CDATA[<h1 id="Gecco学习日记02：梳理-与-分析"><a href="#Gecco学习日记02：梳理-与-分析" class="headerlink" title="Gecco学习日记02：梳理 与 分析"></a>Gecco学习日记02：梳理 与 分析</h1><p>Gecco的目标是提供一个完善的主题爬虫框架，简化下载和内容抽取的开发，利用<strong>管道过滤器</strong>模式，提供灵活的<strong>内容清洗</strong>和<strong>持久化处理</strong>模式，让开发人员把更多的精力投入到与业务主题相关的内容处理上。</p><h2 id="Gecco引擎初始化梳理"><a href="#Gecco引擎初始化梳理" class="headerlink" title="Gecco引擎初始化梳理"></a>Gecco引擎初始化梳理</h2><p>GeccoEngine是一个线程类，其中包含一些关键类有：</p><p>状态性的——</p><blockquote><p>请求队列：Scheduler，装着请求对象的队列<br>请求类：Request，代表一个应该进行的请求，存放在请求队列中，多个爬虫对象并发地从队列中取得请求对象，根据之发起HTTP请求<br>响应类：Response，将爬虫对象发起HTTP请求后获得的结果，封装成响应对象，由Render转换成实体对象</p></blockquote><p>行为性的——</p><blockquote><p>引擎类：Engine，总的配置和入口<br>爬虫类：Spider，一个引擎可以有多个爬虫对象并发工作，每个爬虫对象有一个单独的线程，爬虫的线程主循环中，从请求队列中获得请求对象，交给下载器<br>下载器：Downloader，用于根据一个请求对象，发起一次HTTP请求，将HTTP响应封装成响应对象<br>转换器：Render，用于将响应对象转换成用户定义的实体类的对象，实现方式是通过反射读取实体类的字段上的注解并处理</p></blockquote><p>对其运行过程进行流程梳理。</p><ol><li>首先GeccoEngine进行一系列初始化（scheduler、spiderBeanFactory、startRequests、spiders）。</li><li>scheduler将需要下载的请求都放在这里管理，可以认为这里是一个队列，保存了所有待抓取的请求。</li><li>每个爬虫(Spider)可以认为是一个单独线程，在每个爬虫对象线程的主循环中，爬虫会从Scheduler中获取需要待抓取的请求对象，由下载器进行下载。爬虫的任务就是下载网页并渲染相应的JavaBean。</li><li>下载器(Downloader)，使用请求对象(startRequests)，发起HTTP请求，把HTTP响应封装成响应对象</li><li>转换器，使用响应对象，及实体类上的注解信息，将响应对象渲染成有业务意义的实体对象</li><li>在爬取信息过程中，GeccoEngine会监控爬虫的基本信息，并导出jmx信息</li></ol><h2 id="GeccoEngine基本配置项"><a href="#GeccoEngine基本配置项" class="headerlink" title="GeccoEngine基本配置项"></a>GeccoEngine基本配置项</h2><ul><li>loop(true)：表示是否循环抓取，默认为false</li><li>thread(2)：表示开启的爬虫线程数量，默认是1，需要注意的是线程数量要小于或者等于start请求的数量</li><li>interval(2000)：表示某个线程在抓取完成一个请求后的间隔时间，单位是毫秒，系统会在左右1秒时间内随机。如果为2000，系统会在1000～3000之间随机选取。</li><li>mobile(false)：表示使用移动端还是pc端的UserAgent。默认为false使用pc端的UserAgent。</li><li>debug(true)：是否开启debug模式，如果开启debug模式，会在控制台输出jsoup元素抽取的日志。</li><li>pipelineFactory(PipelineFactory)：自定义Pipeline工厂类</li><li>scheduler(Scheduler)：自定义请求队列管理器</li></ul><h2 id="非阻塞启动和阻塞启动"><a href="#非阻塞启动和阻塞启动" class="headerlink" title="非阻塞启动和阻塞启动"></a>非阻塞启动和阻塞启动</h2><ul><li>start()：非阻塞启动，GeccoEngine会单独启动线程运行，推荐以该方式运行。线程模型如下：</li></ul><p>Main Thread–&gt;GeccoEngine Thread–&gt;Spider Thread</p><ul><li>run()：阻塞启动，GeccoEngine在主线程中启动运行，非循环模式GeccoEngine需要等待其他爬虫线程运行完毕后才会退出。线程模型r如下：</li></ul><p>Main Thread–&gt;Spider Thread</p><h2 id="Gecco如何匹配URL"><a href="#Gecco如何匹配URL" class="headerlink" title="Gecco如何匹配URL"></a>Gecco如何匹配URL</h2><ul><li><h4 id="匹配URL的作用"><a href="#匹配URL的作用" class="headerlink" title="匹配URL的作用"></a>匹配URL的作用</h4></li></ul><p>​匹配URL是告知Gecco，这种格式的url对应的网页会被渲染成当前的SpiderBean。</p><ul><li><h4 id="matchUrl如何写"><a href="#matchUrl如何写" class="headerlink" title="matchUrl如何写"></a>matchUrl如何写</h4></li></ul><p>​完全匹配：@Gecco(matchUrl=”<a href="https://github.com/&quot;">https://github.com/"</a>)</p><p>​模糊匹配：@Gecco(matchUrl=”<a href="https://github.com/%7Buser%7D/%7Bproject%7D&quot;)%EF%BC%8C%E4%BC%9A%E5%8C%B9%E9%85%8D%E6%89%80%E6%9C%89%E7%B1%BB%E4%BC%BC%E6%A0%BC%E5%BC%8F%E7%9A%84url%EF%BC%8C%E4%BE%8B%E5%A6%82[https://github.com/xtuhcy/gecco](https://github.com/xtuhcy/gecco)">https://github.com/{user}/{project}")，会匹配所有类似格式的url，例如[https://github.com/xtuhcy/gecco](https://github.com/xtuhcy/gecco)</a></p><p>​任意匹配：@Gecco，如果你不写matchUrl，任何格式的url都会被匹配，这种方式一般用作通用爬虫，例如：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Gecco</span><span class="token punctuation">(</span>pipelines<span class="token operator">=</span><span class="token string">"consolePipeline"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CommonCrawler</span> <span class="token keyword">implements</span> <span class="token class-name">HtmlBean</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token operator">-</span>8870768223740844229L<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Request</span>    <span class="token keyword">private</span> HttpRequest request<span class="token punctuation">;</span>    <span class="token annotation punctuation">@HtmlField</span><span class="token punctuation">(</span>cssPath<span class="token operator">=</span><span class="token string">"body"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> String body<span class="token punctuation">;</span>    <span class="token keyword">public</span> HttpRequest <span class="token function">getRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> request<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setRequest</span><span class="token punctuation">(</span>HttpRequest request<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>request <span class="token operator">=</span> request<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> body<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setBody</span><span class="token punctuation">(</span>String body<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>body <span class="token operator">=</span> body<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        GeccoEngine<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">classpath</span><span class="token punctuation">(</span><span class="token string">"com.geccocrawler.gecco.demo"</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token string">"https://www.baidu.com/"</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">interval</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Gecco </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gecco </tag>
            
            <tag> 网络爬虫 </tag>
            
            <tag> 开源项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gecco学习日记01</title>
      <link href="/2022/06/27/gecco01/"/>
      <url>/2022/06/27/gecco01/</url>
      
        <content type="html"><![CDATA[<h1 id="Gecco学习日记01：网络爬虫的定义与Gecco快速开始"><a href="#Gecco学习日记01：网络爬虫的定义与Gecco快速开始" class="headerlink" title="Gecco学习日记01：网络爬虫的定义与Gecco快速开始"></a>Gecco学习日记01：网络爬虫的定义与Gecco快速开始</h1><h2 id="什么是爬虫？"><a href="#什么是爬虫？" class="headerlink" title="什么是爬虫？"></a>什么是爬虫？</h2><p>WiKi中的定义：网络爬虫（英语：web crawler），也叫网络蜘蛛（spider），是一种用来自动浏览万维网的网络机器人。其目的一般为编纂<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E7%B4%A2%E5%BC%95">网络索引</a>。<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E">网络</a><a href="https://zh.wikipedia.org/wiki/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E">搜索引擎</a>等站点通过爬虫软件更新自身的<a href="https://zh.wikipedia.org/w/index.php?title=%E7%B6%B2%E7%AB%99%E5%85%A7%E5%AE%B9&amp;action=edit&amp;redlink=1">网站内容</a>或其对其他网站的索引。网络爬虫可以将自己所访问的页面保存下来，以便搜索引擎事后生成<a href="https://zh.wikipedia.org/w/index.php?title=%E7%B4%A2%E5%BC%95_(%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E)&amp;action=edit&amp;redlink=1">索引</a>供用户搜索。</p><p>通俗来讲，爬虫就是一个探测机器，它的基本操作就是模拟人的行为去各个网站溜达，点点按钮，查查数据，或者把看到的信息背回来。就像一只虫子在一幢楼里不知疲倦地爬来爬去。</p><p>由此我们可以知道，爬虫的应用领域有：搜索引擎、比价网站、舆情系统、知识信息储备。</p><h2 id="网络爬虫工作原理是什么？"><a href="#网络爬虫工作原理是什么？" class="headerlink" title="网络爬虫工作原理是什么？"></a><strong>网络爬虫工作原理是什么？</strong></h2><p>网络爬虫一般分为如下两个阶段：第一阶段，<strong>URL库初始化</strong>然后开始爬取；第二阶段，爬虫读取没有访问过的URL，来确定它的工作范围。对于所要抓取的URL，具体步骤如下：</p><ol><li>获取URL链接；</li><li>解析内容，获取URL相关数据；</li><li>存储有价值的数据；</li><li>对新抓取的RL进行规范化；</li><li>过滤掉不相关的URL；</li><li>将要抓取的URL更新到URL库中；</li><li>重复步骤2，直到终止条件为止。</li></ol><h2 id="爬虫实现策略包括哪些？"><a href="#爬虫实现策略包括哪些？" class="headerlink" title="爬虫实现策略包括哪些？"></a><strong>爬虫实现策略包括哪些？</strong></h2><ul><li>指定初始URL下载的选择策略</li><li>检测页面是否更新的重新访问策略</li><li>定义如何避免网站过度访问的约定性策略</li><li>如何部署分布式网络爬虫的并行策略</li></ul><p>网络爬虫主要爬取策略有：<strong>深度优先策略</strong>、<strong>宽度优先策略</strong>等等。</p><h2 id="一个典型的网络爬虫系统组成包括哪些？"><a href="#一个典型的网络爬虫系统组成包括哪些？" class="headerlink" title="一个典型的网络爬虫系统组成包括哪些？"></a><strong>一个典型的网络爬虫系统组成包括哪些？</strong></h2><p>网络爬虫本质是对网络资源的抓取、分析、过滤、存储。一个典型的网络爬虫系统组成主要有<strong>控制器，解析器，资源库</strong>三部分组成。</p><blockquote><p>控制器负责给多线程中的各个爬虫线程分配工作任务。</p><p>解析器的主要工作是下载网页，进行页面的处理。</p><p>资源库是用来存放下载到的网页资源，一般都采用大型的数据库存储，如Oracle数据库，并对其建立索引。</p></blockquote><h2 id="知己知彼：常用的反爬虫手段"><a href="#知己知彼：常用的反爬虫手段" class="headerlink" title="知己知彼：常用的反爬虫手段"></a>知己知彼：常用的反爬虫手段</h2><p>常见的反爬虫手段包括：统计IP访问限制、单个session访问量以及单个User-agent的访问，基于网站流量统计和日志分析反爬虫，通过Headers反爬虫，添加验证码限制等。</p><h2 id="介绍：什么是Gecco？"><a href="#介绍：什么是Gecco？" class="headerlink" title="介绍：什么是Gecco？"></a>介绍：什么是Gecco？</h2><p>Gecco 是一款基于 java 语言开发的轻量化的易用的网络爬虫。Gecco 整合了 jsoup、httpclient、fastjson、spring、htmlunit、redission 等优秀框架，让您只需要配置一些 jquery 风格的选择器就能很快的写出一个爬虫。</p><h3 id="Gecco主要特征"><a href="#Gecco主要特征" class="headerlink" title="Gecco主要特征"></a>Gecco主要特征</h3><ol><li>使用 jquery 风格的选择器抽取元素</li><li>支持爬取规则的动态配置和加载</li><li>支持页面中的异步 ajax 请求</li><li>支持页面中的 javascript 变量抽取</li><li>利用 Redis 实现分布式抓取</li><li>支持结合 Spring 开发业务逻辑</li><li>支持 htmlunit 扩展</li><li>支持插件扩展机制</li><li>支持下载时 UserAgent 随机选取</li><li>支持下载代理服务器随机选取</li></ol><h2 id="框架概述"><a href="#框架概述" class="headerlink" title="框架概述"></a>框架概述</h2><p><img src="/2022/06/27/gecco01/jiagou.jpg" alt="img"></p><h3 id="GeccoEngine"><a href="#GeccoEngine" class="headerlink" title="GeccoEngine"></a>GeccoEngine</h3><p>GeccoEngine 是爬虫引擎，每个爬虫引擎最好是一个独立进程，在分布式爬虫场景下，建议每台爬虫服务器（物理机或者虚机）运行一个 GeccoEngine。爬虫引擎包括 Scheduler、Downloader、Spider、SpiderBeanFactory、PipelineFactory 5 个主要模块。</p><h3 id="Scheduler（下载地址管理）"><a href="#Scheduler（下载地址管理）" class="headerlink" title="Scheduler（下载地址管理）"></a>Scheduler（下载地址管理）</h3><p>通常爬虫需要一个有效管理下载地址的角色，Scheduler 负责下载地址的管理。gecco 对初始地址的管理使用 StartScheduler，StartScheduler 内部采用一个<strong>阻塞的 FIFO 的队列</strong>。初始地址通常会派生出很多其他待抓取的地址，派生出来的其他地址采用 SpiderScheduler 进行管理，SpiderScheduler 内部采用<strong>线程安全的非阻塞 FIFO 队列</strong>。这种设计使的 gecco 对初始地址采用了深度遍历的策略，即一个线程抓取完一个初始地址后才会去抓取另外一个初始地址；对初始地址派生出来的地址，采用广度优先策略。</p><h3 id="Downloader（下载器）"><a href="#Downloader（下载器）" class="headerlink" title="Downloader（下载器）"></a>Downloader（下载器）</h3><p>Downloader 负责从 Scheduler 中获取需要下载的请求，gecco 默认采用 httpclient4.x 作为下载引擎。通过实现 Downloader 接口可以自定义自己的下载引擎。你也可以对每个请求定义 BeforeDownload 和 AfterDownload，实现不同的请求下载的个性需求。</p><h3 id="SpiderBeanFactory（爬虫工厂类：生成爬虫SpiderBean）"><a href="#SpiderBeanFactory（爬虫工厂类：生成爬虫SpiderBean）" class="headerlink" title="SpiderBeanFactory（爬虫工厂类：生成爬虫SpiderBean）"></a>SpiderBeanFactory（爬虫工厂类：生成爬虫SpiderBean）</h3><p>Gecco 将下载下来的内容渲染为 SpiderBean，所有爬虫渲染的 JavaBean 都统一继承 SpiderBean，SpiderBean 又分为 HtmlBean 和 JsonBean 分别对应 html 页面的渲染和 json 数据的渲染。<strong>SpiderBeanFactroy 会根据请求的 url 地址，匹配相应的 SpiderBean，同时生成该 SpiderBean 的上下文 SpiderBeanContext</strong>。上下文 SpiderBeanContext 会告知这个 SpiderBean 采用什么渲染器，采用那个下载器，渲染完成后采用哪些 pipeline 处理等相关上下文信息。</p><h3 id="PipelineFactory（管道工厂类）"><a href="#PipelineFactory（管道工厂类）" class="headerlink" title="PipelineFactory（管道工厂类）"></a>PipelineFactory（管道工厂类）</h3><p>pipeline 是 SpiderBean 渲染完成的后续业务处理单元，PipelineFactory 是 pipeline 的工厂类，负责 pipeline 实例化。通过扩展 PipelineFactory 就可以实现和 Spring 等业务处理框架的整合。</p><h3 id="Spider"><a href="#Spider" class="headerlink" title="Spider"></a>Spider</h3><p>Gecco 框架最核心的类应该是 <strong>Spider 线程</strong>，一个爬虫引擎可以同时运行多个 Spider 线程。Spider 描绘了这个框架运行的基本骨架，<font color="red">先从 Scheduler 获取请求，再通过 <strong>SpiderBeanFactory</strong> 匹配 SpiderBeanClass，再通过 SpiderBeanClass 找到 SpiderBean 的上下文，下载网页并对 SpiderBean 做渲染，将渲染后的 SpiderBean 交给 pipeline 处理。</font></p><h2 id="Maven导入jar包"><a href="#Maven导入jar包" class="headerlink" title="Maven导入jar包"></a>Maven导入jar包</h2><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.geccocrawler<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>gecco<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>x.x.x<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><h2 id="项目quick-start"><a href="#项目quick-start" class="headerlink" title="项目quick-start"></a>项目quick-start</h2><p>快速入门源码：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Gecco</span><span class="token punctuation">(</span>matchUrl<span class="token operator">=</span><span class="token string">"https://github.com/{user}/{project}"</span><span class="token punctuation">,</span>pipelines<span class="token operator">=</span><span class="token string">"consolePipeline"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyGithub</span> <span class="token keyword">implements</span> <span class="token class-name">HtmlBean</span> <span class="token punctuation">{</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token operator">-</span>7127412585200687225L<span class="token punctuation">;</span><span class="token annotation punctuation">@RequestParameter</span><span class="token punctuation">(</span><span class="token string">"user"</span><span class="token punctuation">)</span><span class="token keyword">private</span> String user<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//url中的{user}值</span><span class="token annotation punctuation">@RequestParameter</span><span class="token punctuation">(</span><span class="token string">"project"</span><span class="token punctuation">)</span><span class="token keyword">private</span> String project<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//url中的{project}值</span><span class="token annotation punctuation">@Text</span><span class="token annotation punctuation">@HtmlField</span><span class="token punctuation">(</span>cssPath<span class="token operator">=</span><span class="token string">".pagehead-actions li:nth-child(2) .social-count"</span><span class="token punctuation">)</span><span class="token keyword">private</span> String star<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//抽取页面中的star</span><span class="token annotation punctuation">@Text</span><span class="token annotation punctuation">@HtmlField</span><span class="token punctuation">(</span>cssPath<span class="token operator">=</span><span class="token string">".pagehead-actions li:nth-child(3) .social-count"</span><span class="token punctuation">)</span><span class="token keyword">private</span> String fork<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//抽取页面中的fork</span><span class="token annotation punctuation">@Html</span><span class="token annotation punctuation">@HtmlField</span><span class="token punctuation">(</span>cssPath<span class="token operator">=</span><span class="token string">".entry-content"</span><span class="token punctuation">)</span><span class="token keyword">private</span> String readme<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//抽取页面中的readme</span><span class="token keyword">public</span> String <span class="token function">getReadme</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> readme<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setReadme</span><span class="token punctuation">(</span>String readme<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>readme <span class="token operator">=</span> readme<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> String <span class="token function">getUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> user<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setUser</span><span class="token punctuation">(</span>String user<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>user <span class="token operator">=</span> user<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> String <span class="token function">getProject</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> project<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setProject</span><span class="token punctuation">(</span>String project<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>project <span class="token operator">=</span> project<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> String <span class="token function">getStar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> star<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setStar</span><span class="token punctuation">(</span>String star<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>star <span class="token operator">=</span> star<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> String <span class="token function">getFork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> fork<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setFork</span><span class="token punctuation">(</span>String fork<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>fork <span class="token operator">=</span> fork<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    GeccoEngine<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//工程的包路径</span>    <span class="token punctuation">.</span><span class="token function">classpath</span><span class="token punctuation">(</span><span class="token string">"com.geccocrawler.gecco.demo"</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//开始抓取的页面地址</span>    <span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token string">"https://github.com/xtuhcy/gecco"</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//开启几个爬虫线程</span>    <span class="token punctuation">.</span><span class="token function">thread</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//单个爬虫每次抓取完一个请求后的间隔时间</span>    <span class="token punctuation">.</span><span class="token function">interval</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//循环抓取</span>    <span class="token punctuation">.</span><span class="token function">loop</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//使用pc端userAgent</span>    <span class="token punctuation">.</span><span class="token function">mobile</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//非阻塞方式运行</span>    <span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h3><ul><li>接口HtmlBean说明该爬虫是一个解析html页面的爬虫（gecco还支持json格式的解析）</li><li>注解@Gecco告知该爬虫匹配的url格式(matchUrl)和内容抽取后的bean处理类（pipelines处理类采用管道过滤器模式，可以定义多个处理类）。</li><li>注解@RequestParameter可以注入url中的请求参数，如@RequestParameter(“user”)表示匹配url中的{user}</li><li>注解@HtmlField表示抽取html中的元素，cssPath采用类似jquery的css selector选取元素</li><li>注解@Text表示获取@HtmlField抽取出来的元素的text内容</li><li>注解@Html表示获取@HtmlField抽取出来的元素的html内容（如果不指定默认为@Html）</li><li>GeccoEngine表示爬虫引擎，通过create()初始化，通过start()/run()运行。可以配置一些启动参数如：扫描**@Gecco注解**的包名classpath；开始抓取的url地址star；抓取线程数thread；抓取完一个页面后的间隔时间interval(ms)等</li></ul><p><code>@Gecco</code>自定义注解</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Inherited</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">Gecco</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">/**    * 摒弃正则表达式的匹配方式，采用更容易理解的{value}方式    * 如：https://github.com/{user}/{project}    *     * @return url匹配规则    */</span>   String<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">matchUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">"*"</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/**    * url下载器，默认为httpClientDownloader    *     * @return 下载器    */</span>   String <span class="token function">downloader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">""</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/**    * 下载超时时间    *     * @return 下载超时时间    */</span>   <span class="token keyword">int</span> <span class="token function">timeout</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token number">3000</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/**    * bean渲染完成后，后续的管道过滤器    *     * @return 管道过滤器    */</span>   String<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">pipelines</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">""</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>伏笔</strong>：在启动quickstart之后，打印出了以下错误信息：</p><p><img src="/2022/06/27/gecco01/image-20220628175501708.png" alt="image-20220628175501708"></p><p>具体问题解决看下篇~</p><p>本篇结束</p><end></end>]]></content>
      
      
      <categories>
          
          <category> Gecco </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gecco </tag>
            
            <tag> 网络爬虫 </tag>
            
            <tag> 开源项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程学习日记01：进程、线程</title>
      <link href="/2022/06/26/multithread01/"/>
      <url>/2022/06/26/multithread01/</url>
      
        <content type="html"><![CDATA[<h1 id="进程、线程"><a href="#进程、线程" class="headerlink" title="进程、线程"></a>进程、线程</h1><h2 id="前言：程序是如何跑起来的"><a href="#前言：程序是如何跑起来的" class="headerlink" title="前言：程序是如何跑起来的"></a>前言：程序是如何跑起来的</h2><p>​通常来说，像我们苦逼码农写的软件都是文本格式的代码，这些代码不能直接被计算机识别执行，需要使用编译器<font color:red="">编译</font>成操作系统或者虚拟机可以运行的代码（可执行代码），它们都被存储在文件系统中。</p><p>​要想让程序处理数据，完成计算任务，必须把程序从外部设备加载到内存中，并在操作系统的管理调度下交给 CPU 去执行，去运行起来，才能真正发挥软件的作用，程序运行起来以后，被称作<strong>进程</strong>。</p><p>​进程除了包含可执行的程序代码，还包括进程在运行期使用的内存<strong>堆空间、栈空间</strong>、供操作系统管理用的数据结构。</p><h2 id="进程（process）"><a href="#进程（process）" class="headerlink" title="进程（process）"></a>进程（process）</h2><ul><li><p>程序在系统上的一次执行过程</p></li><li><p>每个进程有独立的<strong>地址空间</strong>，进程切换时需要切换进程页表，以及切换运行环境（寄存器等）</p></li></ul><h4 id="早期内存分配机制"><a href="#早期内存分配机制" class="headerlink" title="早期内存分配机制"></a>早期内存分配机制</h4><p>  ​在早期的计算机中，要运行一个程序，会把这些程序全都装入内存，程序都是直接运行在内存上的，也就是说<strong>程序中访问的内存地址都是实际的物理内存地址</strong>。当计算机同时运行多个程序时，必须保证这些程序用到的内存总量要小于计算机实际物理内存的大小。</p><p>  ​那当程序同时运行多个程序时，操作系统是如何为这些程序分配内存的呢？</p><blockquote><p>举个栗子，某台计算机总的内存大小是 128M ，现在同时运行两个程序 A 和 B ， A 需占用内存 10M ， B 需占用内存 110M 。计算机在给程序分配内存时会采取这样的方法：先将内存中的前 10M 分配给程序 A ，接着再从内存中剩余的 118M 中划分出 110M 分配给程序 B 。</p></blockquote><p><img src="/2022/06/26/multithread01/215125w5kywrxk0yhzw1mj.png" alt="image.png"></p><p>这种分配方法可以保证程序 A 和程序 B 都能运行，但是<strong>这种简单的内存分配策略问题很多</strong>。</p><p><strong>安全的问题</strong> ：进程地址空间不隔离。由于程序都是直接访问物理内存，所以恶意程序可以随意修改别的进程的内存数据，以达到破坏的目的。有些非恶意的，但是有 bug 的程序也可能不小心修改了其它程序的内存数据，就会导致其它程序的运行出现异常。</p><p><strong>效率的问题 <strong>：内存使用效率低。在 A 和 B 都运行的情况下，如果用户又运行了程序 C，而程序 C 需要 20M 大小的内存才能运行，而此时系统只剩下 8M 的空间可供使用，所以此时系统必须在已运行的程序中选择一个将该程序的数据暂时拷贝到硬盘上</strong>（知识点：外存硬盘属于I/O设备）</strong>，释放出部分空间来供程序 C 使用，然后再将程序 C 的数据全部装入内存中运行。可以想象得到，在这个过程中，有大量的数据在装入装出，导致效率十分低下。</p><p><strong>地址随机性的问题</strong>：程序运行的地址不确定。当内存中的剩余空间可以满足程序 C 的要求后，操作系统会在剩余空间中随机分配一段连续的 20M 大小的空间给程序 C 使用，因为是随机分配的，所以程序运行的地址是不确定的。</p><h4 id="内存分段机制"><a href="#内存分段机制" class="headerlink" title="内存分段机制"></a>内存分段机制</h4><p><strong>虚内存</strong>：内存地址不是真正的物理地址，而是一个<strong>虚拟地址</strong>（通过映射计算）。<strong>按照这种方法，程序中访问的内存地址不再是实际的物理内存地址，而是一个虚拟地址，然后由操作系统将这个虚拟地址映射到适当的物理内存地址上</strong>。只要操作系统处理好虚拟地址到物理内存地址的<strong>映射</strong>，就可以保证不同的程序最终访问的内存地址位于不同的区域，彼此没有重叠，就可以达到内存地址空间隔离的效果。</p><p>当创建一个进程时，操作系统会为该进程分配一个 4GB 大小的虚拟进程地址空间。之所以是 4GB ，是因为在 32 位的操作系统中，一个指针长度是 4 字节，而 4 字节指针的寻址能力是从<code> 0x00000000</code>~`0xFFFFFFFF<code>，最大值 </code>0xFFFFFFFF` 表示的即为 4GB 大小的容量。</p><p>当进程创建时，每个进程都会有一个自己的 4GB 虚拟地址空间。要注意的是这个 4GB 的地址空间是“虚拟”的，并不是真实存在的，而且每个进程只能访问自己虚拟地址空间中的数据，无法访问别的进程中的数据，通过这种方法实现了进程间的<strong>地址隔离</strong>。</p><p>再举个例子。</p><blockquote><p>假设有两个进程 A 和 B ，进程 A 所需内存大小为 10M ，其虚拟地址空间分布在 0x00000000 到 0x00A00000 ，进程 B 所需内存为 100M ，其虚拟地址空间分布为 0x00000000 到 0x06400000 。那么按照分段的映射方法，进程 A 在物理内存上映射区域为 0x00100000 到 0x00B00000 ，进程 B 在物理内存上映射区域为0x00C00000 到 0x07000000 。于是进程 A 和进程 B 分别被映射到了不同的内存区间，彼此互不重叠，实现了地址隔离。从应用程序的角度看来，进程 A 的地址空间就是分布在 0x00000000 到 0x00A00000 </p></blockquote><p>在 Windows 系统下，这个虚拟地址空间被分成了 4 部分： <strong>NULL 指针区、用户区、 64KB 禁入区、内核区</strong>。<strong>应用程序能使用的只是用户区而已</strong>，大约 2GB 左右 ( 最大可以调整到 3GB) 。内核区为 2GB ，内核区保存的是系统线程调度、内存管理、设备驱动等数据，这部分数据供所有的进程共享，但应用程序是不能直接访问的。</p><p>这种分段的映射方法虽然解决了上述中的安全问题和地址随机性的问题，但并没能解决内存的使用效率问题。在分段的映射方法中，每次换入换出内存的都是整个程序， 这样会造成大量的磁盘访问操作，导致效率低下。所以这种映射方法还是稍显粗糙，粒度比较大。基于此情况，人们想到了粒度更小的内存分割和映射方法，这种方法就是分页 (Paging) 。 </p><h4 id="内存分页机制"><a href="#内存分页机制" class="headerlink" title="内存分页机制"></a>内存分页机制</h4><p>分页的基本方法是，将地址空间分成许多的页。每页的大小由 CPU 决定，然后由操作系统选择页的大小。目前 Inter 系列的 CPU 支持 4KB 或 4MB 的页大小，而 PC上目前都选择使用 4KB 。按这种选择， 4GB 虚拟地址空间共可以分成 1048576（1024*1024） 页， 512M 的物理内存可以分为 131072 个页。显然<strong>虚拟空间的页数要比物理空间的页数多得多</strong>。</p><blockquote><p>例如：银行存钱，张三：存1号箱，李四：存1号箱，但是两个1号箱并不是同一个，有一个特殊的对应表来查询实际的物理位置</p></blockquote><p>在分段的方法中，每次程序运行时总是把程序全部装入内存，而分页的方法则有所不同。分页的思想是程序运行时用到哪页就为哪页分配内存，没用到的页暂时保留在硬盘上。当用到这些页时再在物理地址空间中为这些页分配内存，然后建立虚拟地址空间中的页和刚分配的物理内存页间的映射。</p><h2 id="线程（Thread）"><a href="#线程（Thread）" class="headerlink" title="线程（Thread）"></a>线程（Thread）</h2><ul><li><p>定义：<strong>进程真正的执行过程是线程</strong>，每个进程在创立时会缺省的创立一个主线程，当然，进程还可以创建更多的线程，所有的线程属于这个进程，进程销毁时，进程下所有线程也销毁，<strong>同一个进程</strong>里面 <strong>切换线程</strong>时 **<font color="red">不需要切换页表</font>**（节约时间），需要切换运行时环境（寄存器等）</p></li><li><p>线程一定属于进程</p></li><li><p>每个线程都有独立的运行时空间</p></li><li><p>同一个进程里面 切换线程时 不需要切换页表（节约时间），需要切换运行时环境（寄存器等）</p></li><li><p>一个进程多个线程并发</p></li></ul><h3 id="Java中的线程生命周期"><a href="#Java中的线程生命周期" class="headerlink" title="Java中的线程生命周期"></a>Java中的线程生命周期</h3><p>线程是一个动态执行的过程，它也有一个从产生到死亡的过程。Java中的线程生命周期大体可以分为五种状态：</p><h4 id="1、初始化状态（NEW）"><a href="#1、初始化状态（NEW）" class="headerlink" title="1、初始化状态（NEW）"></a>1、<strong>初始化状态（NEW）</strong></h4><ul><li>此时JVM为其分配内存，并初始化其成员变量的值；</li><li><strong>此时线程对象没有表现出任何线程的动态特征</strong>，程序也不会执行线程的线程执行体；</li></ul><h4 id="2、可运行-x2F-运行状态（RUNNABLE）"><a href="#2、可运行-x2F-运行状态（RUNNABLE）" class="headerlink" title="2、可运行/运行状态（RUNNABLE）"></a>2、<strong>可运行/运行状态（RUNNABLE）</strong></h4><p>线程对象调用了start()方法之后，该线程处于 <strong>就绪状态</strong>，此时JVM会为其<strong>创建方法调用栈和程序计数器</strong></p><p>该状态的线程一直处于 <strong>线程就绪队列</strong>（尽管是采用队列形式，事实上，<strong>把它称为可运行池而不是可运行队列</strong>。因为CPU的调度不一定是按照先进先出的顺序来调度的），线程并没有开始运行；</p><ul><li>此时线程 <strong>等待系统为其分配CPU时间片</strong>，并不是说执行了start()方法就立即执行；</li><li><strong>调用start()方法来启动线程，系统会把该run()方法当成线程执行体来处理</strong>。但如果直接调用线程对象的run()方法，则run()方法立即就会被执行，而且在run()方法返回之前其他线程无法并发执行。也就是说，<strong>系统把线程对象当成一个普通对象，而run()方法也是一个普通方法，而不是线程执行体</strong>；</li><li>需要指出的是，调用了线程的run()方法之后，<strong>该线程已经不再处于新建状态</strong>，不要再次调用线程对象的start()方法。<strong>只能对处于新建状态的线程调用start()方法，否则将引发IllegaIThreadStateExccption异常</strong>；</li></ul><h4 id="3、运行状态（RUNNING）"><a href="#3、运行状态（RUNNING）" class="headerlink" title="3、运行状态（RUNNING）"></a><font color="red"><strong>3、运行状态（RUNNING）</strong></font></h4><p>当CPU开始调度处于 <strong>就绪状态</strong> 的线程时，此时线程获得了CPU时间片才得以真正开始执行run()方法的线程执行体，则该线程处于 <strong>运行状态</strong>。</p><ol><li>如果计算机只有一个CPU，那么在任何时刻只有一个线程处于运行状态；</li><li>如果在一个多处理器的机器上，将会有多个线程并行执行，处于运行状态；</li><li>当线程数大于处理器数时，依然会存在多个线程在同一个CPU上轮换的现象；</li></ol><p>线程<strong>不可能一直处于运行状态</strong>，其在运行过程中需要被中断，<strong>目的是使其他线程获得执行的机会，线程调度的细节取决于底层平台所采用的策略</strong>(抢占式or协作式)。</p><h4 id="4、阻塞状态（BLOCKED）"><a href="#4、阻塞状态（BLOCKED）" class="headerlink" title="4、阻塞状态（BLOCKED）"></a><font color="red"><strong>4、阻塞状态（BLOCKED）</strong></font></h4><p>处于运行状态的线程在某些情况下，让出CPU并暂时停止自己的运行，进入 <strong>阻塞状态</strong>。</p><p><strong>当发生如下情况时，线程将会进入阻塞状态：</strong></p><blockquote><ol><li><strong>线程调用sleep()方法</strong>，主动放弃所占用的处理器资源，暂时进入中断状态（<strong>不会释放持有的对象锁</strong>），时间到后等待系统分配CPU继续执行；</li><li><strong>线程调用一个阻塞式IO方法</strong>，在该方法返回之前，该线程被阻塞；</li><li><strong>线程试图获得一个同步监视器</strong>，但该同步监视器正被其他线程所持有;</li><li><strong>程序调用了线程的suspend方法将线程挂起</strong>；</li><li><strong>线程调用wait</strong>，等待notify/notifyAll唤醒时(会释放持有的对象锁)；</li></ol></blockquote><p><strong>阻塞状态分类：</strong></p><blockquote><ol><li><strong>等待阻塞</strong>：运行状态中的 <strong>线程执行wait()方法</strong>，使本线程进入到等待阻塞状态；</li><li><strong>同步阻塞</strong>：线程在 <strong>获取synchronized同步锁失败</strong>（因为锁被其它线程占用），它会进入到同步阻塞状态；</li><li><strong>其他阻塞</strong>：通过调用线程的 <strong>sleep()或join()或发出I/O请求</strong> 时，线程会进入到阻塞状态。当 <strong>sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕</strong> 时，线程重新转入就绪状态；</li></ol></blockquote><p><strong>在阻塞状态的线程只能进入就绪状态，无法直接进入运行状态</strong>。而就绪和运行状态之间的转换通常不受程序控制，<strong>而是由系统线程调度所决定</strong>。当处于就绪状态的线程获得处理器资源时，该线程进入运行状态；<strong>当处于运行状态的线程失去处理器资源时，该线程进入就绪状态</strong>。</p><blockquote><p>但有一个方法例外，<strong>调用yield()方法可以让运行状态的线程转入就绪状态</strong>。</p></blockquote><h5 id="等待状态分类：无限制等待状态（WAITING）、时限等待状态（TIMED-WAITING）"><a href="#等待状态分类：无限制等待状态（WAITING）、时限等待状态（TIMED-WAITING）" class="headerlink" title="等待状态分类：无限制等待状态（WAITING）、时限等待状态（TIMED_WAITING）"></a>等待状态分类：无限制等待状态（WAITING）、时限等待状态（TIMED_WAITING）</h5><p>当线程进入了一个 <strong>时限等待状态</strong>，如：</p><blockquote><p>**sleep(3000)**，等待3秒后线程重新进行 <strong>就绪（RUNNABLE）状态</strong> 继续运行。</p></blockquote><h4 id="5、终止状态（TERMINATED）"><a href="#5、终止状态（TERMINATED）" class="headerlink" title="5、终止状态（TERMINATED）"></a><strong>5、终止状态（TERMINATED）</strong></h4><p>线程会以如下3种方式结束，结束后就处于 <strong>死亡状态</strong>：</p><blockquote><ol><li><strong>run()或call()方法执行完成</strong>，线程正常结束；</li><li><strong>线程抛出一个未捕获的Exception或Error</strong>；</li><li><strong>直接调用该线程stop()方法来结束该线程</strong>—该方法容易导致死锁，通常不推荐使用；</li></ol></blockquote><p><strong>处于死亡状态的线程对象也许是活的，但是，它已经不是一个单独执行的线程</strong>。线程一旦死亡，就不能复生。 <strong>如果在一个死去的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常</strong>。</p><p><strong>所以，需要注意的是：</strong></p><blockquote><p>一旦线程通过start()方法启动后就再也不能回到新建（NEW）状态，线程终止后也不能再回到就绪（RUNNABLE）状态。</p></blockquote><p><strong>需要重点理解的是：虽然Java语言中线程的状态比较多，但是，其实<font color="red">在操作系统层面，Java线程中的阻塞状态（BLOCKED）、无时限等待状态（WAITING）、有时限等待状态（TIMED_WAITING）都是一种状态，即通用线程生命周期中的休眠状态。</font>也就是说，只要Java中的线程处于这三种状态时，那么，这个线程就没有CPU的使用权。</strong></p><p>下面的图表示Java中线程的生命周期。</p><p><img src="/2022/06/26/multithread01/ThreadLife.png" alt="image.png"></p><h2 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h2><p><strong><a href="https://juejin.cn/post/6844903558433734669">https://juejin.cn/post/6844903558433734669</a></strong></p><p><strong><a href="https://developer.huawei.com/consumer/cn/forum/topic/0202779877806640557?fid=0101592429757310384">https://developer.huawei.com/consumer/cn/forum/topic/0202779877806640557?fid=0101592429757310384</a></strong></p><end></end>]]></content>
      
      
      <categories>
          
          <category> java多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javaSE 面试题01</title>
      <link href="/2022/06/25/javasems01/"/>
      <url>/2022/06/25/javasems01/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-SE-面试题-01"><a href="#Java-SE-面试题-01" class="headerlink" title="Java SE 面试题 01"></a>Java SE 面试题 01</h1><p style="color:red;">    练习面试题需要将题目独立提取出来，以自问自答的形式反复练习。<br>    没有人能随随便便成功，加油吧，骚年！</p><h2 id="1-面向对象和面向过程的区别"><a href="#1-面向对象和面向过程的区别" class="headerlink" title="1. 面向对象和面向过程的区别"></a>1. 面向对象和面向过程的区别</h2><p><strong>面向过程：</strong> </p><p>优点：性能高，类的实例化是有较大开销的，且占用更多的内存，在注重性能的开发场合，例如单片机、嵌入式开发、Linux/Unix内核等场景中一般采用面向过程开发。</p><p>缺点：代码逻辑贴近机器逻辑，不易维护；不易复用；不易扩展。</p><p><strong>面向对象：</strong> </p><p>优点：易维护；易复用；易扩展；面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统。</p><p>缺点：性能比面向过程低，一般用于业务层、比如业务中间件。</p><h2 id="2-Java语言有哪些特点？"><a href="#2-Java语言有哪些特点？" class="headerlink" title="2. Java语言有哪些特点？"></a>2. Java语言有哪些特点？</h2><p>面向对象（封装，继承，多态）；</p><p>平台无关性（Java虚拟机实现平台无关性），编译与解释并存；</p><p>使用广泛，有很多可用的库</p><h2 id="3-什么是字节码？采用字节码的最大好处是什么？"><a href="#3-什么是字节码？采用字节码的最大好处是什么？" class="headerlink" title="3. 什么是字节码？采用字节码的最大好处是什么？"></a>3. 什么是字节码？采用字节码的最大好处是什么？</h2><p><strong>java中的编译器和解释器：</strong> </p><p>Java引入了虚拟机（JVM），即在机器和编译程序之间加入了一层抽象的虚拟的机器。</p><p>在不同的操作系统上，其实有不同的虚拟机，但是他们都提供给编译程序一个的共同的接口。编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。这种供虚拟机理解的代码叫做字节码（Java中是扩展名为.class的文件），它不面向任何特定的处理器，只面向虚拟机。</p><p>Java源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行，这就是上面提到的Java的特点的编译与解释并存。 </p><p>Java源代码—-&gt;编译器—-&gt;jvm可执行的Java字节码(即虚拟指令)—-&gt;jvm—-&gt;jvm中解释器—–&gt;机器可执行的二进制机器码—-&gt;程序运行。</p><p>JIT：Just In Time，虚拟机的一种优化手段，如果某个方法或者代码块频繁的被调用，虚拟机会把这段代码标记为“热点代码”，并将这段字节码一次性的编译为机器码，以提高运行效率。Java中的JIT是HotSpot。</p><p><strong>采用字节码的好处：</strong></p><p> Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。</p><h2 id="4-什么是JDK-什么是JRE？"><a href="#4-什么是JDK-什么是JRE？" class="headerlink" title="4. 什么是JDK? 什么是JRE？"></a>4. 什么是JDK? 什么是JRE？</h2><p>  JDK: 顾名思义它是给开发者提供的开发工具箱,是给程序开发者用的。它除了包括完整的JRE（Java Runtime Environment），Java运行环境，还包含了其他供开发者使用的工具包。</p><p>​        JDK中包括：</p><pre class=" language-markdown"><code class="language-markdown"><span class="token list punctuation">1.</span> javac：编译器<span class="token list punctuation">2.</span> java：运行工具<span class="token list punctuation">3.</span> jar：打包工具<span class="token list punctuation">4.</span> javadoc：文档生成器<span class="token list punctuation">5.</span> jdb debugger：调试工具</code></pre><p>  JRE:普通用户而只需要安装JRE（Java Runtime Environment）来 来运行Java程序。而程序开发者必须安装JDK来编译、调试程序。</p><h2 id="5-Java环境变量PATH和CLASSPATH"><a href="#5-Java环境变量PATH和CLASSPATH" class="headerlink" title="5. Java环境变量PATH和CLASSPATH"></a>5. Java环境变量PATH和CLASSPATH</h2><p><strong>PATH环境变量</strong>：</p><ol><li>设定%JAVA_HOME%，并将%JAVA_HOME%/bin加入到 PATH中</li><li>好处：可以在任何文件夹下调用javac, java 等工具。</li></ol><p><strong>CLASSPATH环境变量</strong></p><ol><li>java在运行字节码时，需要通过-classpath指定java类的所在位置，否则会报无法加载主类的错误</li><li>设定%CLASSPATH%后，可以使用这个变量用于指定-classpath参数</li></ol><h2 id="6-字符型常量和字符串常量的区别"><a href="#6-字符型常量和字符串常量的区别" class="headerlink" title="6. 字符型常量和字符串常量的区别"></a>6. 字符型常量和字符串常量的区别</h2><ol><li>形式上：字符常量是单引号引起的一个字符 字符串常量是双引号引起的若干个字符</li><li>含义上：字符常量相当于一个整形值(ASCII值),可以参加表达式运算 字符串常量代表一个地址值(该字符串在内存中存放位置)</li><li>占内存大小：字符常量只占一个字节 字符串常量占若干个字节(java和C\C++不一样，字符串不需要\0结尾)。</li></ol><h2 id="7-Java语言采用何种编码方案？有何特点？"><a href="#7-Java语言采用何种编码方案？有何特点？" class="headerlink" title="7. Java语言采用何种编码方案？有何特点？"></a>7. Java语言采用何种编码方案？有何特点？</h2><p>  Java语言采用Unicode编码标准，每个字符两个字节</p><p>​这里说的编码是Java代码运行时在内存中的编码，不是*.java在文件中的编码。</p><h2 id="8-构造器Constructor是否可被override"><a href="#8-构造器Constructor是否可被override" class="headerlink" title="8. 构造器Constructor是否可被override"></a>8. 构造器Constructor是否可被override</h2><p>  在讲继承的时候我们就知道父类的私有属性和构造方法并不能被继承，所以Constructor也就不能被override（子类覆盖父类的同名方法）,但是可以overload（方法相同，但是参数不同）,所以你可以看到一个类中有多个构造函数的情况。</p><p><strong>override和overload的区别：</strong></p><p>override：发生在父子类中，方法名、参数列表必须相同，返回值小于等于父类，抛出的异常小于等于父类，访问修饰符大于等于父类；如果父类方法访问修饰符为private则子类中就不是重写。</p><p>overload：发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。</p><h2 id="9-java-面向对象编程三大特性"><a href="#9-java-面向对象编程三大特性" class="headerlink" title="9. java 面向对象编程三大特性"></a>9. java 面向对象编程三大特性</h2><p>封装：对象的属性或者方法，可以隐藏起来，禁止被外部访问</p><pre class=" language-markdown"><code class="language-markdown"><span class="token code keyword">    9. 封装：访问权限 protected friendly(什么都不写，default)</span><span class="token code keyword">                 当前类   派生类   同一个package里的类    不同package里的类</span><span class="token code keyword">        public    Yes     Yes            Yes              Yes</span><span class="token code keyword">        protected Yes     Yes            Yes               No</span><span class="token code keyword">        (default) Yes  看是否同一个package Yes               No</span><span class="token code keyword">        private   Yes     No             No                No</span></code></pre><p>继承：派生类可以使用基类的属性和方法（一般方法，构造方法），也可以定义自己的属性和方法</p><p>多态：动态绑定，决定调用基类的方法还是派生类的方法，由实例事实上是哪个类的实例来决定，而不是由引用的类型决定。</p><h2 id="10-java中equals方法的用法以及-x3D-x3D-的用法"><a href="#10-java中equals方法的用法以及-x3D-x3D-的用法" class="headerlink" title="10. java中equals方法的用法以及==的用法"></a>10. java中equals方法的用法以及==的用法</h2><p>“==”比较两个变量本身的值，即两个对象在内存中的首地址。</p><p>“equals()”比较字符串中所包含的内容是否相同。</p><p>主要适用于String，原始类型的包装类</p><pre class=" language-java"><code class="language-java">String s1<span class="token punctuation">,</span>s2<span class="token punctuation">,</span>s3 <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">,</span> s4 <span class="token operator">=</span><span class="token string">"abc"</span> <span class="token punctuation">;</span>s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>s2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>s1 == s2: false</p><p>s1.equals(s2): true</p><p>s3 == s4: true</p><p>s3.equals(s4): true</p><pre class=" language-java"><code class="language-java">String s1 <span class="token operator">=</span> <span class="token string">"123"</span><span class="token punctuation">;</span> String s2 <span class="token operator">=</span> <span class="token string">"123"</span><span class="token punctuation">;</span> String s3 <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">;</span> String s4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> String s5 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> String s6 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1 <span class="token operator">==</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//（1）true </span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//（2）true </span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1 <span class="token operator">==</span> s3<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//（3）flase </span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>s3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//（4）flase </span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s4 <span class="token operator">==</span> s5<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//（5）flase </span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s4<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>s5<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//（6）true </span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s4 <span class="token operator">==</span> s6<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//（7）flase </span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s4<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>s6<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//（8）flase </span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1 <span class="token operator">==</span> s4<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//（9）false </span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>s4<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//（10）true </span></code></pre><p>特例：如果某些类没有override equals方法，那么他们使用Object.equals，这个方法也是比较地址的。</p><pre class=" language-java"><code class="language-java">StringBuffer s5 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>StringBuffer s6 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>s5 == s6: false</p><p>s5.equals(s6): false</p><h2 id="11-String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的？"><a href="#11-String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的？" class="headerlink" title="11. String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的？"></a>11. String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的？</h2><p><strong>可变性</strong> </p><p>String类中使用字符数组保存字符串，private final char value[]，所以string对象是不可变的。StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，char[]value，这两种对象都是可变的。  </p><p><strong>线程安全性</strong></p><p>String中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder是StringBuilder与StringBuffer的公共父类，定义了一些字符串的基本操作，如expandCapacity、append、insert、indexOf等公共方法。StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。  </p><p><strong>性能</strong></p><p>每次对String 类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String 对象。StringBuffer每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用StirngBuilder 相比使用StringBuffer 仅能获得10%~15% 左右的性能提升，但却要冒多线程不安全的风险。 </p><p><strong>对于三者使用的总结：</strong> 如果要操作少量的数据用：String；单线程操作字符串缓冲区 下操作大量数据：StringBuilder；多线程操作字符串缓冲区 下操作大量数据：StringBuffer。</p><h2 id="12-自动装箱与拆箱"><a href="#12-自动装箱与拆箱" class="headerlink" title="12. 自动装箱与拆箱"></a>12. 自动装箱与拆箱</h2><p><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</p><p><strong>拆箱</strong>：将包装类型转换为基本数据类型；  </p><p>Java使用自动装箱和拆箱机制，节省了常用数值的内存开销和创建对象的开销，提高了效率，由编译器来完成，编译器会在编译期根据语法决定是否进行装箱和拆箱动作。</p><h2 id="13-说出这段代码的运行结果："><a href="#13-说出这段代码的运行结果：" class="headerlink" title="13. 说出这段代码的运行结果："></a>13. 说出这段代码的运行结果：</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">aClass</span> <span class="token punctuation">{</span>         <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">static</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                      i<span class="token operator">++</span><span class="token punctuation">;</span>              System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 分别打印输出1</span>        <span class="token punctuation">}</span>                <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              aClass obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">aClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              obj<span class="token punctuation">.</span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              obj<span class="token punctuation">.</span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><p>报错：注意，虽然C\C++这样写是对的，java中static不可以修饰局部变量。</p><h2 id="14-在一个静态方法内调用一个非静态成员为什么是非法的？"><a href="#14-在一个静态方法内调用一个非静态成员为什么是非法的？" class="headerlink" title="14. 在一个静态方法内调用一个非静态成员为什么是非法的？"></a>14. 在一个静态方法内调用一个非静态成员为什么是非法的？</h2><p>  由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。</p><h2 id="15-在Java中定义一个不做事且没有参数的构造方法的作用"><a href="#15-在Java中定义一个不做事且没有参数的构造方法的作用" class="headerlink" title="15. 在Java中定义一个不做事且没有参数的构造方法的作用"></a>15. 在Java中定义一个不做事且没有参数的构造方法的作用</h2><p>  Java程序在执行子类的构造方法之前，如果没有用super()来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用super()来调用父类中特定的构造方法，则编译时将发生错误，因为Java程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。</p><h2 id="16-接口和抽象类的区别是什么？"><a href="#16-接口和抽象类的区别是什么？" class="headerlink" title="16. 接口和抽象类的区别是什么？"></a>16. 接口和抽象类的区别是什么？</h2><ol><li><p>接口的方法默认是public，在JDK 7及以前，所有方法在接口中不能有实现，JDK 8 及以后接口中可以用default关键字实现方法，抽象类可以有非抽象的方法</p></li><li><p>接口中不能有变量，构造函数和static静态代码块，只能有常量 public static final，而抽象类没有限制</p></li><li><p>一个类可以实现多个接口，但最多只能实现一个抽象类</p></li><li><p>一个类实现接口的话要实现接口的所有方法，而抽象类不一定</p></li><li><p>从设计层面来说，抽象类是对类的抽象，是一种模板设计，接口是行为能力的抽象，是一种行为的规范。</p></li></ol><h2 id="17-成员变量与局部变量的区别有那些？"><a href="#17-成员变量与局部变量的区别有那些？" class="headerlink" title="17. 成员变量与局部变量的区别有那些？"></a>17. 成员变量与局部变量的区别有那些？</h2><ol><li><p>从语法形式上，看成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；成员变量可以被public,private,static等修饰符所修饰，而局部变量不能被访问控制修饰符及static所修饰；成员变量和局部变量都能被final所修饰；</p></li><li><p>从变量在内存中的存储方式来看，成员变量是对象的一部分，而对象存在于堆内存，局部变量存在于栈内存</p></li><li><p>从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。</p></li><li><p>成员变量如果没有被赋初值，则会自动以类型的默认值而赋值（一种情况例外被final修饰但没有被static修饰的成员变量必须显示地赋值）；而局部变量则不会自动赋值。</p></li></ol><h2 id="18-创建一个对象用什么运算符？对象实体与对象引用有何不同？"><a href="#18-创建一个对象用什么运算符？对象实体与对象引用有何不同？" class="headerlink" title="18. 创建一个对象用什么运算符？对象实体与对象引用有何不同？"></a>18. 创建一个对象用什么运算符？对象实体与对象引用有何不同？</h2><p>  new运算符，new创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。一个对象引用可以指向0个或1个对象;一个对象可以有n个引用指向它。</p>]]></content>
      
      
      <categories>
          
          <category> java面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo模板教程</title>
      <link href="/2022/06/22/hexo01/"/>
      <url>/2022/06/22/hexo01/</url>
      
        <content type="html"><![CDATA[<h2 id="1、新建文章"><a href="#1、新建文章" class="headerlink" title="1、新建文章"></a>1、新建文章</h2><blockquote><p>命令格式：</p><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token punctuation">[</span>layout<span class="token punctuation">]</span> <span class="token string">"title"</span> $ hexo n <span class="token punctuation">[</span>layout<span class="token punctuation">]</span> <span class="token string">"title"</span></code></pre></blockquote><p>创建文章前要先选定模板，在hexo中也叫做布局。hexo支持三种布局（layout）：post(默认)、draft、page。</p><p>我们先介绍如何使用已有布局，后面还将会介绍如何自定义布局。</p><p>在博客目录下输入以下命令时，会默认使用post布局，然后自动在<code>source\_posts</code>目录生成一个text1.md文件：</p><pre class=" language-bash"><code class="language-bash">$ hexo n text1</code></pre><p>也可以指定布局：</p><pre class=" language-bash"><code class="language-bash">$ hexo n <span class="token punctuation">[</span>layout_name<span class="token punctuation">]</span> draft1</code></pre><p>这样就创建了一个使用特定布局的名为draft1的文章。</p><p>打开创建的text1.md文件，我们可以看到文章开头包含以下内容：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token operator">--</span><span class="token operator">-</span>title<span class="token punctuation">:</span> text1author<span class="token punctuation">:</span> silverCorriodsdate<span class="token punctuation">:</span> <span class="token number">2022</span><span class="token operator">-</span><span class="token number">06</span><span class="token operator">-</span><span class="token number">21</span> <span class="token number">14</span><span class="token punctuation">:</span><span class="token number">13</span><span class="token punctuation">:</span><span class="token number">36</span>tags<span class="token punctuation">:</span> hexocategories<span class="token punctuation">:</span> blog<span class="token operator">--</span><span class="token operator">-</span></code></pre><p>上面的内容在hexo被称作<strong>Front-matter，实际上就是该文章的一些变量，用于实现一些特定的功能</strong>。例如<code>tags</code>与<code>categories</code>，渲染后的文章会添加相应的标签和分类。</p><p>如何自定义布局呢？实际上，布局是一个markdown文件，它们保存在<code>scaffolds/</code>目录下，可以看到hexo自带的三种布局其实就是三个<code>.md</code>文件：</p><h2 id="2、给文章添加分类和标签"><a href="#2、给文章添加分类和标签" class="headerlink" title="2、给文章添加分类和标签"></a>2、给文章添加分类和标签</h2><p>在<code>.md</code>文件中设置<code>tags</code>与<code>categories</code>，渲染后的文章会添加相应的标签和分类。</p><p><img src="/2022/06/22/hexo01/image-20220622185517433-16562188823113.png" alt="image-20220622185517433"></p><h2 id="3、启动服务器，本地测试"><a href="#3、启动服务器，本地测试" class="headerlink" title="3、启动服务器，本地测试"></a>3、启动服务器，本地测试</h2><pre class=" language-bash"><code class="language-bash"><span class="token variable">$hexo</span> s</code></pre><p>如图：</p><p><img src="/2022/06/22/hexo01/image-20220622185628911-16562169191001.png" alt="image-20220622185628911-16562169191001"></p><h2 id="4、添加“阅读全文”按钮"><a href="#4、添加“阅读全文”按钮" class="headerlink" title="4、添加“阅读全文”按钮"></a>4、添加“阅读全文”按钮</h2><h5 id="方法一：在文章任意你想添加的位置添加即可"><a href="#方法一：在文章任意你想添加的位置添加即可" class="headerlink" title="方法一：在文章任意你想添加的位置添加即可"></a>方法一：在文章任意你想添加的位置添加即可</h5><pre class=" language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>more<span class="token operator">--</span><span class="token operator">></span>        </code></pre><p>例如：<br>在这里.md里面的内容是：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token operator">--</span><span class="token operator">-</span>title<span class="token punctuation">:</span> 在这里date<span class="token punctuation">:</span> <span class="token number">2018</span><span class="token operator">-</span><span class="token number">08</span><span class="token operator">-</span><span class="token number">02</span> <span class="token number">11</span><span class="token punctuation">:</span><span class="token number">41</span><span class="token punctuation">:</span><span class="token number">10</span>tags<span class="token punctuation">:</span><span class="token operator">-</span> 博客<span class="token operator">-</span> hexocategories<span class="token punctuation">:</span> web前端<span class="token operator">--</span><span class="token operator">-</span>javascript是一门充满活力、简单易用的语言，又是一门具有许多复杂微妙技术的语言。即使是经验丰富的javascript开发者，如果没有认真学习的话，也无法真正理解它们，这就是javascript的矛盾之处。由于javascript不必理解就可以使用，因此通常来说很难真正理解语言本身，这就是我们面临的挑战。不满足于只是让代码正常工作，而是想要弄清楚为什么，勇于挑战这条崎岖颠簸的少有人走的路，拥抱整个javascript<span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>more<span class="token operator">--</span><span class="token operator">></span>后面的内容在首页不显示，只显示到<span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>more<span class="token operator">--</span><span class="token operator">></span>这里</code></pre><p>效果示例：</p><p><img src="/2022/06/22/hexo01/image-20220622185851114.png" alt="image-20220622185851114"></p><h5 id="方法二：设置首页文章以摘要形式显示，打开主题配置文件，找到auto-excerpt进行修改："><a href="#方法二：设置首页文章以摘要形式显示，打开主题配置文件，找到auto-excerpt进行修改：" class="headerlink" title="方法二：设置首页文章以摘要形式显示，打开主题配置文件，找到auto_excerpt进行修改："></a>方法二：设置首页文章以摘要形式显示，打开主题配置文件，找到auto_excerpt进行修改：</h5><pre class=" language-json"><code class="language-json">  auto_excerpt<span class="token operator">:</span>  enable<span class="token operator">:</span> <span class="token boolean">true</span>  length<span class="token operator">:</span> <span class="token number">150</span></code></pre><p>其中length代表显示摘要的截取字符长度。<br>注：这两种方法，在博客首页显示的效果不一样，根据自己的需要，选择自己喜欢的方法</p><h2 id="5、在博文中添加图片"><a href="#5、在博文中添加图片" class="headerlink" title="5、在博文中添加图片"></a>5、在博文中添加图片</h2><h5 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h5><p>(1)在hexo目录下，安装插件：</p><pre class=" language-nginx"><code class="language-nginx">npm install hexo<span class="token operator">-</span>asset<span class="token operator">-</span>image <span class="token operator">--</span>save</code></pre><p>(2)在hexo\source 目录下新建一个img文件夹，把图片放置在里面；<br>(3)在xxx.md文件中引用图片：</p><pre class=" language-markdown"><code class="language-markdown">![header]( img/header.jpg)</code></pre><h5 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h5><p>(1)在全局配置文件（hexo/_config.yml)中将post_asset_folder设置为true；<br>(2)创建文章（在创建的时候，会在hexo/source/_post目录下，生成一个XXX.md文件和一个同名的文件夹）：</p><pre><code>hexo new "XXX"</code></pre><p><img src="/2022/06/22/hexo01/image-20220622190357066.png" alt="image-20220622190357066"></p><p>(3)把XXX这个博文需要展示的图片放在XXX文件夹目录下；<br>(4)在XXX.md文件中引入图片的方式：</p><pre class=" language-markdown"><code class="language-markdown">{% asset_img example.jpg This is an example image %}</code></pre><h4 id="6、发布到Github上"><a href="#6、发布到Github上" class="headerlink" title="6、发布到Github上"></a>6、发布到Github上</h4><p>（1）发表的文章在本地预览无误后，在 Git Bash 命令窗口执行以下命令：</p><pre class=" language-bash"><code class="language-bash"><span class="token variable">$hexo</span> clean <span class="token variable">$hexo</span> g <span class="token variable">$hexo</span> d</code></pre><p>（2）在浏览器，访问自己的博客域名，即可看到刚 发布的文章</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 写作 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
