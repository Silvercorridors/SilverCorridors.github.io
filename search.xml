<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Gecco学习日记01</title>
      <link href="/2022/06/27/gecco01/"/>
      <url>/2022/06/27/gecco01/</url>
      
        <content type="html"><![CDATA[<h1 id="Gecco学习日记01：网络爬虫的定义与Gecco快速开始"><a href="#Gecco学习日记01：网络爬虫的定义与Gecco快速开始" class="headerlink" title="Gecco学习日记01：网络爬虫的定义与Gecco快速开始"></a>Gecco学习日记01：网络爬虫的定义与Gecco快速开始</h1><h2 id="什么是爬虫？"><a href="#什么是爬虫？" class="headerlink" title="什么是爬虫？"></a>什么是爬虫？</h2><p>WiKi中的定义：网络爬虫（英语：web crawler），也叫网络蜘蛛（spider），是一种用来自动浏览万维网的网络机器人。其目的一般为编纂<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E7%B4%A2%E5%BC%95">网络索引</a>。<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E">网络</a><a href="https://zh.wikipedia.org/wiki/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E">搜索引擎</a>等站点通过爬虫软件更新自身的<a href="https://zh.wikipedia.org/w/index.php?title=%E7%B6%B2%E7%AB%99%E5%85%A7%E5%AE%B9&amp;action=edit&amp;redlink=1">网站内容</a>或其对其他网站的索引。网络爬虫可以将自己所访问的页面保存下来，以便搜索引擎事后生成<a href="https://zh.wikipedia.org/w/index.php?title=%E7%B4%A2%E5%BC%95_(%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E)&amp;action=edit&amp;redlink=1">索引</a>供用户搜索。</p><p>通俗来讲，爬虫就是一个探测机器，它的基本操作就是模拟人的行为去各个网站溜达，点点按钮，查查数据，或者把看到的信息背回来。就像一只虫子在一幢楼里不知疲倦地爬来爬去。</p><p>由此我们可以知道，爬虫的应用领域有：搜索引擎、比价网站、舆情系统、知识信息储备。</p><h2 id="网络爬虫工作原理是什么？"><a href="#网络爬虫工作原理是什么？" class="headerlink" title="网络爬虫工作原理是什么？"></a><strong>网络爬虫工作原理是什么？</strong></h2><p>网络爬虫一般分为如下两个阶段：第一阶段，<strong>URL库初始化</strong>然后开始爬取；第二阶段，爬虫读取没有访问过的URL，来确定它的工作范围。对于所要抓取的URL，具体步骤如下：</p><ol><li>获取URL链接；</li><li>解析内容，获取URL相关数据；</li><li>存储有价值的数据；</li><li>对新抓取的RL进行规范化；</li><li>过滤掉不相关的URL；</li><li>将要抓取的URL更新到URL库中；</li><li>重复步骤2，直到终止条件为止。</li></ol><h2 id="爬虫实现策略包括哪些？"><a href="#爬虫实现策略包括哪些？" class="headerlink" title="爬虫实现策略包括哪些？"></a><strong>爬虫实现策略包括哪些？</strong></h2><ul><li>指定初始URL下载的选择策略</li><li>检测页面是否更新的重新访问策略</li><li>定义如何避免网站过度访问的约定性策略</li><li>如何部署分布式网络爬虫的并行策略</li></ul><p>网络爬虫主要爬取策略有：<strong>深度优先策略</strong>、<strong>宽度优先策略</strong>等等。</p><h2 id="一个典型的网络爬虫系统组成包括哪些？"><a href="#一个典型的网络爬虫系统组成包括哪些？" class="headerlink" title="一个典型的网络爬虫系统组成包括哪些？"></a><strong>一个典型的网络爬虫系统组成包括哪些？</strong></h2><p>网络爬虫本质是对网络资源的抓取、分析、过滤、存储。一个典型的网络爬虫系统组成主要有<strong>控制器，解析器，资源库</strong>三部分组成。</p><blockquote><p>控制器负责给多线程中的各个爬虫线程分配工作任务。</p><p>解析器的主要工作是下载网页，进行页面的处理。</p><p>资源库是用来存放下载到的网页资源，一般都采用大型的数据库存储，如Oracle数据库，并对其建立索引。</p></blockquote><h2 id="知己知彼：常用的反爬虫手段"><a href="#知己知彼：常用的反爬虫手段" class="headerlink" title="知己知彼：常用的反爬虫手段"></a>知己知彼：常用的反爬虫手段</h2><p>常见的反爬虫手段包括：统计IP访问限制、单个session访问量以及单个User-agent的访问，基于网站流量统计和日志分析反爬虫，通过Headers反爬虫，添加验证码限制等。</p><h2 id="介绍：什么是Gecco？"><a href="#介绍：什么是Gecco？" class="headerlink" title="介绍：什么是Gecco？"></a>介绍：什么是Gecco？</h2><p>Gecco 是一款基于 java 语言开发的轻量化的易用的网络爬虫。Gecco 整合了 jsoup、httpclient、fastjson、spring、htmlunit、redission 等优秀框架，让您只需要配置一些 jquery 风格的选择器就能很快的写出一个爬虫。</p><h3 id="Gecco主要特征"><a href="#Gecco主要特征" class="headerlink" title="Gecco主要特征"></a>Gecco主要特征</h3><ol><li>使用 jquery 风格的选择器抽取元素</li><li>支持爬取规则的动态配置和加载</li><li>支持页面中的异步 ajax 请求</li><li>支持页面中的 javascript 变量抽取</li><li>利用 Redis 实现分布式抓取</li><li>支持结合 Spring 开发业务逻辑</li><li>支持 htmlunit 扩展</li><li>支持插件扩展机制</li><li>支持下载时 UserAgent 随机选取</li><li>支持下载代理服务器随机选取</li></ol><h2 id="框架概述"><a href="#框架概述" class="headerlink" title="框架概述"></a>框架概述</h2><p><img src="/2022/06/27/gecco01/jiagou.jpg" alt="img"></p><h3 id="GeccoEngine"><a href="#GeccoEngine" class="headerlink" title="GeccoEngine"></a>GeccoEngine</h3><blockquote><p>GeccoEngine 是爬虫引擎，每个爬虫引擎最好是一个独立进程，在分布式爬虫场景下，建议每台爬虫服务器（物理机或者虚机）运行一个 GeccoEngine。爬虫引擎包括 Scheduler、Downloader、Spider、SpiderBeanFactory、PipelineFactory5 个主要模块。</p></blockquote><h3 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h3><blockquote><p>通常爬虫需要一个有效管理下载地址的角色，Scheduler 负责下载地址的管理。gecco 对初始地址的管理使用 StartScheduler，StartScheduler 内部采用一个阻塞的 FIFO 的队列。初始地址通常会派生出很多其他待抓取的地址，派生出来的其他地址采用 SpiderScheduler 进行管理，SpiderScheduler 内部采用线程安全的非阻塞 FIFO 队列。这种设计使的 gecco 对初始地址采用了深度遍历的策略，即一个线程抓取完一个初始地址后才会去抓取另外一个初始地址；对初始地址派生出来的地址，采用广度优先策略。</p></blockquote><h3 id="Downloader"><a href="#Downloader" class="headerlink" title="Downloader"></a>Downloader</h3><blockquote><p>Downloader 负责从 Scheduler 中获取需要下载的请求，gecco 默认采用 httpclient4.x 作为下载引擎。通过实现 Downloader 接口可以自定义自己的下载引擎。你也可以对每个请求定义 BeforeDownload 和 AfterDownload，实现不同的请求下载的个性需求。</p></blockquote><h3 id="SpiderBeanFactory"><a href="#SpiderBeanFactory" class="headerlink" title="SpiderBeanFactory"></a>SpiderBeanFactory</h3><blockquote><p>Gecco 将下载下来的内容渲染为 SpiderBean，所有爬虫渲染的 JavaBean 都统一继承 SpiderBean，SpiderBean 又分为 HtmlBean 和 JsonBean 分别对应 html 页面的渲染和 json 数据的渲染。SpiderBeanFactroy 会根据请求的 url 地址，匹配相应的 SpiderBean，同时生成该 SpiderBean 的上下文 SpiderBeanContext。上下文 SpiderBeanContext 会告知这个 SpiderBean 采用什么渲染器，采用那个下载器，渲染完成后采用哪些 pipeline 处理等相关上下文信息。</p></blockquote><h3 id="PipelineFactory"><a href="#PipelineFactory" class="headerlink" title="PipelineFactory"></a>PipelineFactory</h3><blockquote><p>pipeline 是 SpiderBean 渲染完成的后续业务处理单元，PipelineFactory 是 pipeline 的工厂类，负责 pipeline 实例化。通过扩展 PipelineFactory 就可以实现和 Spring 等业务处理框架的整合。</p></blockquote><h3 id="Spider"><a href="#Spider" class="headerlink" title="Spider"></a>Spider</h3><blockquote><p>Gecco 框架最核心的类应该是 <strong>Spider 线程</strong>，一个爬虫引擎可以同时运行多个 Spider 线程。Spider 描绘了这个框架运行的基本骨架，先从 Scheduler 获取请求，再通过 SpiderBeanFactory 匹配 SpiderBeanClass，再通过 SpiderBeanClass 找到 SpiderBean 的上下文，下载网页并对 SpiderBean 做渲染，将渲染后的 SpiderBean 交个 pipeline 处理。</p></blockquote><h2 id="Maven依赖配置"><a href="#Maven依赖配置" class="headerlink" title="Maven依赖配置"></a>Maven依赖配置</h2><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.geccocrawler<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>gecco<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>x.x.x<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><h2 id="项目quick-start源码"><a href="#项目quick-start源码" class="headerlink" title="项目quick-start源码"></a>项目quick-start源码</h2><p>@Gecco(matchUrl=”<a href="https://github.com/%7Buser%7D/%7Bproject%7D&quot;">https://github.com/{user}/{project}"</a>, pipelines=”consolePipeline”)<br>public class MyGithub implements HtmlBean {</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token operator">-</span>7127412585200687225L<span class="token punctuation">;</span><span class="token annotation punctuation">@RequestParameter</span><span class="token punctuation">(</span><span class="token string">"user"</span><span class="token punctuation">)</span><span class="token keyword">private</span> String user<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//url中的{user}值</span><span class="token annotation punctuation">@RequestParameter</span><span class="token punctuation">(</span><span class="token string">"project"</span><span class="token punctuation">)</span><span class="token keyword">private</span> String project<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//url中的{project}值</span><span class="token annotation punctuation">@Text</span><span class="token annotation punctuation">@HtmlField</span><span class="token punctuation">(</span>cssPath<span class="token operator">=</span><span class="token string">".pagehead-actions li:nth-child(2) .social-count"</span><span class="token punctuation">)</span><span class="token keyword">private</span> String star<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//抽取页面中的star</span><span class="token annotation punctuation">@Text</span><span class="token annotation punctuation">@HtmlField</span><span class="token punctuation">(</span>cssPath<span class="token operator">=</span><span class="token string">".pagehead-actions li:nth-child(3) .social-count"</span><span class="token punctuation">)</span><span class="token keyword">private</span> String fork<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//抽取页面中的fork</span><span class="token annotation punctuation">@Html</span><span class="token annotation punctuation">@HtmlField</span><span class="token punctuation">(</span>cssPath<span class="token operator">=</span><span class="token string">".entry-content"</span><span class="token punctuation">)</span><span class="token keyword">private</span> String readme<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//抽取页面中的readme</span><span class="token keyword">public</span> String <span class="token function">getReadme</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> readme<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setReadme</span><span class="token punctuation">(</span>String readme<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>readme <span class="token operator">=</span> readme<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> String <span class="token function">getUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> user<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setUser</span><span class="token punctuation">(</span>String user<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>user <span class="token operator">=</span> user<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> String <span class="token function">getProject</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> project<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setProject</span><span class="token punctuation">(</span>String project<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>project <span class="token operator">=</span> project<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> String <span class="token function">getStar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> star<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setStar</span><span class="token punctuation">(</span>String star<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>star <span class="token operator">=</span> star<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> String <span class="token function">getFork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> fork<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setFork</span><span class="token punctuation">(</span>String fork<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>fork <span class="token operator">=</span> fork<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    GeccoEngine<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//工程的包路径</span>    <span class="token punctuation">.</span><span class="token function">classpath</span><span class="token punctuation">(</span><span class="token string">"com.geccocrawler.gecco.demo"</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//开始抓取的页面地址</span>    <span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token string">"https://github.com/xtuhcy/gecco"</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//开启几个爬虫线程</span>    <span class="token punctuation">.</span><span class="token function">thread</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//单个爬虫每次抓取完一个请求后的间隔时间</span>    <span class="token punctuation">.</span><span class="token function">interval</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//循环抓取</span>    <span class="token punctuation">.</span><span class="token function">loop</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//使用pc端userAgent</span>    <span class="token punctuation">.</span><span class="token function">mobile</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//非阻塞方式运行</span>    <span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>}</p>]]></content>
      
      
      <categories>
          
          <category> Gecco </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gecco </tag>
            
            <tag> 网络爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程学习日记01：进程与线程</title>
      <link href="/2022/06/26/multithread01/"/>
      <url>/2022/06/26/multithread01/</url>
      
        <content type="html"><![CDATA[<h1 id="多线程学习：进程与线程"><a href="#多线程学习：进程与线程" class="headerlink" title="多线程学习：进程与线程"></a>多线程学习：进程与线程</h1><h2 id="前言：程序是如何跑起来的"><a href="#前言：程序是如何跑起来的" class="headerlink" title="前言：程序是如何跑起来的"></a>前言：程序是如何跑起来的</h2><p>​通常来说，像我们苦逼码农写的软件都是文本格式的代码，这些代码不能直接被计算机识别执行，需要使用编译器<font color:red="">编译</font>成操作系统或者虚拟机可以运行的代码（可执行代码），它们都被存储在文件系统中。</p><p>​要想让程序处理数据，完成计算任务，必须把程序从外部设备加载到内存中，并在操作系统的管理调度下交给 CPU 去执行，去运行起来，才能真正发挥软件的作用，程序运行起来以后，被称作<strong>进程</strong>。</p><p>​进程除了包含可执行的程序代码，还包括进程在运行期使用的内存<strong>堆空间、栈空间</strong>、供操作系统管理用的数据结构。</p><h2 id="进程（process）"><a href="#进程（process）" class="headerlink" title="进程（process）"></a>进程（process）</h2><ul><li><p>程序在系统上的一次执行过程</p></li><li><p>每个进程有独立的<strong>地址空间</strong>，进程切换时需要切换进程页表，以及切换运行环境（寄存器等）</p></li></ul><h4 id="早期内存分配机制"><a href="#早期内存分配机制" class="headerlink" title="早期内存分配机制"></a>早期内存分配机制</h4><p>  ​在早期的计算机中，要运行一个程序，会把这些程序全都装入内存，程序都是直接运行在内存上的，也就是说<strong>程序中访问的内存地址都是实际的物理内存地址</strong>。当计算机同时运行多个程序时，必须保证这些程序用到的内存总量要小于计算机实际物理内存的大小。</p><p>  ​那当程序同时运行多个程序时，操作系统是如何为这些程序分配内存的呢？</p><blockquote><p>举个栗子，某台计算机总的内存大小是 128M ，现在同时运行两个程序 A 和 B ， A 需占用内存 10M ， B 需占用内存 110M 。计算机在给程序分配内存时会采取这样的方法：先将内存中的前 10M 分配给程序 A ，接着再从内存中剩余的 118M 中划分出 110M 分配给程序 B 。</p></blockquote><p><img src="/2022/06/26/multithread01/215125w5kywrxk0yhzw1mj.png" alt="image.png"></p><p>这种分配方法可以保证程序 A 和程序 B 都能运行，但是<strong>这种简单的内存分配策略问题很多</strong>。</p><p><strong>安全的问题</strong> ：进程地址空间不隔离。由于程序都是直接访问物理内存，所以恶意程序可以随意修改别的进程的内存数据，以达到破坏的目的。有些非恶意的，但是有 bug 的程序也可能不小心修改了其它程序的内存数据，就会导致其它程序的运行出现异常。</p><p><strong>效率的问题 <strong>：内存使用效率低。在 A 和 B 都运行的情况下，如果用户又运行了程序 C，而程序 C 需要 20M 大小的内存才能运行，而此时系统只剩下 8M 的空间可供使用，所以此时系统必须在已运行的程序中选择一个将该程序的数据暂时拷贝到硬盘上</strong>（知识点：外存硬盘属于I/O设备）</strong>，释放出部分空间来供程序 C 使用，然后再将程序 C 的数据全部装入内存中运行。可以想象得到，在这个过程中，有大量的数据在装入装出，导致效率十分低下。</p><p><strong>地址随机性的问题</strong>：程序运行的地址不确定。当内存中的剩余空间可以满足程序 C 的要求后，操作系统会在剩余空间中随机分配一段连续的 20M 大小的空间给程序 C 使用，因为是随机分配的，所以程序运行的地址是不确定的。</p><h4 id="内存分段机制"><a href="#内存分段机制" class="headerlink" title="内存分段机制"></a>内存分段机制</h4><p><strong>虚内存</strong>：内存地址不是真正的物理地址，而是一个<strong>虚拟地址</strong>（通过映射计算）。<strong>按照这种方法，程序中访问的内存地址不再是实际的物理内存地址，而是一个虚拟地址，然后由操作系统将这个虚拟地址映射到适当的物理内存地址上</strong>。只要操作系统处理好虚拟地址到物理内存地址的<strong>映射</strong>，就可以保证不同的程序最终访问的内存地址位于不同的区域，彼此没有重叠，就可以达到内存地址空间隔离的效果。</p><p>当创建一个进程时，操作系统会为该进程分配一个 4GB 大小的虚拟进程地址空间。之所以是 4GB ，是因为在 32 位的操作系统中，一个指针长度是 4 字节，而 4 字节指针的寻址能力是从<code> 0x00000000</code>~`0xFFFFFFFF<code>，最大值 </code>0xFFFFFFFF` 表示的即为 4GB 大小的容量。</p><p>当进程创建时，每个进程都会有一个自己的 4GB 虚拟地址空间。要注意的是这个 4GB 的地址空间是“虚拟”的，并不是真实存在的，而且每个进程只能访问自己虚拟地址空间中的数据，无法访问别的进程中的数据，通过这种方法实现了进程间的<strong>地址隔离</strong>。</p><p>再举个例子。</p><blockquote><p>假设有两个进程 A 和 B ，进程 A 所需内存大小为 10M ，其虚拟地址空间分布在 0x00000000 到 0x00A00000 ，进程 B 所需内存为 100M ，其虚拟地址空间分布为 0x00000000 到 0x06400000 。那么按照分段的映射方法，进程 A 在物理内存上映射区域为 0x00100000 到 0x00B00000 ，进程 B 在物理内存上映射区域为0x00C00000 到 0x07000000 。于是进程 A 和进程 B 分别被映射到了不同的内存区间，彼此互不重叠，实现了地址隔离。从应用程序的角度看来，进程 A 的地址空间就是分布在 0x00000000 到 0x00A00000 </p></blockquote><p>在 Windows 系统下，这个虚拟地址空间被分成了 4 部分： <strong>NULL 指针区、用户区、 64KB 禁入区、内核区</strong>。<strong>应用程序能使用的只是用户区而已</strong>，大约 2GB 左右 ( 最大可以调整到 3GB) 。内核区为 2GB ，内核区保存的是系统线程调度、内存管理、设备驱动等数据，这部分数据供所有的进程共享，但应用程序是不能直接访问的。</p><p>这种分段的映射方法虽然解决了上述中的安全问题和地址随机性的问题，但并没能解决内存的使用效率问题。在分段的映射方法中，每次换入换出内存的都是整个程序， 这样会造成大量的磁盘访问操作，导致效率低下。所以这种映射方法还是稍显粗糙，粒度比较大。基于此情况，人们想到了粒度更小的内存分割和映射方法，这种方法就是分页 (Paging) 。 </p><h4 id="内存分页机制"><a href="#内存分页机制" class="headerlink" title="内存分页机制"></a>内存分页机制</h4><p>分页的基本方法是，将地址空间分成许多的页。每页的大小由 CPU 决定，然后由操作系统选择页的大小。目前 Inter 系列的 CPU 支持 4KB 或 4MB 的页大小，而 PC上目前都选择使用 4KB 。按这种选择， 4GB 虚拟地址空间共可以分成 1048576（1024*1024） 页， 512M 的物理内存可以分为 131072 个页。显然<strong>虚拟空间的页数要比物理空间的页数多得多</strong>。</p><blockquote><p>例如：银行存钱，张三：存1号箱，李四：存1号箱，但是两个1号箱并不是同一个，有一个特殊的对应表来查询实际的物理位置</p></blockquote><p>在分段的方法中，每次程序运行时总是把程序全部装入内存，而分页的方法则有所不同。分页的思想是程序运行时用到哪页就为哪页分配内存，没用到的页暂时保留在硬盘上。当用到这些页时再在物理地址空间中为这些页分配内存，然后建立虚拟地址空间中的页和刚分配的物理内存页间的映射。</p><h2 id="线程（Thread）"><a href="#线程（Thread）" class="headerlink" title="线程（Thread）"></a>线程（Thread）</h2><ul><li>定义：<strong>进程真正的执行过程是线程</strong>，每个进程在创立时会缺省的创立一个主线程，当然，进程还可以创建更多的线程，所有的线程属于这个进程，进程销毁时，进程下所有线程也销毁，<strong>同一个进程</strong>里面 <strong>切换线程</strong>时 **<font color="red">不需要切换页表</font>**（节约时间），需要切换运行时环境（寄存器等）</li><li>线程一定属于进程</li><li>每个线程都有独立的运行时空间</li><li>同一个进程里面 切换线程时 不需要切换页表（节约时间），需要切换运行时环境（寄存器等）</li><li>一个进程多个线程并发</li></ul><h4 id="线程池（Thread-Pool）"><a href="#线程池（Thread-Pool）" class="headerlink" title="线程池（Thread Pool）"></a>线程池（Thread Pool）</h4><p>线程池（Thread Pool）是一种基于池化思想管理线程的工具。线程过多会带来额外的开销，其中包括创建<strong>销毁线程的开销、调度线程的开销</strong>等等，同时也降低了计算机的整体性能。线程池维护多个线程，等待监督管理者分配可并发执行的任务。这种做法，一方面避免了处理任务时创建销毁线程开销的代价，另一方面避免了线程数量膨胀导致的过分调度问题，保证了对内核的充分利用。</p><p>使用线程池可以带来一系列好处：</p><ul><li><strong>降低资源消耗</strong>：通过池化技术重复利用已创建的线程，降低线程创建和销毁造成的损耗。</li><li><strong>提高响应速度</strong>：任务到达时，无需等待线程创建即可立即执行。</li><li><strong>提高线程的可管理性</strong>：线程是稀缺资源，如果无限制创建，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性。使用线程池可以进行统一的分配、调优和监控。</li><li><strong>提供更多更强大的功能</strong>：线程池具备可拓展性，允许开发人员向其中增加更多的功能。比如延时定时线程池ScheduledThreadPoolExecutor，就允许任务延期执行或定期执行。</li></ul><p>本章结束~~</p><end></end>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javaSE 面试题01</title>
      <link href="/2022/06/25/javasems01/"/>
      <url>/2022/06/25/javasems01/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-SE-面试题-零"><a href="#Java-SE-面试题-零" class="headerlink" title="Java SE 面试题 (零)"></a>Java SE 面试题 (零)</h1><p style="color:red;">    练习面试题需要将题目独立提取出来，以自问自答的形式反复练习。<br>    没有人能随随便便成功，加油吧，骚年！</p><h2 id="1-面向对象和面向过程的区别"><a href="#1-面向对象和面向过程的区别" class="headerlink" title="1. 面向对象和面向过程的区别"></a>1. 面向对象和面向过程的区别</h2><p><strong>面向过程：</strong> </p><p>优点：性能高，类的实例化是有较大开销的，且占用更多的内存，在注重性能的开发场合，例如单片机、嵌入式开发、Linux/Unix内核等场景中一般采用面向过程开发。</p><p>缺点：代码逻辑贴近机器逻辑，不易维护；不易复用；不易扩展。</p><p><strong>面向对象：</strong> </p><p>优点：易维护；易复用；易扩展；面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统。</p><p>缺点：性能比面向过程低，一般用于业务层、比如业务中间件。</p><h2 id="2-Java语言有哪些特点？"><a href="#2-Java语言有哪些特点？" class="headerlink" title="2. Java语言有哪些特点？"></a>2. Java语言有哪些特点？</h2><p>面向对象（封装，继承，多态）；</p><p>平台无关性（Java虚拟机实现平台无关性），编译与解释并存；</p><p>使用广泛，有很多可用的库</p><h2 id="3-什么是字节码？采用字节码的最大好处是什么？"><a href="#3-什么是字节码？采用字节码的最大好处是什么？" class="headerlink" title="3. 什么是字节码？采用字节码的最大好处是什么？"></a>3. 什么是字节码？采用字节码的最大好处是什么？</h2><p><strong>java中的编译器和解释器：</strong> </p><p>Java引入了虚拟机（JVM），即在机器和编译程序之间加入了一层抽象的虚拟的机器。</p><p>在不同的操作系统上，其实有不同的虚拟机，但是他们都提供给编译程序一个的共同的接口。编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。这种供虚拟机理解的代码叫做字节码（Java中是扩展名为.class的文件），它不面向任何特定的处理器，只面向虚拟机。</p><p>Java源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行，这就是上面提到的Java的特点的编译与解释并存。 </p><p>Java源代码—-&gt;编译器—-&gt;jvm可执行的Java字节码(即虚拟指令)—-&gt;jvm—-&gt;jvm中解释器—–&gt;机器可执行的二进制机器码—-&gt;程序运行。</p><p>JIT：Just In Time，虚拟机的一种优化手段，如果某个方法或者代码块频繁的被调用，虚拟机会把这段代码标记为“热点代码”，并将这段字节码一次性的编译为机器码，以提高运行效率。Java中的JIT是HotSpot。</p><p><strong>采用字节码的好处：</strong></p><p> Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。</p><h2 id="4-什么是JDK-什么是JRE？"><a href="#4-什么是JDK-什么是JRE？" class="headerlink" title="4. 什么是JDK? 什么是JRE？"></a>4. 什么是JDK? 什么是JRE？</h2><p>  JDK: 顾名思义它是给开发者提供的开发工具箱,是给程序开发者用的。它除了包括完整的JRE（Java Runtime Environment），Java运行环境，还包含了其他供开发者使用的工具包。</p><p>​        JDK中包括：</p><pre class=" language-markdown"><code class="language-markdown"><span class="token list punctuation">1.</span> javac：编译器<span class="token list punctuation">2.</span> java：运行工具<span class="token list punctuation">3.</span> jar：打包工具<span class="token list punctuation">4.</span> javadoc：文档生成器<span class="token list punctuation">5.</span> jdb debugger：调试工具</code></pre><p>  JRE:普通用户而只需要安装JRE（Java Runtime Environment）来 来运行Java程序。而程序开发者必须安装JDK来编译、调试程序。</p><h2 id="5-Java环境变量PATH和CLASSPATH"><a href="#5-Java环境变量PATH和CLASSPATH" class="headerlink" title="5. Java环境变量PATH和CLASSPATH"></a>5. Java环境变量PATH和CLASSPATH</h2><p><strong>PATH环境变量</strong>：</p><ol><li>设定%JAVA_HOME%，并将%JAVA_HOME%/bin加入到 PATH中</li><li>好处：可以在任何文件夹下调用javac, java 等工具。</li></ol><p><strong>CLASSPATH环境变量</strong></p><ol><li>java在运行字节码时，需要通过-classpath指定java类的所在位置，否则会报无法加载主类的错误</li><li>设定%CLASSPATH%后，可以使用这个变量用于指定-classpath参数</li></ol><h2 id="6-字符型常量和字符串常量的区别"><a href="#6-字符型常量和字符串常量的区别" class="headerlink" title="6. 字符型常量和字符串常量的区别"></a>6. 字符型常量和字符串常量的区别</h2><ol><li>形式上：字符常量是单引号引起的一个字符 字符串常量是双引号引起的若干个字符</li><li>含义上：字符常量相当于一个整形值(ASCII值),可以参加表达式运算 字符串常量代表一个地址值(该字符串在内存中存放位置)</li><li>占内存大小：字符常量只占一个字节 字符串常量占若干个字节(java和C\C++不一样，字符串不需要\0结尾)。</li></ol><h2 id="7-Java语言采用何种编码方案？有何特点？"><a href="#7-Java语言采用何种编码方案？有何特点？" class="headerlink" title="7. Java语言采用何种编码方案？有何特点？"></a>7. Java语言采用何种编码方案？有何特点？</h2><p>  Java语言采用Unicode编码标准，每个字符两个字节</p><p>​这里说的编码是Java代码运行时在内存中的编码，不是*.java在文件中的编码。</p><h2 id="8-构造器Constructor是否可被override"><a href="#8-构造器Constructor是否可被override" class="headerlink" title="8. 构造器Constructor是否可被override"></a>8. 构造器Constructor是否可被override</h2><p>  在讲继承的时候我们就知道父类的私有属性和构造方法并不能被继承，所以Constructor也就不能被override（子类覆盖父类的同名方法）,但是可以overload（方法相同，但是参数不同）,所以你可以看到一个类中有多个构造函数的情况。</p><p><strong>override和overload的区别：</strong></p><p>override：发生在父子类中，方法名、参数列表必须相同，返回值小于等于父类，抛出的异常小于等于父类，访问修饰符大于等于父类；如果父类方法访问修饰符为private则子类中就不是重写。</p><p>overload：发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。</p><h2 id="9-java-面向对象编程三大特性"><a href="#9-java-面向对象编程三大特性" class="headerlink" title="9. java 面向对象编程三大特性"></a>9. java 面向对象编程三大特性</h2><p>封装：对象的属性或者方法，可以隐藏起来，禁止被外部访问</p><pre class=" language-markdown"><code class="language-markdown"><span class="token code keyword">    9. 封装：访问权限 protected friendly(什么都不写，default)</span><span class="token code keyword">                 当前类   派生类   同一个package里的类    不同package里的类</span><span class="token code keyword">        public    Yes     Yes            Yes              Yes</span><span class="token code keyword">        protected Yes     Yes            Yes               No</span><span class="token code keyword">        (default) Yes  看是否同一个package Yes               No</span><span class="token code keyword">        private   Yes     No             No                No</span></code></pre><p>继承：派生类可以使用基类的属性和方法（一般方法，构造方法），也可以定义自己的属性和方法</p><p>多态：动态绑定，决定调用基类的方法还是派生类的方法，由实例事实上是哪个类的实例来决定，而不是由引用的类型决定。</p><h2 id="10-java中equals方法的用法以及-x3D-x3D-的用法"><a href="#10-java中equals方法的用法以及-x3D-x3D-的用法" class="headerlink" title="10. java中equals方法的用法以及==的用法"></a>10. java中equals方法的用法以及==的用法</h2><p>“==”比较两个变量本身的值，即两个对象在内存中的首地址。</p><p>“equals()”比较字符串中所包含的内容是否相同。</p><p>主要适用于String，原始类型的包装类</p><pre class=" language-java"><code class="language-java">String s1<span class="token punctuation">,</span>s2<span class="token punctuation">,</span>s3 <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">,</span> s4 <span class="token operator">=</span><span class="token string">"abc"</span> <span class="token punctuation">;</span>s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>s2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>s1 == s2: false</p><p>s1.equals(s2): true</p><p>s3 == s4: true</p><p>s3.equals(s4): true</p><pre class=" language-java"><code class="language-java">String s1 <span class="token operator">=</span> <span class="token string">"123"</span><span class="token punctuation">;</span> String s2 <span class="token operator">=</span> <span class="token string">"123"</span><span class="token punctuation">;</span> String s3 <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">;</span> String s4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> String s5 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> String s6 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1 <span class="token operator">==</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//（1）true </span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//（2）true </span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1 <span class="token operator">==</span> s3<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//（3）flase </span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>s3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//（4）flase </span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s4 <span class="token operator">==</span> s5<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//（5）flase </span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s4<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>s5<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//（6）true </span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s4 <span class="token operator">==</span> s6<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//（7）flase </span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s4<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>s6<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//（8）flase </span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1 <span class="token operator">==</span> s4<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//（9）false </span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>s4<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//（10）true </span></code></pre><p>特例：如果某些类没有override equals方法，那么他们使用Object.equals，这个方法也是比较地址的。</p><pre class=" language-java"><code class="language-java">StringBuffer s5 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>StringBuffer s6 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>s5 == s6: false</p><p>s5.equals(s6): false</p><h2 id="11-String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的？"><a href="#11-String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的？" class="headerlink" title="11. String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的？"></a>11. String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的？</h2><p><strong>可变性</strong> </p><p>String类中使用字符数组保存字符串，private final char value[]，所以string对象是不可变的。StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，char[]value，这两种对象都是可变的。  </p><p><strong>线程安全性</strong></p><p>String中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder是StringBuilder与StringBuffer的公共父类，定义了一些字符串的基本操作，如expandCapacity、append、insert、indexOf等公共方法。StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。  </p><p><strong>性能</strong></p><p>每次对String 类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String 对象。StringBuffer每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用StirngBuilder 相比使用StringBuffer 仅能获得10%~15% 左右的性能提升，但却要冒多线程不安全的风险。 </p><p><strong>对于三者使用的总结：</strong> 如果要操作少量的数据用：String；单线程操作字符串缓冲区 下操作大量数据：StringBuilder；多线程操作字符串缓冲区 下操作大量数据：StringBuffer。</p><h2 id="12-自动装箱与拆箱"><a href="#12-自动装箱与拆箱" class="headerlink" title="12. 自动装箱与拆箱"></a>12. 自动装箱与拆箱</h2><p><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</p><p><strong>拆箱</strong>：将包装类型转换为基本数据类型；  </p><p>Java使用自动装箱和拆箱机制，节省了常用数值的内存开销和创建对象的开销，提高了效率，由编译器来完成，编译器会在编译期根据语法决定是否进行装箱和拆箱动作。</p><h2 id="13-说出这段代码的运行结果："><a href="#13-说出这段代码的运行结果：" class="headerlink" title="13. 说出这段代码的运行结果："></a>13. 说出这段代码的运行结果：</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">aClass</span> <span class="token punctuation">{</span>         <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">static</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                      i<span class="token operator">++</span><span class="token punctuation">;</span>              System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 分别打印输出1</span>        <span class="token punctuation">}</span>                <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              aClass obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">aClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              obj<span class="token punctuation">.</span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              obj<span class="token punctuation">.</span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><p>报错：注意，虽然C\C++这样写是对的，java中static不可以修饰局部变量。</p><h2 id="14-在一个静态方法内调用一个非静态成员为什么是非法的？"><a href="#14-在一个静态方法内调用一个非静态成员为什么是非法的？" class="headerlink" title="14. 在一个静态方法内调用一个非静态成员为什么是非法的？"></a>14. 在一个静态方法内调用一个非静态成员为什么是非法的？</h2><p>  由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。</p><h2 id="15-在Java中定义一个不做事且没有参数的构造方法的作用"><a href="#15-在Java中定义一个不做事且没有参数的构造方法的作用" class="headerlink" title="15. 在Java中定义一个不做事且没有参数的构造方法的作用"></a>15. 在Java中定义一个不做事且没有参数的构造方法的作用</h2><p>  Java程序在执行子类的构造方法之前，如果没有用super()来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用super()来调用父类中特定的构造方法，则编译时将发生错误，因为Java程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。</p><h2 id="16-接口和抽象类的区别是什么？"><a href="#16-接口和抽象类的区别是什么？" class="headerlink" title="16. 接口和抽象类的区别是什么？"></a>16. 接口和抽象类的区别是什么？</h2><ol><li><p>接口的方法默认是public，在JDK 7及以前，所有方法在接口中不能有实现，JDK 8 及以后接口中可以用default关键字实现方法，抽象类可以有非抽象的方法</p></li><li><p>接口中不能有变量，构造函数和static静态代码块，只能有常量 public static final，而抽象类没有限制</p></li><li><p>一个类可以实现多个接口，但最多只能实现一个抽象类</p></li><li><p>一个类实现接口的话要实现接口的所有方法，而抽象类不一定</p></li><li><p>从设计层面来说，抽象类是对类的抽象，是一种模板设计，接口是行为能力的抽象，是一种行为的规范。</p></li></ol><h2 id="17-成员变量与局部变量的区别有那些？"><a href="#17-成员变量与局部变量的区别有那些？" class="headerlink" title="17. 成员变量与局部变量的区别有那些？"></a>17. 成员变量与局部变量的区别有那些？</h2><ol><li><p>从语法形式上，看成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；成员变量可以被public,private,static等修饰符所修饰，而局部变量不能被访问控制修饰符及static所修饰；成员变量和局部变量都能被final所修饰；</p></li><li><p>从变量在内存中的存储方式来看，成员变量是对象的一部分，而对象存在于堆内存，局部变量存在于栈内存</p></li><li><p>从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。</p></li><li><p>成员变量如果没有被赋初值，则会自动以类型的默认值而赋值（一种情况例外被final修饰但没有被static修饰的成员变量必须显示地赋值）；而局部变量则不会自动赋值。</p></li></ol><h2 id="18-创建一个对象用什么运算符？对象实体与对象引用有何不同？"><a href="#18-创建一个对象用什么运算符？对象实体与对象引用有何不同？" class="headerlink" title="18. 创建一个对象用什么运算符？对象实体与对象引用有何不同？"></a>18. 创建一个对象用什么运算符？对象实体与对象引用有何不同？</h2><p>  new运算符，new创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。一个对象引用可以指向0个或1个对象;一个对象可以有n个引用指向它。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo模板教程</title>
      <link href="/2022/06/22/hexo01/"/>
      <url>/2022/06/22/hexo01/</url>
      
        <content type="html"><![CDATA[<h2 id="1、新建文章"><a href="#1、新建文章" class="headerlink" title="1、新建文章"></a>1、新建文章</h2><blockquote><p>命令格式：</p><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token punctuation">[</span>layout<span class="token punctuation">]</span> <span class="token string">"title"</span> $ hexo n <span class="token punctuation">[</span>layout<span class="token punctuation">]</span> <span class="token string">"title"</span></code></pre></blockquote><p>创建文章前要先选定模板，在hexo中也叫做布局。hexo支持三种布局（layout）：post(默认)、draft、page。</p><p>我们先介绍如何使用已有布局，后面还将会介绍如何自定义布局。</p><p>在博客目录下输入以下命令时，会默认使用post布局，然后自动在<code>source\_posts</code>目录生成一个text1.md文件：</p><pre class=" language-bash"><code class="language-bash">$ hexo n text1</code></pre><p>也可以指定布局：</p><pre class=" language-bash"><code class="language-bash">$ hexo n <span class="token punctuation">[</span>layout_name<span class="token punctuation">]</span> draft1</code></pre><p>这样就创建了一个使用特定布局的名为draft1的文章。</p><p>打开创建的text1.md文件，我们可以看到文章开头包含以下内容：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token operator">--</span><span class="token operator">-</span>title<span class="token punctuation">:</span> text1author<span class="token punctuation">:</span> silverCorriodsdate<span class="token punctuation">:</span> <span class="token number">2022</span><span class="token operator">-</span><span class="token number">06</span><span class="token operator">-</span><span class="token number">21</span> <span class="token number">14</span><span class="token punctuation">:</span><span class="token number">13</span><span class="token punctuation">:</span><span class="token number">36</span>tags<span class="token punctuation">:</span> hexocategories<span class="token punctuation">:</span> blog<span class="token operator">--</span><span class="token operator">-</span></code></pre><p>上面的内容在hexo被称作<strong>Front-matter，实际上就是该文章的一些变量，用于实现一些特定的功能</strong>。例如<code>tags</code>与<code>categories</code>，渲染后的文章会添加相应的标签和分类。</p><p>如何自定义布局呢？实际上，布局是一个markdown文件，它们保存在<code>scaffolds/</code>目录下，可以看到hexo自带的三种布局其实就是三个<code>.md</code>文件：</p><h2 id="2、给文章添加分类和标签"><a href="#2、给文章添加分类和标签" class="headerlink" title="2、给文章添加分类和标签"></a>2、给文章添加分类和标签</h2><p>在<code>.md</code>文件中设置<code>tags</code>与<code>categories</code>，渲染后的文章会添加相应的标签和分类。</p><p><img src="/2022/06/22/hexo01/image-20220622185517433-16562188823113.png" alt="image-20220622185517433"></p><h2 id="3、启动服务器，本地测试"><a href="#3、启动服务器，本地测试" class="headerlink" title="3、启动服务器，本地测试"></a>3、启动服务器，本地测试</h2><pre class=" language-bash"><code class="language-bash"><span class="token variable">$hexo</span> s</code></pre><p>如图：</p><p><img src="/2022/06/22/hexo01/image-20220622185628911-16562169191001.png" alt="image-20220622185628911-16562169191001"></p><h2 id="4、添加“阅读全文”按钮"><a href="#4、添加“阅读全文”按钮" class="headerlink" title="4、添加“阅读全文”按钮"></a>4、添加“阅读全文”按钮</h2><h5 id="方法一：在文章任意你想添加的位置添加即可"><a href="#方法一：在文章任意你想添加的位置添加即可" class="headerlink" title="方法一：在文章任意你想添加的位置添加即可"></a>方法一：在文章任意你想添加的位置添加即可</h5><pre class=" language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>more<span class="token operator">--</span><span class="token operator">></span>        </code></pre><p>例如：<br>在这里.md里面的内容是：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token operator">--</span><span class="token operator">-</span>title<span class="token punctuation">:</span> 在这里date<span class="token punctuation">:</span> <span class="token number">2018</span><span class="token operator">-</span><span class="token number">08</span><span class="token operator">-</span><span class="token number">02</span> <span class="token number">11</span><span class="token punctuation">:</span><span class="token number">41</span><span class="token punctuation">:</span><span class="token number">10</span>tags<span class="token punctuation">:</span><span class="token operator">-</span> 博客<span class="token operator">-</span> hexocategories<span class="token punctuation">:</span> web前端<span class="token operator">--</span><span class="token operator">-</span>javascript是一门充满活力、简单易用的语言，又是一门具有许多复杂微妙技术的语言。即使是经验丰富的javascript开发者，如果没有认真学习的话，也无法真正理解它们，这就是javascript的矛盾之处。由于javascript不必理解就可以使用，因此通常来说很难真正理解语言本身，这就是我们面临的挑战。不满足于只是让代码正常工作，而是想要弄清楚为什么，勇于挑战这条崎岖颠簸的少有人走的路，拥抱整个javascript<span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>more<span class="token operator">--</span><span class="token operator">></span>后面的内容在首页不显示，只显示到<span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>more<span class="token operator">--</span><span class="token operator">></span>这里</code></pre><p>效果示例：</p><p><img src="/2022/06/22/hexo01/image-20220622185851114.png" alt="image-20220622185851114"></p><h5 id="方法二：设置首页文章以摘要形式显示，打开主题配置文件，找到auto-excerpt进行修改："><a href="#方法二：设置首页文章以摘要形式显示，打开主题配置文件，找到auto-excerpt进行修改：" class="headerlink" title="方法二：设置首页文章以摘要形式显示，打开主题配置文件，找到auto_excerpt进行修改："></a>方法二：设置首页文章以摘要形式显示，打开主题配置文件，找到auto_excerpt进行修改：</h5><pre class=" language-json"><code class="language-json">  auto_excerpt<span class="token operator">:</span>  enable<span class="token operator">:</span> <span class="token boolean">true</span>  length<span class="token operator">:</span> <span class="token number">150</span></code></pre><p>其中length代表显示摘要的截取字符长度。<br>注：这两种方法，在博客首页显示的效果不一样，根据自己的需要，选择自己喜欢的方法</p><h2 id="5、在博文中添加图片"><a href="#5、在博文中添加图片" class="headerlink" title="5、在博文中添加图片"></a>5、在博文中添加图片</h2><h5 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h5><p>(1)在hexo目录下，安装插件：</p><pre class=" language-nginx"><code class="language-nginx">npm install hexo<span class="token operator">-</span>asset<span class="token operator">-</span>image <span class="token operator">--</span>save</code></pre><p>(2)在hexo\source 目录下新建一个img文件夹，把图片放置在里面；<br>(3)在xxx.md文件中引用图片：</p><pre class=" language-markdown"><code class="language-markdown">![header]( img/header.jpg)</code></pre><h5 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h5><p>(1)在全局配置文件（hexo/_config.yml)中将post_asset_folder设置为true；<br>(2)创建文章（在创建的时候，会在hexo/source/_post目录下，生成一个XXX.md文件和一个同名的文件夹）：</p><pre><code>hexo new "XXX"</code></pre><p><img src="/2022/06/22/hexo01/image-20220622190357066.png" alt="image-20220622190357066"></p><p>(3)把XXX这个博文需要展示的图片放在XXX文件夹目录下；<br>(4)在XXX.md文件中引入图片的方式：</p><pre class=" language-markdown"><code class="language-markdown">{% asset_img example.jpg This is an example image %}</code></pre><h4 id="6、发布到Github上"><a href="#6、发布到Github上" class="headerlink" title="6、发布到Github上"></a>6、发布到Github上</h4><p>（1）发表的文章在本地预览无误后，在 Git Bash 命令窗口执行以下命令：</p><pre class=" language-bash"><code class="language-bash"><span class="token variable">$hexo</span> clean <span class="token variable">$hexo</span> g <span class="token variable">$hexo</span> d</code></pre><p>（2）在浏览器，访问自己的博客域名，即可看到刚 发布的文章</p>]]></content>
      
      
      <categories>
          
          <category> Hexo教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 写作 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
