<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>javaSE 面试题01</title>
      <link href="/2022/06/25/javasems01/"/>
      <url>/2022/06/25/javasems01/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-SE-面试题-零"><a href="#Java-SE-面试题-零" class="headerlink" title="Java SE 面试题 (零)"></a>Java SE 面试题 (零)</h1><p style="color:red;">    练习面试题需要将题目独立提取出来，以自问自答的形式反复练习。<br>    没有人能随随便便成功，加油吧，骚年！</p><h2 id="1-面向对象和面向过程的区别"><a href="#1-面向对象和面向过程的区别" class="headerlink" title="1. 面向对象和面向过程的区别"></a>1. 面向对象和面向过程的区别</h2><p><strong>面向过程：</strong> </p><p>优点：性能高，类的实例化是有较大开销的，且占用更多的内存，在注重性能的开发场合，例如单片机、嵌入式开发、Linux/Unix内核等场景中一般采用面向过程开发。</p><p>缺点：代码逻辑贴近机器逻辑，不易维护；不易复用；不易扩展。</p><p><strong>面向对象：</strong> </p><p>优点：易维护；易复用；易扩展；面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统。</p><p>缺点：性能比面向过程低，一般用于业务层、比如业务中间件。</p><h2 id="2-Java语言有哪些特点？"><a href="#2-Java语言有哪些特点？" class="headerlink" title="2. Java语言有哪些特点？"></a>2. Java语言有哪些特点？</h2><p>面向对象（封装，继承，多态）；</p><p>平台无关性（Java虚拟机实现平台无关性），编译与解释并存；</p><p>使用广泛，有很多可用的库</p><h2 id="3-什么是字节码？采用字节码的最大好处是什么？"><a href="#3-什么是字节码？采用字节码的最大好处是什么？" class="headerlink" title="3. 什么是字节码？采用字节码的最大好处是什么？"></a>3. 什么是字节码？采用字节码的最大好处是什么？</h2><p><strong>java中的编译器和解释器：</strong> </p><p>Java引入了虚拟机（JVM），即在机器和编译程序之间加入了一层抽象的虚拟的机器。</p><p>在不同的操作系统上，其实有不同的虚拟机，但是他们都提供给编译程序一个的共同的接口。编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。这种供虚拟机理解的代码叫做字节码（Java中是扩展名为.class的文件），它不面向任何特定的处理器，只面向虚拟机。</p><p>Java源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行，这就是上面提到的Java的特点的编译与解释并存。 </p><p>Java源代码—-&gt;编译器—-&gt;jvm可执行的Java字节码(即虚拟指令)—-&gt;jvm—-&gt;jvm中解释器—–&gt;机器可执行的二进制机器码—-&gt;程序运行。</p><p>JIT：Just In Time，虚拟机的一种优化手段，如果某个方法或者代码块频繁的被调用，虚拟机会把这段代码标记为“热点代码”，并将这段字节码一次性的编译为机器码，以提高运行效率。Java中的JIT是HotSpot。</p><p><strong>采用字节码的好处：</strong></p><p> Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。</p><h2 id="4-什么是JDK-什么是JRE？"><a href="#4-什么是JDK-什么是JRE？" class="headerlink" title="4. 什么是JDK? 什么是JRE？"></a>4. 什么是JDK? 什么是JRE？</h2><p>  JDK: 顾名思义它是给开发者提供的开发工具箱,是给程序开发者用的。它除了包括完整的JRE（Java Runtime Environment），Java运行环境，还包含了其他供开发者使用的工具包。</p><p>​        JDK中包括：</p><pre class=" language-markdown"><code class="language-markdown"><span class="token list punctuation">1.</span> javac：编译器<span class="token list punctuation">2.</span> java：运行工具<span class="token list punctuation">3.</span> jar：打包工具<span class="token list punctuation">4.</span> javadoc：文档生成器<span class="token list punctuation">5.</span> jdb debugger：调试工具</code></pre><p>  JRE:普通用户而只需要安装JRE（Java Runtime Environment）来 来运行Java程序。而程序开发者必须安装JDK来编译、调试程序。</p><h2 id="5-Java环境变量PATH和CLASSPATH"><a href="#5-Java环境变量PATH和CLASSPATH" class="headerlink" title="5. Java环境变量PATH和CLASSPATH"></a>5. Java环境变量PATH和CLASSPATH</h2><p><strong>PATH环境变量</strong>：</p><ol><li>设定%JAVA_HOME%，并将%JAVA_HOME%/bin加入到 PATH中</li><li>好处：可以在任何文件夹下调用javac, java 等工具。</li></ol><p><strong>CLASSPATH环境变量</strong></p><ol><li>java在运行字节码时，需要通过-classpath指定java类的所在位置，否则会报无法加载主类的错误</li><li>设定%CLASSPATH%后，可以使用这个变量用于指定-classpath参数</li></ol><h2 id="6-字符型常量和字符串常量的区别"><a href="#6-字符型常量和字符串常量的区别" class="headerlink" title="6. 字符型常量和字符串常量的区别"></a>6. 字符型常量和字符串常量的区别</h2><ol><li>形式上：字符常量是单引号引起的一个字符 字符串常量是双引号引起的若干个字符</li><li>含义上：字符常量相当于一个整形值(ASCII值),可以参加表达式运算 字符串常量代表一个地址值(该字符串在内存中存放位置)</li><li>占内存大小：字符常量只占一个字节 字符串常量占若干个字节(java和C\C++不一样，字符串不需要\0结尾)。</li></ol><h2 id="7-Java语言采用何种编码方案？有何特点？"><a href="#7-Java语言采用何种编码方案？有何特点？" class="headerlink" title="7. Java语言采用何种编码方案？有何特点？"></a>7. Java语言采用何种编码方案？有何特点？</h2><p>  Java语言采用Unicode编码标准，每个字符两个字节</p><p>​这里说的编码是Java代码运行时在内存中的编码，不是*.java在文件中的编码。</p><h2 id="8-构造器Constructor是否可被override"><a href="#8-构造器Constructor是否可被override" class="headerlink" title="8. 构造器Constructor是否可被override"></a>8. 构造器Constructor是否可被override</h2><p>  在讲继承的时候我们就知道父类的私有属性和构造方法并不能被继承，所以Constructor也就不能被override（子类覆盖父类的同名方法）,但是可以overload（方法相同，但是参数不同）,所以你可以看到一个类中有多个构造函数的情况。</p><p><strong>override和overload的区别：</strong></p><p>override：发生在父子类中，方法名、参数列表必须相同，返回值小于等于父类，抛出的异常小于等于父类，访问修饰符大于等于父类；如果父类方法访问修饰符为private则子类中就不是重写。</p><p>overload：发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。</p><h2 id="9-java-面向对象编程三大特性"><a href="#9-java-面向对象编程三大特性" class="headerlink" title="9. java 面向对象编程三大特性"></a>9. java 面向对象编程三大特性</h2><p>封装：对象的属性或者方法，可以隐藏起来，禁止被外部访问</p><pre class=" language-markdown"><code class="language-markdown"><span class="token code keyword">    9. 封装：访问权限 protected friendly(什么都不写，default)</span><span class="token code keyword">                 当前类   派生类   同一个package里的类    不同package里的类</span><span class="token code keyword">        public    Yes     Yes            Yes              Yes</span><span class="token code keyword">        protected Yes     Yes            Yes               No</span><span class="token code keyword">        (default) Yes  看是否同一个package Yes               No</span><span class="token code keyword">        private   Yes     No             No                No</span></code></pre><p>继承：派生类可以使用基类的属性和方法（一般方法，构造方法），也可以定义自己的属性和方法</p><p>多态：动态绑定，决定调用基类的方法还是派生类的方法，由实例事实上是哪个类的实例来决定，而不是由引用的类型决定。</p><h2 id="10-java中equals方法的用法以及-x3D-x3D-的用法"><a href="#10-java中equals方法的用法以及-x3D-x3D-的用法" class="headerlink" title="10. java中equals方法的用法以及==的用法"></a>10. java中equals方法的用法以及==的用法</h2><p>“==”比较两个变量本身的值，即两个对象在内存中的首地址。</p><p>“equals()”比较字符串中所包含的内容是否相同。</p><p>主要适用于String，原始类型的包装类</p><pre class=" language-java"><code class="language-java">String s1<span class="token punctuation">,</span>s2<span class="token punctuation">,</span>s3 <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">,</span> s4 <span class="token operator">=</span><span class="token string">"abc"</span> <span class="token punctuation">;</span>s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>s2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>s1 == s2: false</p><p>s1.equals(s2): true</p><p>s3 == s4: true</p><p>s3.equals(s4): true</p><pre class=" language-java"><code class="language-java">String s1 <span class="token operator">=</span> <span class="token string">"123"</span><span class="token punctuation">;</span> String s2 <span class="token operator">=</span> <span class="token string">"123"</span><span class="token punctuation">;</span> String s3 <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">;</span> String s4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> String s5 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> String s6 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1 <span class="token operator">==</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//（1）true </span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//（2）true </span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1 <span class="token operator">==</span> s3<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//（3）flase </span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>s3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//（4）flase </span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s4 <span class="token operator">==</span> s5<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//（5）flase </span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s4<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>s5<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//（6）true </span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s4 <span class="token operator">==</span> s6<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//（7）flase </span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s4<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>s6<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//（8）flase </span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1 <span class="token operator">==</span> s4<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//（9）false </span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>s4<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//（10）true </span></code></pre><p>特例：如果某些类没有override equals方法，那么他们使用Object.equals，这个方法也是比较地址的。</p><pre class=" language-java"><code class="language-java">StringBuffer s5 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>StringBuffer s6 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>s5 == s6: false</p><p>s5.equals(s6): false</p><h2 id="11-String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的？"><a href="#11-String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的？" class="headerlink" title="11. String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的？"></a>11. String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的？</h2><p><strong>可变性</strong> </p><p>String类中使用字符数组保存字符串，private final char value[]，所以string对象是不可变的。StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，char[]value，这两种对象都是可变的。  </p><p><strong>线程安全性</strong></p><p>String中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder是StringBuilder与StringBuffer的公共父类，定义了一些字符串的基本操作，如expandCapacity、append、insert、indexOf等公共方法。StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。  </p><p><strong>性能</strong></p><p>每次对String 类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String 对象。StringBuffer每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用StirngBuilder 相比使用StringBuffer 仅能获得10%~15% 左右的性能提升，但却要冒多线程不安全的风险。 </p><p><strong>对于三者使用的总结：</strong> 如果要操作少量的数据用：String；单线程操作字符串缓冲区 下操作大量数据：StringBuilder；多线程操作字符串缓冲区 下操作大量数据：StringBuffer。</p><h2 id="12-自动装箱与拆箱"><a href="#12-自动装箱与拆箱" class="headerlink" title="12. 自动装箱与拆箱"></a>12. 自动装箱与拆箱</h2><p><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</p><p><strong>拆箱</strong>：将包装类型转换为基本数据类型；  </p><p>Java使用自动装箱和拆箱机制，节省了常用数值的内存开销和创建对象的开销，提高了效率，由编译器来完成，编译器会在编译期根据语法决定是否进行装箱和拆箱动作。</p><h2 id="13-说出这段代码的运行结果："><a href="#13-说出这段代码的运行结果：" class="headerlink" title="13. 说出这段代码的运行结果："></a>13. 说出这段代码的运行结果：</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">aClass</span> <span class="token punctuation">{</span>         <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">static</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                      i<span class="token operator">++</span><span class="token punctuation">;</span>              System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 分别打印输出1</span>        <span class="token punctuation">}</span>                <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              aClass obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">aClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              obj<span class="token punctuation">.</span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              obj<span class="token punctuation">.</span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><p>报错：注意，虽然C\C++这样写是对的，java中static不可以修饰局部变量。</p><h2 id="14-在一个静态方法内调用一个非静态成员为什么是非法的？"><a href="#14-在一个静态方法内调用一个非静态成员为什么是非法的？" class="headerlink" title="14. 在一个静态方法内调用一个非静态成员为什么是非法的？"></a>14. 在一个静态方法内调用一个非静态成员为什么是非法的？</h2><p>  由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。</p><h2 id="15-在Java中定义一个不做事且没有参数的构造方法的作用"><a href="#15-在Java中定义一个不做事且没有参数的构造方法的作用" class="headerlink" title="15. 在Java中定义一个不做事且没有参数的构造方法的作用"></a>15. 在Java中定义一个不做事且没有参数的构造方法的作用</h2><p>  Java程序在执行子类的构造方法之前，如果没有用super()来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用super()来调用父类中特定的构造方法，则编译时将发生错误，因为Java程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。</p><h2 id="16-接口和抽象类的区别是什么？"><a href="#16-接口和抽象类的区别是什么？" class="headerlink" title="16. 接口和抽象类的区别是什么？"></a>16. 接口和抽象类的区别是什么？</h2><ol><li><p>接口的方法默认是public，在JDK 7及以前，所有方法在接口中不能有实现，JDK 8 及以后接口中可以用default关键字实现方法，抽象类可以有非抽象的方法</p></li><li><p>接口中不能有变量，构造函数和static静态代码块，只能有常量 public static final，而抽象类没有限制</p></li><li><p>一个类可以实现多个接口，但最多只能实现一个抽象类</p></li><li><p>一个类实现接口的话要实现接口的所有方法，而抽象类不一定</p></li><li><p>从设计层面来说，抽象类是对类的抽象，是一种模板设计，接口是行为能力的抽象，是一种行为的规范。</p></li></ol><h2 id="17-成员变量与局部变量的区别有那些？"><a href="#17-成员变量与局部变量的区别有那些？" class="headerlink" title="17. 成员变量与局部变量的区别有那些？"></a>17. 成员变量与局部变量的区别有那些？</h2><ol><li><p>从语法形式上，看成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；成员变量可以被public,private,static等修饰符所修饰，而局部变量不能被访问控制修饰符及static所修饰；成员变量和局部变量都能被final所修饰；</p></li><li><p>从变量在内存中的存储方式来看，成员变量是对象的一部分，而对象存在于堆内存，局部变量存在于栈内存</p></li><li><p>从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。</p></li><li><p>成员变量如果没有被赋初值，则会自动以类型的默认值而赋值（一种情况例外被final修饰但没有被static修饰的成员变量必须显示地赋值）；而局部变量则不会自动赋值。</p></li></ol><h2 id="18-创建一个对象用什么运算符？对象实体与对象引用有何不同？"><a href="#18-创建一个对象用什么运算符？对象实体与对象引用有何不同？" class="headerlink" title="18. 创建一个对象用什么运算符？对象实体与对象引用有何不同？"></a>18. 创建一个对象用什么运算符？对象实体与对象引用有何不同？</h2><p>  new运算符，new创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。一个对象引用可以指向0个或1个对象;一个对象可以有n个引用指向它。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo模板教程</title>
      <link href="/2022/06/22/hexo01/"/>
      <url>/2022/06/22/hexo01/</url>
      
        <content type="html"><![CDATA[<h2 id="1、新建文章"><a href="#1、新建文章" class="headerlink" title="1、新建文章"></a>1、新建文章</h2><blockquote><p>命令格式：</p><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token punctuation">[</span>layout<span class="token punctuation">]</span> <span class="token string">"title"</span> $ hexo n <span class="token punctuation">[</span>layout<span class="token punctuation">]</span> <span class="token string">"title"</span></code></pre></blockquote><p>创建文章前要先选定模板，在hexo中也叫做布局。hexo支持三种布局（layout）：post(默认)、draft、page。</p><p>我们先介绍如何使用已有布局，后面还将会介绍如何自定义布局。</p><p>在博客目录下输入以下命令时，会默认使用post布局，然后自动在<code>source\_posts</code>目录生成一个text1.md文件：</p><pre class=" language-bash"><code class="language-bash">$ hexo n text1</code></pre><p>也可以指定布局：</p><pre class=" language-bash"><code class="language-bash">$ hexo n <span class="token punctuation">[</span>layout_name<span class="token punctuation">]</span> draft1</code></pre><p>这样就创建了一个使用特定布局的名为draft1的文章。</p><p>打开创建的text1.md文件，我们可以看到文章开头包含以下内容：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token operator">--</span><span class="token operator">-</span>title<span class="token punctuation">:</span> text1author<span class="token punctuation">:</span> silverCorriodsdate<span class="token punctuation">:</span> <span class="token number">2022</span><span class="token operator">-</span><span class="token number">06</span><span class="token operator">-</span><span class="token number">21</span> <span class="token number">14</span><span class="token punctuation">:</span><span class="token number">13</span><span class="token punctuation">:</span><span class="token number">36</span>tags<span class="token punctuation">:</span> hexocategories<span class="token punctuation">:</span> blog<span class="token operator">--</span><span class="token operator">-</span></code></pre><p>上面的内容在hexo被称作<strong>Front-matter，实际上就是该文章的一些变量，用于实现一些特定的功能</strong>。例如<code>tags</code>与<code>categories</code>，渲染后的文章会添加相应的标签和分类。</p><p>如何自定义布局呢？实际上，布局是一个markdown文件，它们保存在<code>scaffolds/</code>目录下，可以看到hexo自带的三种布局其实就是三个<code>.md</code>文件：</p><h2 id="2、给文章添加分类和标签"><a href="#2、给文章添加分类和标签" class="headerlink" title="2、给文章添加分类和标签"></a>2、给文章添加分类和标签</h2><p>在<code>.md</code>文件中设置<code>tags</code>与<code>categories</code>，渲染后的文章会添加相应的标签和分类。</p><p><img src="/2022/06/22/hexo01/image-20220622185517433-16562188823113.png" alt="image-20220622185517433"></p><h2 id="3、启动服务器，本地测试"><a href="#3、启动服务器，本地测试" class="headerlink" title="3、启动服务器，本地测试"></a>3、启动服务器，本地测试</h2><pre class=" language-bash"><code class="language-bash"><span class="token variable">$hexo</span> s</code></pre><p>如图：</p><p><img src="/2022/06/22/hexo01/image-20220622185628911-16562169191001.png" alt="image-20220622185628911-16562169191001"></p><h2 id="4、添加“阅读全文”按钮"><a href="#4、添加“阅读全文”按钮" class="headerlink" title="4、添加“阅读全文”按钮"></a>4、添加“阅读全文”按钮</h2><h5 id="方法一：在文章任意你想添加的位置添加即可"><a href="#方法一：在文章任意你想添加的位置添加即可" class="headerlink" title="方法一：在文章任意你想添加的位置添加即可"></a>方法一：在文章任意你想添加的位置添加即可</h5><pre class=" language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>more<span class="token operator">--</span><span class="token operator">></span>        </code></pre><p>例如：<br>在这里.md里面的内容是：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token operator">--</span><span class="token operator">-</span>title<span class="token punctuation">:</span> 在这里date<span class="token punctuation">:</span> <span class="token number">2018</span><span class="token operator">-</span><span class="token number">08</span><span class="token operator">-</span><span class="token number">02</span> <span class="token number">11</span><span class="token punctuation">:</span><span class="token number">41</span><span class="token punctuation">:</span><span class="token number">10</span>tags<span class="token punctuation">:</span><span class="token operator">-</span> 博客<span class="token operator">-</span> hexocategories<span class="token punctuation">:</span> web前端<span class="token operator">--</span><span class="token operator">-</span>javascript是一门充满活力、简单易用的语言，又是一门具有许多复杂微妙技术的语言。即使是经验丰富的javascript开发者，如果没有认真学习的话，也无法真正理解它们，这就是javascript的矛盾之处。由于javascript不必理解就可以使用，因此通常来说很难真正理解语言本身，这就是我们面临的挑战。不满足于只是让代码正常工作，而是想要弄清楚为什么，勇于挑战这条崎岖颠簸的少有人走的路，拥抱整个javascript<span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>more<span class="token operator">--</span><span class="token operator">></span>后面的内容在首页不显示，只显示到<span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>more<span class="token operator">--</span><span class="token operator">></span>这里</code></pre><p>效果示例：</p><p><img src="/2022/06/22/hexo01/image-20220622185851114.png" alt="image-20220622185851114"></p><h5 id="方法二：设置首页文章以摘要形式显示，打开主题配置文件，找到auto-excerpt进行修改："><a href="#方法二：设置首页文章以摘要形式显示，打开主题配置文件，找到auto-excerpt进行修改：" class="headerlink" title="方法二：设置首页文章以摘要形式显示，打开主题配置文件，找到auto_excerpt进行修改："></a>方法二：设置首页文章以摘要形式显示，打开主题配置文件，找到auto_excerpt进行修改：</h5><pre class=" language-json"><code class="language-json">  auto_excerpt<span class="token operator">:</span>  enable<span class="token operator">:</span> <span class="token boolean">true</span>  length<span class="token operator">:</span> <span class="token number">150</span></code></pre><p>其中length代表显示摘要的截取字符长度。<br>注：这两种方法，在博客首页显示的效果不一样，根据自己的需要，选择自己喜欢的方法</p><h2 id="5、在博文中添加图片"><a href="#5、在博文中添加图片" class="headerlink" title="5、在博文中添加图片"></a>5、在博文中添加图片</h2><h5 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h5><p>(1)在hexo目录下，安装插件：</p><pre class=" language-nginx"><code class="language-nginx">npm install hexo<span class="token operator">-</span>asset<span class="token operator">-</span>image <span class="token operator">--</span>save</code></pre><p>(2)在hexo\source 目录下新建一个img文件夹，把图片放置在里面；<br>(3)在xxx.md文件中引用图片：</p><pre class=" language-markdown"><code class="language-markdown">![header]( img/header.jpg)</code></pre><h5 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h5><p>(1)在全局配置文件（hexo/_config.yml)中将post_asset_folder设置为true；<br>(2)创建文章（在创建的时候，会在hexo/source/_post目录下，生成一个XXX.md文件和一个同名的文件夹）：</p><pre><code>hexo new "XXX"</code></pre><p><img src="/2022/06/22/hexo01/image-20220622190357066.png" alt="image-20220622190357066"></p><p>(3)把XXX这个博文需要展示的图片放在XXX文件夹目录下；<br>(4)在XXX.md文件中引入图片的方式：</p><pre class=" language-markdown"><code class="language-markdown">{% asset_img example.jpg This is an example image %}</code></pre><h4 id="6、发布到Github上"><a href="#6、发布到Github上" class="headerlink" title="6、发布到Github上"></a>6、发布到Github上</h4><p>（1）发表的文章在本地预览无误后，在 Git Bash 命令窗口执行以下命令：</p><pre class=" language-bash"><code class="language-bash"><span class="token variable">$hexo</span> clean <span class="token variable">$hexo</span> g <span class="token variable">$hexo</span> d</code></pre><p>（2）在浏览器，访问自己的博客域名，即可看到刚 发布的文章</p>]]></content>
      
      
      <categories>
          
          <category> Hexo教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 写作 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/06/20/hello-world/"/>
      <url>/2022/06/20/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
